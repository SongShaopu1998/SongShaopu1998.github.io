I"H<h1 id="装饰器">装饰器</h1>

<p>记得上篇文章中<strong>闭包</strong>的基本构型吗？</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">88</span>
    <span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f2</span>

<span class="n">action</span> <span class="o">=</span> <span class="n">f1</span><span class="p">()</span>
<span class="n">action</span><span class="p">()</span>

<span class="mi">88</span>
</code></pre></div></div>

<p>我们对它稍微做点改变：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f2</span>

<span class="n">action1</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">action2</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">action1</span><span class="p">()</span>
<span class="n">action2</span><span class="p">()</span>

<span class="mi">1</span>
<span class="mi">2</span>
</code></pre></div></div>

<p>我们把定义于外层函数内部的变量放到了参数的位置上，不过没关系，根据我们已知的闭包特性：函数记住了他的外层作用域，这么做完全可以。那么问题来了，如果我们把函数作为外部函数的参数传进去会发生什么呢？这就是我们常说的装饰器。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">some_func</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
    	<span class="k">print</span> <span class="s">"before some_func"</span>
       	<span class="n">ret</span> <span class="o">=</span> <span class="n">some_func</span><span class="p">()</span> <span class="c1"># 1
</span>        <span class="k">return</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="n">inner</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
	<span class="k">return</span> <span class="mi">1</span>
<span class="n">decorated</span> <span class="o">=</span> <span class="n">outer</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1"># 2
</span>
<span class="n">decorated</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">before</span> <span class="n">some_func</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span>
</code></pre></div></div>

<p>本示例来自与<a href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/#section_10">http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/#section_10</a></p>

<p>在这里，变量<code class="language-plaintext highlighter-rouge">decorated</code>就是<code class="language-plaintext highlighter-rouge">foo</code>的一个<strong>装饰器</strong>，装饰器，顾名思义，就是在原先的基础上增加了某些功能，那么有人会问，为啥增加功能非得这么个增加法？我直接把函数调用写在另一个函数里不就完事了？</p>

<p>当然，这么做没有问题，但是闭包的优点我们已经写过了不是吗？简而言之，我们还是想保留原先的代码结构。</p>

<p>于是，在上边<code class="language-plaintext highlighter-rouge">decorated</code>的基础上，我们可能想直接用装饰后的版本替换原先的<code class="language-plaintext highlighter-rouge">foo</code>函数，得到一个新的<code class="language-plaintext highlighter-rouge">foo</code>版本，我们只需要把#2换成：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span><span class="o">=</span><span class="n">outer</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">foo</span><span class="p">()</span>
</code></pre></div></div>

<p>在很多情况下，之前的foo并不出现在inner()中直接调用，而是作为了inner的返回值：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">some_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"before some_func"</span>
        <span class="k">return</span> <span class="n">some_func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inner</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="n">decorated</span> <span class="o">=</span> <span class="n">outer</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1"># 2
</span>
<span class="n">decorated</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="提到装饰器不能不提语法糖">提到装饰器，不能不提语法糖@</h2>

<p>这个语法糖其实就是为了方便操作和编码准备的，没啥难的，网上教程一搜一大堆。</p>

<p>把上边的例子改改就行了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">some_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"before some_func"</span>
        <span class="k">return</span> <span class="n">some_func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="o">@</span><span class="n">outer</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="c1"># foo = outer(foo) # 2
</span>
<span class="n">foo</span><span class="p">()</span> <span class="c1"># decorated()
</span></code></pre></div></div>

<p>把@放在我们需要的原函数定义的地方，就可以省略最后一步中的赋值操作。</p>

<h2 id="argskwargs">*args、**kwargs</h2>

<p>首先我们得搞清楚这俩玩意儿是干嘛的。</p>

<p>简单地讲，这两个东西均隶属于可变参数的范畴，也就是说可以不定量传递，分别叫做<strong>包裹位置参数和包裹关键字参数</strong>，在一般的Python函数的定义中，我们要按照如下形式定义参数：</p>

<p><code class="language-plaintext highlighter-rouge">位置参数、默认参数、包裹位置参数、包裹关键字参数</code></p>

<p>其中，位置参数就是最一般的根据所在位置决定的参数，在函数的调用中，具体那个参数属于哪一类，这是要取决于前后的参数和自己所在的位置的，这也是我们最常见的参数类型，如果再细分，位置参数还可以分为位置参数与关键字参数，其中，关键字参数是以”键-值”对的形式给出的，而这两种参数类型，也分别恰好对应了包裹位置参数与包裹关键字参数。</p>

<p>对于包裹位置参数，其实就是一个元组，如果我们最后输出，会发现其实Python把他们按照<strong>元组</strong>的形式打包了，那么同理，包裹关键字型参数就是按照<strong>字典</strong>形式打包的。</p>

<p>通过他们，我们可以给原函数传递任意数量和形式的参数，举个例子：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># 1
</span>        
		<span class="k">print</span> <span class="s">"Arguments were: %s, %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># 2
</span>    
	<span class="k">return</span> <span class="n">inner</span>

<span class="o">@</span><span class="n">logger</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">city</span><span class="o">=</span><span class="s">'Nanjing'</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="c1"># foo = logger(foo)
</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">city</span><span class="o">=</span><span class="s">'Beijing'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Arguments</span> <span class="n">were</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">{</span><span class="s">'city'</span><span class="p">:</span><span class="s">'Beijing'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span>
</code></pre></div></div>

<p>这种参数表示法的好处就在于我们可以将所有的，不论什么形式的<code class="language-plaintext highlighter-rouge">foo</code>的参数都可以完整的传递到<code class="language-plaintext highlighter-rouge">func()</code>中去. 这个函数其实很好理解，在之前的叙述中，我们提到装饰器函数记住了自己的外层作用域，其实也就是与外部的自由变量绑定在了一起，我们通过<code class="language-plaintext highlighter-rouge">@logger</code>获取了<code class="language-plaintext highlighter-rouge">logger</code>的返回值<code class="language-plaintext highlighter-rouge">inner</code>函数，并与变量名<code class="language-plaintext highlighter-rouge">foo</code>关联. 调用<code class="language-plaintext highlighter-rouge">foo(1,city='Beijing')</code>时，也即执行<code class="language-plaintext highlighter-rouge">inner(1,city='Beijing')</code>，因为我们调用函数时<strong>包裹位置参数</strong>中只出现了<code class="language-plaintext highlighter-rouge">x</code>，所以参数列表中元组内只有<code class="language-plaintext highlighter-rouge">x</code>的值。但因为<code class="language-plaintext highlighter-rouge">foo(x,y=2,city='Nanjing')</code>中默认参数的存在，其返回值变成了2.</p>

<h2 id="带参数的装饰器">带参数的装饰器</h2>

<p>现在提出一个问题，我想让装饰器也接受另外的参数，做一个层级调度任务，该怎么办？</p>

<p>我们回去看一眼现在的装饰器长啥样儿：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">some_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"before some_func"</span>
        <span class="k">return</span> <span class="n">some_func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="o">@</span><span class="n">outer</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="c1"># decorated = outer(foo) # 2
</span>
<span class="n">decorated</span><span class="p">()</span>
</code></pre></div></div>

<p>我们当时为什么要设计装饰器来着？是为了做改进但是又不破坏原有的代码结构，那岂不是和我们现在要做的是同一件事了？所以答案很简单，接着嵌套就完事了。</p>

<p>从廖大那儿搞个例子：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'%s %s():'</span> <span class="o">%</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="o">@</span><span class="n">log</span><span class="p">(</span><span class="s">'execute'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">now</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'2020-5-27'</span><span class="p">)</span>
</code></pre></div></div>

<p>因为内层的函数始终能记住外部的嵌套作用域，所以这就无限套娃了。(外层函数的返回值应当是其内部函数名，这是必要的)</p>

<p>我觉得廖大的解释很棒，这个3层嵌套的效果是这样：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">now</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="s">'execute'</span><span class="p">)(</span><span class="n">now</span><span class="p">)</span>
</code></pre></div></div>

<p>同理，首先执行<code class="language-plaintext highlighter-rouge">log('execute')</code>，返回的是<code class="language-plaintext highlighter-rouge">decorator</code>函数，再调用返回的函数，参数是<code class="language-plaintext highlighter-rouge">now</code>函数，返回值是<code class="language-plaintext highlighter-rouge">wrapper</code>函数，执行<code class="language-plaintext highlighter-rouge">now = log('execute')(now)</code>后，将函数<code class="language-plaintext highlighter-rouge">now</code>作为变量传入<code class="language-plaintext highlighter-rouge">log('execute')</code>，即<code class="language-plaintext highlighter-rouge">decorator</code>装饰器中，然后<code class="language-plaintext highlighter-rouge">now</code>方法在<code class="language-plaintext highlighter-rouge">decorator</code>中的<code class="language-plaintext highlighter-rouge">wrapper</code>函数实现，并包装新的功能. 所以<code class="language-plaintext highlighter-rouge">now</code>的新值是经过``decorator<code class="language-plaintext highlighter-rouge">装饰的</code>wrapper`方法.</p>

<h2 id="多装饰器">多装饰器</h2>

<p>关于多装饰器，网上例子不少，但是我还是想写下，加深一下印象。</p>

<p>多装饰器的执行方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">f1</span>
<span class="o">@</span><span class="n">f2</span>
<span class="o">@</span><span class="n">f3</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">()</span>
	<span class="k">pass</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</code></pre></div></div>

<p>基本上是一个从下至上的执行顺序。但是问题往往再不经意间，咱们接着往下看：</p>

<p>以下内容参考自<a href="https://segmentfault.com/a/1190000007837364">https://segmentfault.com/a/1190000007837364</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator_a</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Get in decorator_a'</span>
    <span class="k">def</span> <span class="nf">inner_a</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'Get in inner_a'</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner_a</span>

<span class="k">def</span> <span class="nf">decorator_b</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Get in decorator_b'</span>
    <span class="k">def</span> <span class="nf">inner_b</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'Get in inner_b'</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner_b</span>

<span class="o">@</span><span class="n">decorator_b</span>
<span class="o">@</span><span class="n">decorator_a</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Get in f'</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Get</span> <span class="ow">in</span> <span class="n">decorator_a</span>
<span class="n">Get</span> <span class="ow">in</span> <span class="n">decorator_b</span>
<span class="n">Get</span> <span class="ow">in</span> <span class="n">inner_b</span>
<span class="n">Get</span> <span class="ow">in</span> <span class="n">inner_a</span>
<span class="n">Get</span> <span class="ow">in</span> <span class="n">f</span>
</code></pre></div></div>

<p>很显然，根据装饰器一般说的从下至上的执行顺序来讲，这是不对的。所以到底是哪里出了问题呢？</p>

<p>我们把握两点：</p>

<ol>
  <li>函数与函数调用的区别</li>
  <li>装饰器函数在装饰函数定义好后立即执行</li>
</ol>

<ul>
  <li>
    <p>关于第一点：</p>

    <blockquote>
      <p>回想一下闭包时我们对调用闭包实例的阐述，是不是一个意思？</p>

      <blockquote>
        <p>形象化表述：对于闭包实例的调用，我们可以理解成让闭包执行一下，记一下嵌套作用域的环境，把该做的准备做好，就好比是在背文章之前总得先看一遍，之后就用就可以了</p>
      </blockquote>
    </blockquote>

    <p>为什么是先执行 <code class="language-plaintext highlighter-rouge">inner_b</code> 再执行 <code class="language-plaintext highlighter-rouge">inner_a</code> 呢？为了彻底看清上面的问题，得先分清两个概念:函数和函数调用。上面的例子中 <code class="language-plaintext highlighter-rouge">f</code> 称之为函数， <code class="language-plaintext highlighter-rouge">f(1)</code> 称之为函数调用，后者是对前者传入参数进行求值的结果。<strong>在Python中函数也是一个对象，所以 <code class="language-plaintext highlighter-rouge">f</code> 是指代一个函数对象，它的值是函数本身， <code class="language-plaintext highlighter-rouge">f(1)</code> 是对函数的调用，它的值是调用的结果，这里的定义下 <code class="language-plaintext highlighter-rouge">f(1)</code> 的值2。</strong>同样地，拿上面的 <code class="language-plaintext highlighter-rouge">decorator_a</code> 函数来说，它返回的是个函数对象 <code class="language-plaintext highlighter-rouge">inner_a</code> ，这个函数对象是它内部定义的。在 <code class="language-plaintext highlighter-rouge">inner_a</code> 里调用了函数 <code class="language-plaintext highlighter-rouge">func</code> ，将 <code class="language-plaintext highlighter-rouge">func</code> 的调用结果作为值返回。</p>
  </li>
  <li>
    <p>关于第二点：</p>

    <p>其实这一点，我们把语法糖的表示还原回去看的更清楚：</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">decorator_a</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Get in f'</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
  
<span class="c1"># 相当于
</span>  
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Get in f'</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
  
<span class="n">f</span> <span class="o">=</span> <span class="n">decorator_a</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>所以，当解释器执行这段代码时， <code class="language-plaintext highlighter-rouge">decorator_a</code> 已经调用了，它以函数 <code class="language-plaintext highlighter-rouge">f</code> 作为参数， 返回它内部生成的一个函数，所以此后 <code class="language-plaintext highlighter-rouge">f</code> 指代的是 <code class="language-plaintext highlighter-rouge">decorater_a</code> 里面返回的 <code class="language-plaintext highlighter-rouge">inner_a</code> （因为装饰器的写法：<code class="language-plaintext highlighter-rouge">f=decorator(f)</code>）。所以当以后调用 <code class="language-plaintext highlighter-rouge">f</code>时，实际上相当于调用 <code class="language-plaintext highlighter-rouge">inner_a</code> ,传给 <code class="language-plaintext highlighter-rouge">f</code>的参数会传给 <code class="language-plaintext highlighter-rouge">inner_a</code> , 在调用 <code class="language-plaintext highlighter-rouge">inner_a</code> 时会把接收到的参数传给 <code class="language-plaintext highlighter-rouge">inner_a</code> 里的 <code class="language-plaintext highlighter-rouge">func</code> 即 <code class="language-plaintext highlighter-rouge">f</code> ,最后返回的是 <code class="language-plaintext highlighter-rouge">f</code> 调用的值，所以在最外面看起来就像直接在调用 <code class="language-plaintext highlighter-rouge">f</code> 一样</p>

    <p>上边的表述有点转圈，循环的感觉，但其实没毛病，因为本身我们的参数就是从<code class="language-plaintext highlighter-rouge">f</code>传进去，最后又传回了<code class="language-plaintext highlighter-rouge">f</code>，那我们做了啥呢？当然是做了些装饰啦。</p>
  </li>
</ul>

<p>于是，在最初的例子中，在我们定义了装饰器之后：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">decorator_b</span>
<span class="o">@</span><span class="n">decorator_a</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Get in f'</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
</code></pre></div></div>

<p>根据原则1，实际上按照从下到上的顺序已经依次调用了 <code class="language-plaintext highlighter-rouge">decorator_a</code> 和 <code class="language-plaintext highlighter-rouge">decorator_b</code> ，这是会输出对应的 <code class="language-plaintext highlighter-rouge">Get in decorator_a</code> 和 <code class="language-plaintext highlighter-rouge">Get in decorator_b</code> 。</p>

<p>那么接下来，由于多装饰器的嵌套的执行方法，<code class="language-plaintext highlighter-rouge">decorator_a</code>装饰器先return 了<code class="language-plaintext highlighter-rouge">inner_a</code>, 而<code class="language-plaintext highlighter-rouge">decorator_b</code>后面又把<code class="language-plaintext highlighter-rouge">inner_a</code>装饰了，最终整个暴露在外面的是<code class="language-plaintext highlighter-rouge">inner_b</code>，这时候 <code class="language-plaintext highlighter-rouge">f</code> 已经相当于 <code class="language-plaintext highlighter-rouge">decorator_b</code> 里的 <code class="language-plaintext highlighter-rouge">inner_b</code> 。但因为 <code class="language-plaintext highlighter-rouge">f</code> 并没有被调用，所以 <code class="language-plaintext highlighter-rouge">inner_b</code> 并没有调用，依次类推 <code class="language-plaintext highlighter-rouge">inner_b</code> 内部的 <code class="language-plaintext highlighter-rouge">inner_a</code> 也没有调用，所以 <code class="language-plaintext highlighter-rouge">Get in inner_a</code> 和 <code class="language-plaintext highlighter-rouge">Get in inner_b</code> 也不会被输出。</p>

<p>然后最后一行当我们对 <code class="language-plaintext highlighter-rouge">f</code> 传入参数1进行调用时， <code class="language-plaintext highlighter-rouge">inner_b</code> 被调用了，它会先打印 <code class="language-plaintext highlighter-rouge">Get in inner_b</code> ，然后在 <code class="language-plaintext highlighter-rouge">inner_b</code> 内部调用了 <code class="language-plaintext highlighter-rouge">inner_a</code> 所以会再打印 <code class="language-plaintext highlighter-rouge">Get in inner_a</code>, 然后再 <code class="language-plaintext highlighter-rouge">inner_a</code> 内部调用的原来的 <code class="language-plaintext highlighter-rouge">f</code>, 并且将结果作为最终的返回。</p>

<h2 id="函数属性出了点问题">函数属性出了点问题？</h2>

<p>紧接着上边的，看看这个：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
<span class="s">'wrapper'</span>
</code></pre></div></div>

<p>函数的名字在用了装饰器之后变了？</p>

<p>装饰器就是存在这个问题，他会替换函数的<strong>元信息</strong>，</p>

<p>那为什么会替换元信息呢？</p>

<p>我们还是拿之前的2层嵌套为例说明：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">some_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"before some_func"</span>
        <span class="k">return</span> <span class="n">some_func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="o">@</span><span class="n">outer</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="c1"># decorated = outer(foo) # 2
</span>
<span class="n">decorated</span><span class="p">()</span>
</code></pre></div></div>

<p>之前我们分析过函数的调用顺序，通过调用顺序我们知道，调用<code class="language-plaintext highlighter-rouge">f</code>其实就是在调用<code class="language-plaintext highlighter-rouge">inner()</code>.这句话本身就是元信息替换的原因。</p>

<p>为了解决这个问题，Python自然有自己的办法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'%s %s():'</span> <span class="o">%</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorator</span>
</code></pre></div></div>

<p>这么说来，wraps也是一个装饰器，它的作用就是把原函数的信息拷贝到装饰器的func函数中。</p>

<h2 id="类装饰器">类装饰器</h2>

<p>一般依靠类的<code class="language-plaintext highlighter-rouge">__call__</code>方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">'class decorator runing'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_func</span><span class="p">()</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">'class decorator ending'</span><span class="p">)</span>

<span class="o">@</span><span class="n">Foo</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">'bar'</span><span class="p">)</span>

<span class="n">bar</span><span class="p">()</span>
</code></pre></div></div>

<p>输出：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">decorator</span> <span class="n">runing</span>
<span class="n">bar</span>
<span class="k">class</span> <span class="nc">decorator</span> <span class="n">ending</span>
</code></pre></div></div>

<p>装饰器的基本内容就学习到这儿，关于Python的类可以直接参看官方文档：</p>

<p><a href="https://docs.python.org/zh-cn/3/tutorial/classes.html">https://docs.python.org/zh-cn/3/tutorial/classes.html</a></p>
:ET