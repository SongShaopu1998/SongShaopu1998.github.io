---
layout:		post
title:		6.S081
subtitle:	MIT 6.S081
date:		2021-12-05
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
   - C
   - RISC-V
   - Operating System
   - CS基础课程笔记
---

## MIT 6.S081 Lab3 Page Tables

这个实验的后两个部分做了我好几天，中途几度做不下去了，上网搜了一圈发现大家的做法居然都是写一个将`user page table`复制到`kernele page table (per process)`的函数，然后分别在`exec`, `sbrk`等等函数内调用。但我的做法是在维护进程原有的用户页表的同时维护一个新的单进程内核页表，之后每一次更新`user page table`的时候也同时更新该页表。所以也只能硬着头皮继续做下去了，最终调试成功，把自己遇到的问题和分析记录一下。

### 关于调试

首先初始化`home`文件夹下的`.gdbinit`文件，之后使用命令`make qemu-gdb`启动调试，并在另一个命令行窗口输入`gdb-multiarch`开始调试，可以利用`layout split`命令在`gdb`窗口中查看当前调试位置和代码。如果要调试特定文件，则在开始调试时输入`file path+name`即可。

### 关于内核页表

对于从`KERNBASE`到`PHYSTOP`这一段的区间以及下方的`memory-mapped device registers`，内核页表（`kernel_page_table`）会做`direct mapping`，也就是说如果探测到虚拟地址位于这段区间内，不需要通过页表转换才获得物理地址（在实际的`x86_64 linux`系统内也是这么设计的）。这也是为什么我们在程序中通过`PTE2PA`获得了所谓的“物理地址”（因为仍处于软件中，所以其实仍是一个虚拟地址）后，即使看起来内核页表中仍然没有对应的`VA->PA`的映射，但仍不会报错的原因。

### 关于每个进程的内核页表设计

#### 为什么需要每个进程的内核页表？

先前的设计中，我们只会向`satp`寄存器中存入`kernel_page_table`的根页表的地址，在`scheduler()`函数中进行进程切换时也不会将进程页表写入`satp`寄存器内。

然而即使我们将设计补全成一般的形式，即在进行用户态和内核态切换时，也切换当前的页表（`proc_pagetable | kernel_page_table`）。假如此时当我们在内核态中，传入了一个`user space address`时，因为此时的`kernel_page_table`中没有对应的`virtual address`的映射，就会报错。所以我们必须手动模拟把`VA`先转化成`PA`，再根据我们上一节讨论的内容得到硬件上的物理地址。

也就是说，此时寻址的方式是**利用软件模拟访问页表的过程获取物理地址**的。而现在我们想直接利用CPU的硬件寻址功能，即当前被储存在`satp`寄存器中的页表自动完成`VA->PA`的转换过程。也即实验指导中说的，可以直接在内核态中对传入的`user address pointer`解引用（解引用的过程隐含了从`VA->PA`的翻译过程），让系统自动完成翻译过程。

由此一来，在内核态中存储在`satp`寄存器中的页表就必须含有`VA->PA`的对应。

考虑到在原先的`kernel_page_table`中，`0-PLIC`的部分是没有被占用的，所以我们可以利用这一区域存储对应的`user memory mapping`。

> 关于内核页表中的`CLINT`，它位于`PLIC`的下方，但是在单独进程的内核页表中可以不做映射，也就是说在初始化的时候可以忽略这一区域。**否则在调试过程中会报`remap`这一区域的错误**。

#### 调试出现的问题

- 单进程内核页表的映射函数的设计不能和`kvmmap`一样：`kvmmap`函数在系统`boot`时启用，所以如果出现内存分配不够的情况，就应当报`panic`。但是`kgtmap`是与`uvmcreate()`函数类似的使用方法，当内存耗尽时，应当返回-1而非报错，该方法设计不当将导致我们无法通过`execout`单元测试。同时，`kgtmap`函数在返回-1之前，应当释放掉已经分配的（刚创建的）页表：

  ```c
  int
  kpgtmap(pagetable_t pgt, uint64 va, uint64 pa, uint64 sz, int perm)
  {
    if (mappages(pgt, va, sz, pa, perm) != 0) {
      uvmfree_kernel_pages(pgt, 0);
      return -1;
    }
      
    return 0;
  }
  ```

  如果不及时释放页表，则会在单元测试的最后的空闲内存统计中检测到有内存页未被释放。

- 此外，在`vm.c`文件中，我们需要对原有的几个函数声明做改动：

  ```c
  void            uvminit(pagetable_t, pagetable_t, uchar *, uint);
  uint64          uvmalloc(pagetable_t, pagetable_t, uint64, uint64);
  uint64          uvmdealloc(pagetable_t, pagetable_t, uint64, uint64);
  int             uvmcopy(pagetable_t, pagetable_t, pagetable_t, pagetable_t, uint64);
  ```

  以便同时控制`proc_pagetable`和`kpagetable`。

  其中，`uvmalloc`和`uvmdealloc`，还有`uvmcopy`这三个函数格外需要注意，因为他们的内存分配很容易出现问题：需要注意用户页表需要销毁对应的物理页内存，但是单进程内核页表不需要销毁物理页内存。同时注意控制刚分配的内存的释放位置。

  为了方便起见，我将因`PLIC`的位置限制语句也写在`uvmalloc`中。

  ```c
  uint64
  uvmalloc(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz)
  {
    char *mem;
    uint64 a;
  
    if(newsz < oldsz)
      return oldsz;
  
    oldsz = PGROUNDUP(oldsz);
    for(a = oldsz; a < newsz; a += PGSIZE){
      mem = kalloc();
      if(mem == 0){
        uvmdealloc(pagetable, kpagetable, a, oldsz);
        return 0;
      }    
      if (a >= PLIC) {
        kfree(mem);
        uvmdealloc(pagetable, kpagetable, a, oldsz);
        return 0;
      }
        
      memset(mem, 0, PGSIZE);
      //printf("start uvmalloc\n");
      if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){
        kfree(mem);
        uvmdealloc(pagetable, kpagetable, a, oldsz);
        return 0;
      }
      if (mappages(kpagetable, a, PGSIZE, (uint64)mem, PTE_W | PTE_X | PTE_R) != 0) {
        // since the operation of PGROUNDUP has happend above, no need to do it again
        int npages = (a - oldsz) / PGSIZE;
        // 不需要手动释放mem，因为该过程被包含在uvmunmap中
        uvmunmap(pagetable, a, npages + 1, 1);
        uvmunmap(kpagetable, a, npages, 0);
        return 0;
      }
    }
  
    return newsz;
  }
  ```

- 由于`kernel stack`的初始化在`proc.c/procinit()`函数中进行，我们在`allocproc()`和`exec()`函数中无需再分配内核栈的空间，但是需要对新创建的单进程内核页表进行内核栈的映射！我们可以直接利用`p->kstack`取得虚拟地址后，利用`kvmpa(va)`获取其物理地址：

  ```c
  // map the kernel stack
  uint64 va = p->kstack;
  if (kpgtmap(p->kpagetable, va, kvmpa(va), PGSIZE, PTE_R | PTE_W) != 0) {
    freeproc(p);
    release(&p->lock);
    return 0;
  }
  ```

- 在`exec`函数中，有一个关键点是：

  ```c
  ...
  proc_freepagetable(oldpagetable, oldsz);
  
  // MUST RELOAD THE KPAGE (UPDATE THE SATP)
  w_satp(MAKE_SATP(p->kpagetable));
  sfence_vma();
  
  // must put this under the above w_satp step
  uvmfree_kernel_pages(oldkpagetable, 0);
  if (p->pid == 1) vmprint(p->pagetable);
  return argc; // this ends up in a0, the first argument to main(argc, argv)
  ```

  我们必须先将新的单进程内核页表加载，之后再释放旧的页表内存。如果这里不更新`satp`寄存器或者先释放旧的页表内存，再更新`satp`寄存器，原本的页表地址内并没有页表存在，就会导致程序卡住。

