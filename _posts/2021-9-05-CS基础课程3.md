---
layout:		post
title:		CS基础课程3
subtitle:	CS 106X + CS 106L + CS 225
date:		2021-9-05
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C++
    - data structures and algorithms
    - CS基础课程笔记
---

> 开始这一系列课程的目的主要有两个：
>
> 1. 掌握基本的数据结构与算法内容
> 2. 熟悉基本的C++语法和操作
>
> 由于Stanford CS 106X是*quarter*制的授课模式，所以内容相比CS 61B和UIUC的CS 225要稍显简略，考虑到CS 225这门课程也是C++授课，并且是玉米地核心课程之一，但无奈只有注册可课程的人才能获得lab和mp，所以打算利用这门课把CS 106X的没有涉及到的部分补充完整；利用CS 106L在C++上稍微深入一下。
>
> 在此前修完了CS 61A，个人计划是在完成这三门课的穿插学习之后，学习Berkeley CS 170的算法课。

---

## CS 106X Lecture 2 -- Functions & Strings

### Output Parameters

*Pass by reference to return multiple items.*

当`pass by value`时，参数会复制一份到函数自身的`frame`里，所以外部的值不会改变，但是`pass by reference`是传指针。

```c++
void datingRange(int age, int& min, int& max) { 
    min = age / 2 + 7; max = (age - 7) * 2;
}
int main() { 
    int young; 
    int old; 
    datingRange(48, young, old); 
    cout << "A 48-year-old could date someone from " << young << " to " << old " years old." << endl;
}
```

### C String bugs

C本身提供的字符串不具备`+，find`等一系列功能，所以在使用时，最好要转化为C++格式的字符串，用`string`类型做变量类型声明：

> - string("*text*") C string to C++ string – 
>
> - *string*.c_str() C++ string to C string

```C++
string s = string("hi") + "there"; 
string s = "hi";           // convert to C++ string (auto-conversion)

s += "there";
```

## CS 106X Lecture 3 -- Vectors & Grid; IO stream

### Vector & Grid

使用方法：

```C++
Vector<int> names;
names.add("Dog");

Grid<int> matrix(3,4);
```

可以使用`range for loop`:

```C++
for(int value: matrix){
    // do something with value;
}
```

> 当他们作为函数参数使用时，要注意传递引用，`pass by value`是很慢的

### IO Stream

- 整行读取

```c++
iftream input;
input.open("poem.txt");
if (input.fail()){
    // do something if fails;
}
else{
    string line;
    while(getline(input, line)){
    cout << line << endl;
	}
}
input.close();
```

- 单词读取

```c++
ifstream file;
file.open(filename);
string word;

while(input >> word){
    // do something with words
}
```

一种错误的文件遍历方法：

```C++
while(!input.fail()){
    string line;
    getline(input, line);
    cout << line << endl;
}
```

这种方法的问题在于，会多遍历一行（可能是空行），因为在读取完最后一行的数据后，`input.fail`仍然为`false`.

我们也可以通过操作符`>>`进行文件读取：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109051747830.png" alt="image-20210905174746335" style="zoom:50%;" />

## CS 106X HW1 - Game Of Life

遇到的一个问题：

当我试图使用`pass by value`的方式将`ifstream file`传入函数参数时，程序报错：`deleted copy constructor`.

在查阅了《C++ Primer》中有关于拷贝构造函数的相关内容（**P449**）后，发现这是由于某些类（比如`ifstream`），也包括`<iostream>`在定义类时阻止了拷贝，以避免多个对象写入或者读取相同的IO缓冲。在新标准下，将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝。在函数的参数列表后边加上`=delete`来指出我们希望将它定义为删除的，所以在`pass by value`时，因为要调用相关类的拷贝构造函数，就会被阻止操作。

我们可以通过`pass by reference`或者直接将文件操作流定义为引用对象来解决这一问题。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109071641937.png" alt="image-20210907164128795" style="zoom: 67%;" />

## CS 106X Lecture 4 -- Stacks & Queues

### Stack

课堂上一个有趣的例子：关于使用`stack`进行括号匹配判断：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109072008180.png" alt="image-20210907200828068" style="zoom:50%;" />

```c++
int checkBalance(string code){
    Stack<char> stack_code;
    for(int i = 0; i < code.length(); ++i){
        if (code[i] == "(" || code[i] == "{") stack_code.push(code[i]); 
        
        else if (code[i] == ")" || code[i] == "}") stack_code.pop()
    }
    return -1;
}
```

这样的弹出代码是不对的，**必须在栈顶检测到匹配的括号类型时，才将其弹出**，如果此时栈顶括号类型不匹配，说明这段字符串本身的括号就是不匹配的。同时，考虑到可能出现只有左括号而永远没有闭合的情况，这段代码应做如下修改：

```c++
int checkBalance(string code){
    Stack<char> stack_code;
    for(int i = 0; i < code.length(); ++i){
        if (code[i] == "(" || code[i] == "{") stack_code.push(code[i]); 
        else if (code[i] == ")" ) {
            if (stack_code.peek() == "(") stack_code.pop();
            else return i;
        }
        else if (code[i] == "}") {
            if (stack_code.peek() == "{") stack_code.pop();
            else return i;
        }
    }
    if (!stack_code.isEmpty()) return code.length;
    return -1;
}
```

### Queue

一个`mirror`问题：`queue: {a, b, c} -> {a, b, c, c, b, a}`

```c++
void mirror(Queue<string>& queue){
    Stack<string> mirror_stack;
    while (!queue.isEmpty()){
        string s = queue.dequeue();
        mirror_stack.push(s);
    }
    // q = {}
    
    // mirror_stack = {a, b, c} top
}
```

但现在的问题在于想要保存原来的序列，所以考虑在对队列`dequeue`的同时，把数据保存进这个队列（基于**FIFO**的特性）:

```c++
void mirror(Queue<string>& queue){
    Stack<string> mirror_stack;
    Stack<string> mirror_stack;
    // 改为for循环
    
    for (int i = 0; i < queue.length(); ++i){
        string s = queue.dequeue();
        mirror_stack.push(s);
        // 加入queue
        
        queue.enqueue(s);
    }
    // q = {a, b, c} back
    
    // mirror_stack = {a, b, c} top
    
    while (!stack.isEmpty()){
        queue.enqueue(stack.pop());
    }
}
```



