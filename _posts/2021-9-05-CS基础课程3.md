---

layout:		post
title:		CS基础课程3
subtitle:	CS 106X + CS 106L + CS 225
date:		2021-9-05
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C++
    - data structures and algorithms
    - CS基础课程笔记
---

> 开始这一系列课程的目的主要有两个：
>
> 1. 掌握基本的数据结构与算法内容
> 2. 熟悉基本的C++语法和操作
>
> 由于Stanford CS 106X是*quarter*制的授课模式，所以内容相比CS 61B和UIUC的CS 225要稍显简略，考虑到CS 225这门课程也是C++授课，并且是玉米地核心课程之一，但无奈只有注册可课程的人才能获得lab和mp，所以打算利用这门课把CS 106X的没有涉及到的部分补充完整；利用CS 106L在C++上稍微深入一下。
>
> 在此前修完了CS 61A，个人计划是在完成这三门课的穿插学习之后，学习Berkeley CS 170的算法课。

---

## CS 106X Lecture 2 -- Functions & Strings

### Output Parameters

*Pass by reference to return multiple items.*

当`pass by value`时，参数会复制一份到函数自身的`frame`里，所以外部的值不会改变，但是`pass by reference`是传指针。

```c++
void datingRange(int age, int& min, int& max) { 
    min = age / 2 + 7; max = (age - 7) * 2;
}
int main() { 
    int young; 
    int old; 
    datingRange(48, young, old); 
    cout << "A 48-year-old could date someone from " << young << " to " << old " years old." << endl;
}
```

### Default Parameters

All parameters with default value must appear last in the formals list.

### C String bugs

C本身提供的字符串不具备`+，find`等一系列功能，所以在使用时，最好要转化为C++格式的字符串，用`string`类型做变量类型声明：

> - string("*text*") C string to C++ string – 
>
> - *string*.c_str() C++ string to C string

```C++
string s = string("hi") + "there"; 
string s = "hi";           // convert to C++ string (auto-conversion)

s += "there";
```

## CS 106X Lecture 3 -- Vectors & Grid; IO stream

### Vector & Grid

使用方法：

```C++
Vector<int> names;
names.add("Dog");

Grid<int> matrix(3,4);
```

可以使用`range for loop`:

```C++
for(int value: matrix){
    // do something with value;
}
// "for-each" by  reference

for (string& name: names){
    name += "!";
}
```

> 当他们作为函数参数使用时，要注意传递引用，`pass by value`是很慢的

#### Remove?

当我们试图从`Vector`中删除元素时，最好的遍历方法是自后向前遍历，这样可以避免因为删除元素带来的`shifting`的影响。

### IO Stream

- **整行读取**

```c++
iftream input;
input.open("poem.txt");
if (input.fail()){
    // do something if fails;
}
else{
    string line;
    while(getline(input, line)){
    cout << line << endl;
	}
}
input.close();
```

- **单词读取**

```c++
ifstream file;
file.open(filename);
string word;

while(input >> word){
    // do something with words
}
```

一种错误的文件遍历方法：

```C++
while(!input.fail()){
    string line;
    getline(input, line);
    cout << line << endl;
}
```

这种方法的问题在于，会多遍历一行（可能是空行），因为在读取完最后一行的数据后，`input.fail`仍然为`false`.

我们也可以通过操作符`>>`进行文件读取：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109051747830.png" alt="image-20210905174746335" style="zoom:50%;" />

- **tokenize a string**

使用`<sstream>`：

```c++
istringstream input("test string 12345");
string first, last;
int phone;
input >> first >> last; // first = "test", last = "string"

input >> phone; // 12345
```

同样地，我们也可以使用之前的`while`循环来读取所有`tokens`。

- **write output to a string buffer (without display directly)**

```c++
int age = 42, iq = 45;
ostringstream output;
output << "Zoidberg's age is " << age << endl;
output << "and his IQ is " << iq << "!" << endl;

// use the str method to extract the string that was built

string result = output.str();
```

## CS 106X HW1 - Game Of Life

遇到的一个问题：

当我试图使用`pass by value`的方式将`ifstream file`传入函数参数时，程序报错：`deleted copy constructor`.

在查阅了《C++ Primer》中有关于拷贝构造函数的相关内容（**P449**）后，发现这是由于某些类（比如`ifstream`），也包括`<iostream>`在定义类时阻止了拷贝，以避免多个对象写入或者读取相同的IO缓冲。在新标准下，将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝。在函数的参数列表后边加上`=delete`来指出我们希望将它定义为删除的，所以在`pass by value`时，因为要调用相关类的拷贝构造函数，就会被阻止操作。

我们可以通过`pass by reference`或者直接将文件操作流定义为引用对象来解决这一问题。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109071641937.png" alt="image-20210907164128795" style="zoom: 67%;" />

## CS 106X Lecture 4 -- Stacks & Queues

### Stack

课堂上一个有趣的例子：关于使用`stack`进行括号匹配判断：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109072008180.png" alt="image-20210907200828068" style="zoom:50%;" />

```c++
int checkBalance(string code){
    Stack<char> stack_code;
    for(int i = 0; i < code.length(); ++i){
        if (code[i] == "(" || code[i] == "{") stack_code.push(code[i]); 
        
        else if (code[i] == ")" || code[i] == "}") stack_code.pop()
    }
    return -1;
}
```

这样的弹出代码是不对的，**必须在栈顶检测到匹配的括号类型时，才将其弹出**，如果此时栈顶括号类型不匹配，说明这段字符串本身的括号就是不匹配的。同时，考虑到可能出现只有左括号而永远没有闭合的情况，这段代码应做如下修改：

```c++
int checkBalance(string code){
    Stack<char> stack_code;
    for(int i = 0; i < code.length(); ++i){
        if (code[i] == "(" || code[i] == "{") stack_code.push(code[i]); 
        else if (code[i] == ")" ) {
            if (stack_code.peek() == "(") stack_code.pop();
            else return i;
        }
        else if (code[i] == "}") {
            if (stack_code.peek() == "{") stack_code.pop();
            else return i;
        }
    }
    if (!stack_code.isEmpty()) return code.length;
    return -1;
}
```

### Queue

一个`mirror`问题：`queue: {a, b, c} -> {a, b, c, c, b, a}`

```c++
void mirror(Queue<string>& queue){
    Stack<string> mirror_stack;
    while (!queue.isEmpty()){
        string s = queue.dequeue();
        mirror_stack.push(s);
    }
    // q = {}
    
    // mirror_stack = {a, b, c} top
}
```

但现在的问题在于想要保存原来的序列，所以考虑在对队列`dequeue`的同时，把数据保存进这个队列（基于**FIFO**的特性）:

```c++
void mirror(Queue<string>& queue){
    Stack<string> mirror_stack;
    Stack<string> mirror_stack;
    // 改为for循环
    
    for (int i = 0; i < queue.length(); ++i){
        string s = queue.dequeue();
        mirror_stack.push(s);
        // 加入queue
        
        queue.enqueue(s);
    }
    // q = {a, b, c} back
    
    // mirror_stack = {a, b, c} top
    
    while (!stack.isEmpty()){
        queue.enqueue(stack.pop());
    }
}
```

## CS 106X Lecture 5 -- Set & Maps

### Set

- `Perform add/remove/search(contains) efficiently`
- `No indexes`

|         | Sorted or not       | search speed | implementation |
| ------- | ------------------- | ------------ | -------------- |
| Set     | Sorted order        | fast         | binary tree    |
| HashSet | unpredictable order | pretty fast  | hash table     |

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109082204066.png" alt="image-20210908220419659" style="zoom:50%;" />

Set可以理解为一个集合，可以进行与`string`类类似的操作。

遍历方法：

```c++
for (type name: collection){
    statements;
}
```

> 如果定义了自己的struct或者class，是不能直接多次加入set的，我们需要对`<`进行运算符重载

### Maps

类似于`Python`的字典，储存的是`Pair`

类型类似于`Set`

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109082229406.png" alt="image-20210908222905867" style="zoom:50%;" />

## CS 106X Lecutre 7-9 Basic Recursion

这里记录老师上课的几个例子，比较典型的说明了可以对需要进行递归的函数添加的辅助操作：

### Crawl file / directory

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109261841096.png" alt="image-20210926184129666" style="zoom:50%;" />

```c++
void crawl(const string& filename) {
    // both of the two cases need to be printed
    
    // cout << filename << endl;
    
    cout << getTail(filename) << endl;
    if(isFile(filename)) {
        // base case: normal file
        
    }
    else {
        // recursive case: directory
        
        Vector<string> files = listDirectory(filename);
        for (string &file: files) {
            // crawl(file);
            
            crawl(filename + "/" + file);
        }
    }
}
```

到了这一步，我们来补齐每个句子前边的缩进，通过在函数参数中添加默认参数实现对递归中缩进的递增，通过在*for*循环中递增缩进参数来实现递增：

```c++
void crawl(const string& filename, string indent = "") {
    cout << indent << getTail(filename) << endl;
    if(isFile(filename)) {
        // base case: normal file
        
    }
    else {
        // recursive case: directory

        Vector<string> files = listDirectory(filename);
        for (string &file: files) {
            // cout << "    " + indent;

            crawl(filename + "/" + file, indent + "    ");
        }
    }
}
```

### Evaluate

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109262019179.png" alt="image-20210926201916855" style="zoom:50%;" />

注意这道题本身带有很多的限制条件，我们可以利用这些限制条件写出一个比较简单的递归函数，而不用借助多次复杂的数据结构；所以我们尝试增加一个变量，跟中遍历字符串位置：

```c++
int evaluate(const string & exp) {
    int index = 0;
    return evaluate_helper(exp, index);
}

int evaluate_helper(const string & exp, int index) {
    // base case
    
    if(isdigit(exp[index])) {
        // transform from the char to int
        
        int result = exp[index] - '0';
        index++;
        return result;
    }
    // recursive case
    
    else {
        
    }
}
```

在思考*recursive case*的时候，我们要想在这个问题中，什么才是**self-similar problem**，很明显每一对括号都是一个`self-similar problem`，所以在遇到这些`self-similar problem`的时候，进行递归。

```c++
int evaluate(const string & exp) {
    int index = 0;
    return evaluate_helper(exp, index);
}

int evaluate_helper(const string & exp, int index) {
    if(isdigit(exp[index])) {
        int result = exp[index] - '0';
        index++;
        return result;
    }
    // recursive case
    
    else {
        // this "if" can be deleted, since it is the only other case
        
        if (exp[index] == '(') {
            // skip '('
            
            index++;
            // operand->operator->operand
            
            // assume this function will return what we want:
            
            int left = evaluate_helper(exp, index);
            char operand = exp[index];
            index++;
            int right = evaluate_helper(exp, index);
            if (operand == '+') {
                return left + right;
            }
            if (operand == '*') {
                return left * right;
            }
            // skip ')'
            
            index++;
        }
        // ')'
        
        // +, *
    }
}
```

## CS 106X Lecture 10-12 Exhaustive Search & Backtrack

### Exhaustive Search

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109282244509.png" alt="image-20210928224457046" style="zoom:50%;" />

使用递归实现穷举搜索的方法类似于CS 61A中的*tree recursion*，在某一时间节点，我们有两种（或者多种选择），每一种选择又对应着一个与原问题*self-similar*的递归问题。

特别的是，在这种问题里，*base case*更恰当的理解方式是**已经没有多余选择**。

课堂上的几个例子比较具有代表性，在这里予以记录：

#### PrintBinary

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109282250705.png" alt="image-20210928225057402" style="zoom: 33%;" />

*printBinary(3)*第一次选择（0/1）后，问题便转化为*printBinary(2)*，所以问题的基本框架是：

```c++
void printBinary(int digits) {
    if (digits == 0) {
        // there is no more choice
        
    }
    else {
        // do something to indicate using 0
        printBinary(digits - 1);
        // do something to indicate using 1
        printBinary(digits - 1); 
    }
}
```

为了能够保存到底使用了0还是1的这种数据，我们对函数做出如下改变：

```c++
void printBinary(int digits, string prefix) {
    if (digits == 0) {
        // there is no more choice
        cout << prefix << endl;
    }
    else {
        // do something to indicate using 0
        printBinary(digits - 1, prefix + "0");
        // do something to indicate using 1
        printBinary(digits - 1, prefix + "1"); 
    }
}
```

正如在CS 61A中的描述的*tree recursion*一样，最终的调用树如下：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109282310977.png" alt="image-20210928231012887" style="zoom:33%;" />

这种树被称为*call tree*或者*decision tree*.

如果将此题中的二进制数字改为十进制数字，那么最好借助于*for*循环规范代码（也与CS 61A中教授的方法相同）：

```c++
void printDecimal(int digits, string prefix) {
    if (digits == 0) {
        cout << prefix << endl;
    }
    else {
        for (int i = 0; i <= 9; ++i) {
            printDecimal(digits - 1, prefix + integerToString(i));
        }
    }
}
```

#### Permutations

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109282315249.png" alt="image-20210928231528658" style="zoom:50%;" />

```c++
void permute(string s, string prefix) {
    if (s == "") {
        cout << prefix << endl;
    }
    else {
        // 每一个字母都可以作为第一个字母出现
        for (int i = 0; i < s.length(); ++i) {
            char cur = s[i];
            // 将选定的字母从序列中去除，之后不再出现
            str = s.substr(0, i) + s.substr(i + 1);
            permute(str, prefix + cur);
        }
    }
}
```

如果我们想把所有的结果保存起来，则需要借助数据结构和一个*helper*函数：

```c++
Vector<string> permute(string s) {
    Vector<string>& v;
    permuteHelper(s, "", v);
    return v;
}

void permute(string s, string prefix, Vector<string>& v) {
    if (s == "") {
        // cout << prefix << endl;
        v.add(prefix);
    }
    else {
        // 每一个字母都可以作为第一个字母出现
        for (int i = 0; i < s.length(); ++i) {
            char cur = s[i];
            // 将选定的字母从序列中去除，之后不再出现
            str = s.substr(0, i) + s.substr(i + 1);
            permute(str, prefix + cur);
        }
    }
}
```

### Backtracking

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109291113975.png" alt="image-20210929111320535" style="zoom:50%;" />

与穷举所不同的是，在回溯问题中，因为在递归之后可能改变了原本数据的组成结构和状态，所以我们要进行*un-choose*。或者说我们可能会遇到某些情况，导致需要舍弃掉当前的选择，并回退到上一步重新进行选择。

回溯算法一般分为三步：

- **choose**
- **explore**
- **un-choose**

#### Dice rolls

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109291753463.png" alt="image-20210929175333015" style="zoom:50%;" />

```c++
Vector<int> diceRolls(int dice) {
    Vector<int> v;
    diceHelper(dice, v);
    return v;
}

void diceHelper(int dice, Vector<int> & chosen) {
    if (dice == 0) {
        cout << chosen << endl;
    }
    else {
        for (int i = 1; i <= 6; ++i) {
        	// choose
            chosen.add(i);
            // search/explore
            diceHelper(dice - 1, chosen);
            // un-choose
            chosen.remove(chosen.size() - 1);
        }
    }
}
```

为什么这里需要`un-choose`的步骤？

> 因为我们需要储存的是每一种单独的选择组合，在`explore`的过程中，我们改变了`chosen`中的数据存储，如果不进行`un-choose`的步骤，那么`chosen`的数据会一直保存下来。而在这里，`un-choose`的步骤刚好能够去除在每一次运行中添加在`chosen`中的元素。

为什么在`exhaustive search`中的`permutations`不需要`un-choose`的步骤？

> 因为在那道题目中，`prefix`不是按引用传递的，而在这道题目中，`vector`按照引用传递。

#### Dice roll sum

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109291825366.png" alt="image-20210929182500986" style="zoom:50%;" />

这道题目比较容易能想到使用回溯法做了：

```c++
Vector<int> diceSum(int dice) {
    Vector<int> v;
    diceHelper(dice, v);
    return v;
}

void diceSumHelper(int dice, int desiredSum, Vector<int> & chosen) {
    // if there is no choice to make
    if (dice == 0) {
        if (sumAll(chosen) == desiredSum) {
            cout << chosen << endl;
        }
    }
    else {
        for (int i = 1; i <= 6; ++i) {
        	// choose
            chosen.add(i);
            // search/explore
            diceHelper(dice - 1, desiredSum, chosen);
            // un-choose
            chosen.remove(chosen.size() - 1);
        }
    }
}
```

但是这个解法中毫无疑问经过了多次没有必要的函数运行，因为我们先是计算出了所有的可能的组合，之后只把符合条件的输出了，而我们本可以直接根据和的情况舍弃一些值，不继续进行函数循环：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109291832681.png" alt="image-20210929183243297" style="zoom:50%;" />

（红色标注的均是可以舍弃的情况）

所以这里就用到了回溯算法中经常结合的一个操作：剪枝操作。

> 1. computing sum over and over is wasteful
> 2. don't explore decision trees where values are too low/high

```c++
Vector<int> diceSum(int dice) {
    Vector<int> v;
    diceSumHelper(dice, 0, v);
    return v;
}

void diceSumHelper(int dice, int desiredSum, Vector<int> & chosen) {
    // if there is no choice to make
    if (dice == 0) {
        if (desiredSum == 0) {
            cout << chosen << endl;
        }
    }
    else {
        for (int i = 1; i <= 6; ++i) {
            int max = desiredSum - i - 1 * (dice - 1);
            int min = desiredSum - i - 6 * (dice - 1);
            if (max >= 0 && min <= 0) {
                // choose
                chosen.add(i);
                // search/explore
                diceHelper(dice - 1, desiredSum - i, chosen);
                // un-choose
                chosen.remove(chosen.size() - 1);
            }
        }
    }
}
```

如果我们再对此题进行改编：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109291855559.png" alt="image-20210929185557443" style="zoom:50%;" />

可以想到，我们需要一个参数来保存前一个只，并保证当前要选择的值必须不小于前一个值，之后将该参数更新为此次选择的值：

```c++
Vector<int> diceSum(int dice) {
    Vector<int> v;
    diceSumHelper(dice, 0, v, 0);
    return v;
}

void diceSumHelper(int dice, int desiredSum, Vector<int> & chosen, int curMinValue) {
    // if there is no choice to make
    if (dice == 0) {
        if (desiredSum == 0) {
            cout << chosen << endl;
        }
    }
    else {
        // update the for iteration
        for (int i = curMinValue; i <= 6; ++i) {
            // also update this formula
            int max = desiredSum - i - i * (dice - 1);
            int min = desiredSum - i - 6 * (dice - 1);
            if (max >= 0 && min <= 0) {
                // choose
                chosen.add(i);
                // search/explore
                diceHelper(dice - 1, desiredSum - i, chosen, i);
                // un-choose
                chosen.remove(chosen.size() - 1);
            }
        }
    }
}
```

#### Subsets

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109291904509.png" alt="image-20210929190436410" style="zoom:50%;" />

这道题很容易出现的错误是`vector`中元素顺序不一样，但是含有的元素是一样的，即下图所示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109291918105.png" alt="image-20210929191812011" style="zoom:50%;" />

为了避免这种情况的出现，我们应该把做选择的依据变更为：**是否包含某个元素**，而非先包含哪个元素。所以这道题目里不应当使用*for*循环，否则会造成重复选择，正确的*decision tree*如下：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109292036843.png" alt="image-20210929203639731" style="zoom:50%;" />

```c++
Vector<string> subsets(Vector<string>& v) {
    Vector<string> chosen;
    sublistHelper(v, chosen);
    return chosen;
}

void sublistHelper(Vector<string>& v, Vector<string>& chosen) {
    if (v.isEmpty()) {
        cout << chosen << endl;
    }
    else {
        // choose
        string mine = v[0];
        v.remove(0);
        // explore/search
        
        // Yes, include them
        chosen.add(mine);
        sublistHelper(v, chosen);
        // No, exclude them
        chosen.remove(chosen.size() - 1);
        subslitHelper(v, chosen);
        
        // un-choose
        v.insert(0, mine);
    }
}
```

#### 8 Queens Problem

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109292054905.png" alt="image-20210929205442510" style="zoom:50%;" />

一个比较简单的出发点是观察到在每一行以及每一列，一定存在并且仅存在一个*queen*。考虑每一行（或者每一列），然后对其中的每一列（每一行）的点逐个判定是否是可以摆放的点（是否安全），整体上使用回溯法解决：如果当前行（列）满足条件（可以摆放），那么就继续探索（坐标移到下一行（列）），否则将板上的皇后去掉：

```c++
void solveQueensHelper(Board& board, int col) {
    if (col >= board.size()) {
        // base case
        cout << board << endl;
    }
    else {
        for (int row = 0; row < board.size(); ++row) {
            if (board.isSafe(row, col)) {
                // choose
                board.place(row, col);
                // explore
                solveQueensHelper(board, col + 1);
                // un-choose
                board.remove(row, col);
            }
        }
    }
}
```

如果我们想让程序仅输出一个正确结果：

```c++
bool solveQueensHelper(Board& board, int col) {
    if (col >= board.size()) {
        // base case
        cout << board << endl;
        return true;
    }
    else {
        for (int row = 0; row < board.size(); ++row) {
            if (board.isSafe(row, col)) {
                // choose
                board.place(row, col);
                // explore
                bool result = solveQueensHelper(board, col + 1);
                if (result) {
                    return true;
                }
                // un-choose
                board.remove(row, col);
            }
        }
        return false;
    }
}
```

#### Travel

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202109292112528.png" alt="image-20210929211245120" style="zoom:50%;" />

这也是一个*backtracking*的问题，因为在穷举搜索的基础上，会存在一些*bad case*使得我们无法到达目标指定位置，那我们需要回溯到上一步的位置：

```c++
Vector<string> travel(const GPoint & target) {
    GPoint origin(0, 0);
    Vector<string> path;
    travelHelper(target, origin, path);
    return path;
}

void travelHelper(const GPoint& target, GPoint me, Vector<string>& path) {
    if (target == me) {
        cout << path << endl;
    }
    else if (me.getX() <= target.getX()
            && me.getY() <= target.getY()){
        // choose
        path.add("N");
        GPoint n(me.getX(), me.getY() + 1);
        // explore
        travelHelper(target, n, path);
        // un-choose
        path.remove(path.size() - 1);
        // choose
        path.add("E");
        GPoint e(me.getX() + 1, me.getY());
        // explore
        travelHelper(target, e, path);
        // un-choose
        path.remove(path.size() - 1);
        // choose
        path.add("NE");
        GPoint ne(me.getX() + 1, me.getY() + 1);
        // explore
        travelHelper(target, ne, path);
        // un-choose
        path.remove(path.size() - 1);
    }
}
```

## Assignment 4 & Section 3

### longestCommonSubsequence

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110082238743.png" alt="image-20211008223819618" style="zoom:50%;" />

这道题类似于**Assignment 4**的最后一个问题，是一个*subSet*问题。这种问题的一般想法是：**对于某个位置的某个元素，include or not?** 之后再针对**include/not include**的两种情况的大小或者其他条件，将各自作为返回值：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110082242585.png" alt="image-20211008224203512" style="zoom:50%;" />

### partitionable

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110082245138.png" alt="image-20211008224547075" style="zoom:50%;" />

这道题的解法不止一种，最初我的方法是将这道题转化为**dicsSum**来做，而答案则是转化成了一个类似于**include or not**的方法来做：对于每一个元素，我们可以选择加入*sum1*或者选择加入*sum2*，答案的写法是比较精妙的：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110082258439.png" alt="image-20211008225858366" style="zoom:50%;" />

这道题的处理让我想起在CS 61A中期末复习题中的一道题目(*lab14 q4*)：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110101937614.png" alt="image-20211010193749484" style="zoom:50%;" />

这道题也可以使用这种方法来做：

```c++
int subSeq(const vector<int>& test, int d) {
    vector<int> test1 = test;
    return subSeqHelepr(test1, 0, 0, d);
}

int subSeqHelepr(vector<int>& test, int sum1, int sum2, int d) {
    if (test.empty()) {
        return abs(sum1 - sum2) <= d;
    }
    else {
        int first = test[0];
        test.erase(test.begin());
        int result = subSeqHelepr(test, sum1 + first, sum2, d) + subSeqHelepr(test, sum1, sum2 + first, d);
        test.insert(test.begin(), first);
        return result;
    }
}
```

### listTwiddles

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110082315281.png" alt="image-20211008231534220" style="zoom:50%;" />

我们经常会遇到一些数据量比较大的递归问题，此时我们的选择不应当是在函数中直接遍历，比如此题中的**lexicon**，也比如在**Assignment 4**的第二个问题，我们应当遍历的都是针对题目所谓的*neighbors*。在**Assignment 4**中，对大数据集**unCovered**的处理是通过改变函数参数，将此次函数使用的*neighbors*去除实现的；而在本题中，则增加了一个参数*index*来实现对**Lexicon**的持续遍历。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110082330256.png" alt="image-20211008233002175" style="zoom:50%;" />

## CS 106X Lecture 16-18 & UIUC CS 225 -- Trees

> 本部分内容参考《算法导论》以及《大话数据结构》、《算法》

在这里对一些可能面试会用到的树的类型做一个总结：

对于一棵二叉树来讲，我们可以通过**DFS**和**BFS**两种方法对树进行搜索（或者进行遍历）。考虑*search*这一操作：我们可以得到如下的时间复杂度与空间复杂度（均指最坏情况）：

|      | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- |
| DFS  | O(n)       | O(h)       |
| BFS  | O(n)       | O(n)       |

在讨论时，主要考查完美二叉树以及`h=n`的特殊情况，对于空间复杂度的分析通过计算实现*DFS*与*BFS*操作的栈内节点数量得到。如果我们使用递归实现，那么**求的是递归最深的那一次压栈所耗费的空间的个数；递归最深的那一次所耗费的空间足以容纳它所有递归过程。**

### Binary Search Tree (BST)

#### 基本数据结构

```c++
class BST {
    public:
    // remove
    // insert
    // getMin
    //...
    
    private:
    // a node data structure
        struct TreeNode {
            int value;
            TreeNode* left, right;
            // a constructor
            TreeNode(int value, TreeNode* left = nullptr, TreeNode* right = nullptr)
            {};
        };
        // head pointer
        TreeNode* head;
};
```

二叉搜索树具备以下特征：

1. *left.v < p.v < right.v*
2. O(lgn) < O(V) < O(h)

#### 方法实现

##### contains-O(h)

```c++
bool contains(TreeNode*& node, int value) {
    if (node != nullptr) {
        if (node->data == value) {
            return true;
        }
        bool result = contains(node->left, value) ||
            contains(node->right, value);
        if (result) {
            return true;
        }
    }
    return false;
}
```

##### search-O(h)

```c++
TreeNode* find(TreeNode*&, int value) {
    if (node != nullptr) {
        if (value < node->data) {
            return find(node->left, value);
        }
        else if (value > node->data) {
            return find(node->right, value);
        }
        else {
            return node;
        }
    }
    return nullptr;
} 
```

##### getMin-O(h)

> 最小值存在于树的最左侧节点，同理，最大值为树的最右侧节点

```c++
// pass by pointer(value)
int getMin(TreeNode* node) {
    if (node->left != nullptr) {
        return getMin(node->left);
    }
    else 
        return node->data;
}
```

##### insert-O(h)

```c++
void insert(TreeNode*& node, int value) {
    if (node != nullptr) {
        if (value > node->data) {
            insert(node->right, value);
        }
        else if (value < node->data) {
            insert(node->left, value);
        }
        else {
            // do nothing, don't need to insert
            return;
        }
    }
    node = new TreeNode(value);
}
```

##### remove-O(h)

> 当所删除节点有**两个孩子**时，主要流程包括:
>
> 1. 先找到删除节点
> 2. 找到该节点的**前驱**或者**后继**
> 3. swap
> 4. 删除交换后的原节点

```c++
void remove(TreeNode*& node, int value) {
    if (node == nullptr) return;
    if (value > node->data) {
        remove(node->right, value);
    }
    else if (value < node->data) {
        remove(node->left, value);
    } 
    // different removing cases
    else {
        // case 1: leaf
        if (node->isLeaf()) {
            // free the memory that the current node pointing at
            delete node;
            // set the node pointing to null, indicating node's parent
            // that there is no child
            node = nullptr;
        }
        // case 2: only left subtree
        else if (node->right == nullptr) {
            TreeNode* trash = node;
            node = node->left;
            delete trash;
        }
        // case 3 : only right subtree
        else if (node->left == nullptr) {
            TreeNode* trash = node;
            node = node->right;
            delete trash;
        }
        // case 4: have two children
        else {
            // find IOS
            int minValue = getMin(node->right);
            node->data = minValue;
            remove(node->right, minValue);
        }
    }
}
```

### AVL Tree (Balanced  Tree)

#### 基本特征

Height balance: 

`b = height(Tr) - height(Tl)`

A tree is balanced if: The tree itself and all its subtrees meets: $$\lvert b \rvert \le 1$$.

- Four kinds of rotations (**L, R, LR, RL**)
- All rotations are local (subtrees are not impacted)
- All rotations are constant time: **O(1)**
- BST property maintained

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110161852300.png" alt="image-20211016185257206" style="zoom:50%;" />

##### rotation example

- **L**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110161451602.png" alt="image-20211016145105424" style="zoom:50%;" />

> 只需要更改**3**处指针，所以旋转的操作时间复杂度为常数级

- **LR**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110161839255.png" alt="image-20211016183902941" style="zoom:50%;" />

需要注意的几个变换特征：

1. 对于单独的左旋转与右旋转，我们所处理的对象是一个*stick*；而对于两种复合操作来说，我们所处理的对象形状被定义为一个*elbow*。
2. 分别观察左旋转与右旋转，我们容易发现，它们都是以*stick*的中心节点为轴，左旋转将*stick*中的顶端节点转到左下端，而右旋转则成对称式地将位于右上的顶端节点旋转到右下方。他们最后都形成一个*山峰*状。
3. 对于此类复合型操作，在图像上的效果也是**先展开再弯曲**.从操作上来讲，是先对中间节点进行左旋（右旋），之后再对整体（子树根节点）进行右旋（左旋）。

##### finding rotations on Insert

- L

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110161903267.png" alt="image-20211016190321171" style="zoom:50%;" />

因为在插入节点后，平衡标志的计算是自顶而上的，在**第一次检测到**不满足AVL条件的位置*t*，平衡系数*b*一定为**2**.

继续推断得到：*t->right*的*b*值为**1**.

- RL

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110161944872.png" alt="image-20211016194415770" style="zoom:50%;" />

同理，对于这一类旋转，*t*位置*b*为**2**，但是*t->right*的*b*为**-1**.

#### 基本数据结构

```c++
struct TreeNode {
    int data;
    // need to keep track of the node's height
    unsigned height;
    TreeNode* left;
    TreeNode* right;
}
```

#### 方法实现

##### height-O(1)

```c++
int height(TreeNode* node) {
    if (node == nullptr) {
        return 0;
    }
    return node->height;
}
```

##### rightRotate-O(1)

```c++
void rightRotate(TreeNode*& node) {
    TreeNode* x = node->left;
    TreeNode* t2 = x->right;
    
    // perform rotation
    x->right = node;
    node->left = t2;
    
    // update the heights
    node->height = max(height(node->left), height(node->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
}
```

##### leftRotate-O(1)

```c++
void leftRotate(TreeNode*& node) {
    TreeNode* x = node->right;
    TreeNode* t2 = x->left;
    
    // preform rotation
    x->left = node;
    node->right = t2;
    
    // update the height
    node->height = max(height(node->left), height(node->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
}
```

##### reBalance-O(lgn)

```c++
void rebalance(TreeNode*& node) {
    // calculate two balances
    int balance = height(t->right) - height(t->left);
    
    if (balance == 2) {
        int rightBalance = height(node->right->right) - height(node->right->left);
        if (rightBalance == 1) {
            // R
            leftRotate(node);
        }
        else if (rightBalance == -1) {
            // RL
            rightRotate(node->right);
            leftRotate(node);
        }
    }
    else if (balance == -2) {
        int leftBalance = height(node->left->right) - height(node->left->left);
        if (leftBalance == -1) {
            // R
            rightRotate(node);
        }
        else if (leftBalance == 1) {
            // LR
            leftRotate(node->left);
            rightRotate(node);
        }
    }
    // update the t's height
    node->height = max(height(node->left), height(node->right)) + 1;
}   

```

##### insert-O(lgn)

AVL树的插入操作可以被分为四个步骤：

1. Insert at proper place
2. Check for imbalance
3. Rotate, if necessary
4. Update height
5. Recursive up

```c++
void insert(TreeNode*& node, int value) {
    // insert
    if (node == nullptr) {
        node = new TreeNode(value);
    }
    // will insert and adjust the right tree
    else if (value > node->data) {
        insert(node->right, value);
    }
    // will insert and adjust the left tree
    else if (value < node->data) {
        insert(node->left, value);
    }
    // rebalance the tree
    reBalance(node);
}
```

> 为什么插入操作只需要对树进行一次*reBalance*，因为插入会将树的高度增加1，而重平衡会将树的高度减短1，故不会对其余部分造成影响。

##### remove-O(lgn)

```c++
void remove(TreeNode*& node, int value) {
    // use the BST remove function
    remove(node, value);
    // reBalance the tree (each subtree)
    reBalance(node);
}
```

#### 复杂度分析

这一部分可以参见UIUC CS 225关于AVL树的性能分析，通过节点数目与树的高度的关系得到了一个粗略的下界，反过来确定了树高度的上界（一个估计值）。这里不作详细讨论。

### Tries (Dictionary  Search  Tree)

#### 基本数据结构

```C++
struct TireNode {
    TrieNode* chilren[26];
    bool isWord;
}
```

单词查找树的特点在于：**查找命中所需的时间与被查找的键的长度成正比**。（如果我们将字母存储于一个二叉平衡搜索树中，则查找需要的时间为**键的长度*O(lgn)**）

#### 方法实现（My Github）

由于字典查找树的实现较为复杂，我将实现方法放到了我的[GitHub仓库](https://github.com/SongShaopu1998/Tries)中，该仓库内同时包含了压缩字典查找树，即*compressed trie*的实现。

> 关于*compressed trie*，这里有一篇博客讲得比较清楚，我的代码也是根据此原理实现：
>
> http://theoryofprogramming.com/2016/11/15/compressed-trie-tree/

### KD-Tree & BTree

这部分内容不作详细实现了，KD-Tree准备在CS 106L课程中实现，B树的性质讲解可以参见UIUC CS 225的课程视频。这里仅仅列出关于B树的一部分内容：

#### B树性质

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110191803091.png" alt="image-20211019180300906" style="zoom:50%;" />

#### insert & search

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202110191807439.png" alt="image-20211019180741294" style="zoom:50%;" />

这段代码的思路其实也很好理解，先找到所查看节点中的合理位置，之后再根据情况进行递归即可，或者直接返回结果。

而B树的插入是一个自底向上的过程，首先找到该层节点中合适的位置，之后我们通过递归不断变更节点的祖先（如果有必要）。

### Segment Tree



### Binary Heap

