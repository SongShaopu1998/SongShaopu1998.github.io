---
layout:		post
title:		CS基础课程4
subtitle:	Stanford CS 106L
date:		2021-11-07
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C++
    - CS基础课程笔记
---

我将2019秋季Stanford的CS 106L作业发布在我的[Github仓库](https://github.com/SongShaopu1998/Stanford-CS-106L).

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091826467.png" alt="image-20211109182644300" style="zoom:50%;" />

## stream

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091455815.png" alt="image-20211109145516729" style="zoom:50%;" />

### stringstream

以下内容来自官方文档：

> Stream class to operate on strings.
>
> Objects of this class use a *[string buffer](https://www.cplusplus.com/stringbuf)* that contains a sequence of characters. This sequence of characters can be accessed directly as a [string](https://www.cplusplus.com/string) object, using member [str](https://www.cplusplus.com/stringstream::str).
>
> Characters can be inserted and/or extracted from the stream using any operation allowed on both *[input](https://www.cplusplus.com/istream)* and *[output](https://www.cplusplus.com/ostream)* streams.
>
> **stream buffer**: "A stream buffer is an object in charge of performing the reading and writing operations of the *stream* object it is associated with: the stream delegates all such operations to its associated *stream buffer* object, which is **an intermediary between the *stream* and its *controlled input and output sequences***."
>
> <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100150967.png" alt="image-20211110015005910" style="zoom:50%;" />
>
> <img src="https://upload.cppreference.com/mwiki/images/7/75/std-streambuf.svg" alt="std-streambuf.svg"  />

> **All *stream* objects, no matter whether buffered or unbuffered, have an associated *stream buffer***: Some *stream buffer* types may then be set to either use an intermediate *buffer* or not.

`stringstream`类继承自几个`ios`基础类：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081327496.png" alt="image-20211108132713194" style="zoom:50%;" />

`stringbuf`继承自`streambuf`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111090021218.png" alt="image-20211109002123175" style="zoom:50%;" />

#### read & write

该类在实际使用中，常常用于分割字符（按空格）。它将`string`存放到一个`string buffer`（继承自`streambuf`）中：

> Internally, its [iostream](https://www.cplusplus.com/iostream::iostream) base constructor is passed a pointer to a [stringbuf](https://www.cplusplus.com/stringbuf) object constructed with str and which as arguments.

我们可以通过参数`stringstream::ate`指定指针位置在末端；如果我们使用的是`istringstream`，那么可以使用`stringstream::bin`的方式以二进制读取。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081336407.png" alt="image-20211108133647355" style="zoom:33%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081337944.png" alt="image-20211108133704904" style="zoom:33%;" />

每当我们使用`stringstream object`向该`string buffer`中读入数据时，指针会不断向后做相应移动，就像这样：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081338230.png" alt="image-20211108133834185" style="zoom:33%;" />

我们还可以使用`.str()`方法将存放于`string buffer`中的内容读取成字符串。

#### about ">>"

我们可以指定类型，之后使用`>>`操作符将内容读入指定类型的变量中。在C++官方[文档页面](https://www.cplusplus.com/reference/istream/istream/operator%3E%3E/)上，对这一操作进行了详细的描述，该运算符被多次重载用以接受以下三种参数：

- `arithmetic types`
- `stream buffers`
- `manipulators`

具体的操作可以参见上边的链接，总之就是要借助于继承自`istream`的`sentry`类来辅助处理输入流（接受一个`stream object parameter`），**它首先会检测当前`internal error flags`的状态，如果为`good`，则继续进行，否则不会对流做任何操作，这一点需要注意。**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100144760.png" alt="image-20211110014417695" style="zoom:50%;" />

在运算过程中，程序通过设定`ios_base::iostate`的值来告诉目前`stream`的情况--还提供了相应的函数帮助我们进行判断，这几个常量被称为`internal error state flags`，具体见下表:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081426342.png" alt="image-20211108142645284" style="zoom:50%;" />

我们可以通过调用方法`ios::rdstate() const`来获取当前`internal error state flags`的值，或者使用`basic_ios::setstate()`来修改当前标志位的值。需要注意的是，已经设置了的`bitflag`是不会自动清除的(`sticky!`)，需要通过调用`basic_ios::clear(iostate state = goodbit)`来替换当前状态。

> 需要注意的是，`End-Of-File`并不是什么存在于文件末尾的字符，`EOF`是定义于标准库内的一个宏(`macro`):
>
> ```c++
> #define EOF (-1)
> ```
>
> 当文件或者字符串被读取到末尾时，**读取函数会返回`-1`**，所以我们也说`eof reached`.当文件（字符串）末尾到达后，程序设置`eofbit`，但是需要注意此时`failbit`与`badbit`也可能同时被设置.
>
> > "Reaching the *End-of-File* sets the eofbit. But note that operations that reach the *End-of-File* may also set the failbit if this makes them fail (thus setting both eofbit and failbit)."

那么问题来了，`>>`会在什么时候设置这几个`bitflag`呢？官方[文档](https://www.cplusplus.com/reference/istream/istream/operator%3E%3E/)也给出了详细说明（啥都没发生就是`goodbit`）:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081445541.png" alt="image-20211108144549477" style="zoom:50%;" />

当内置错误标志为`fail`时，我们也可以利用C++库的从`istream object&`到`bool`的隐式转换`ss >> ch`作为`!ss.fail()`的替代:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111102311395.png" alt="image-20211110231100308" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111102311243.png" alt="image-20211110231116176" style="zoom:50%;" />

在本课的`stringToInteger`函数中，我们见到如下使用方式：

```c++
int stringToInteger(const string& str) {
    istringstream iss(str);
    int result;
    iss >> result;
    cout << "result: " << result << endl;
    if (iss.fail())
        throw domain_error("error1");
    char remain;
    iss >> remain;
    cout << "remain: " << remain << endl;
    if (!iss.fail())
        throw domain_error("error2");
    return result;
}

// case 1:
// result: 5, remain: l
// error2
stringToInetger("5lol");
// case 2:
// result: 0
// error1
stringToInteger("lol");
```

为什么会出现如上的情况？这要考虑到`>>`第一种重载模式，即用来读取算术类型的内置操作：

> "Extracts and parses characters sequentially from the stream to interpret them as the representation of a value of the proper type, which is stored as the value of val.
> Internally, the function accesses the input sequence by first constructing a [sentry](https://www.cplusplus.com/istream::sentry) object (with noskipws set to `false`). Then (if [good](https://www.cplusplus.com/ios::good)), it calls [num_get::get](https://www.cplusplus.com/num_get::get) (using the stream's *[selected locale](https://www.cplusplus.com/ios_base::getloc)*) to perform both the extraction and the parsing operations, adjusting the stream's *[internal state flags](https://www.cplusplus.com/basic_ios::rdstate)* accordingly. Finally, it destroys the [sentry](https://www.cplusplus.com/istream::sentry) object before returning."

注意到此时在内部是使用了`num_get::get`方法对数字进行读取的，如果成功读取，把结果存储在参数`val`中，并利用此函数更新`internal error flags`(利用传递给`get`方法的`ios_base::iostate& err`参数)：

> - "The function stops reading characters from the sequence as soon as one character cannot be part of a valid numerical expression (or end is reached). The next character in the sequence is pointed by the iterator returned by the function."
>
> - "*Return value*: The next character in the sequence right after where the extraction operation ended."
> - <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081615482.png" alt="image-20211108161553419" style="zoom:50%;" />

当尝试使用`int type`读入字符串`"5lol"`时，首先`num_get::get`方法读取数字5，由于下一个`char`不是`part of valid numerical expression`，所以他立即停止读取，此时`val`的数值为`5`. 指针指向`5`的下一个字符`l`.

当尝试使用`int type`读入字符串`"lol"`时，首先`num_get::get`方法读取字符`l`，发现` The sequence did not match the expected format`，所以他立即停止读取，此时`val`的数值为`0`. 指针仍然指向头部，并设置了一个`failbit`，于是当我们返回到`>>`的处理过程中时，就会显示`fail()`了，这也与`>>`产生`failbit`的条件吻合，因为此时相当于没有新的字符被成功提取，同时`sb`此时也是一个`null pointer`.(因为我们用的是`int type`处理)。并且`result`的输出值为`0`，这也是`num_get::get`方法中`val`被存储的值。

> 如果我们把第二次读取的类型换成`double`，并尝试读入字符串“5.2”时，不会出现任何问题，因为在第一次读取`5`之后，序列中余下的`.2`被程序理解为`0.2`，也是我们第二次读取输出的结果。

#### white space separating？

为什么使用`stringstream`之后`istream >> string`读取字符串能够自动以空白字符作为分割？

这是因为`string`类本身也对`extraction operator`进行了重载：

```c++
istream& operator>> (istream& is, string& str);
```

按照*StackOverflow*的说法，该函数的实现类似于**C**中的*scanf %s*，他会持续读取直到遇到空白字符（包括空格、tab等）下一次从空白字符开始读取（但是默认会`skipws`）。在官方[文档](https://www.cplusplus.com/reference/string/string/operator%3E%3E/)中，我们找到了依据：

> Notice that the [istream](https://www.cplusplus.com/istream) extraction operations use whitespaces as separators; Therefore, this operation will only extract what can be considered a word from the stream. To extract entire lines of text, see the [string](https://www.cplusplus.com/string) overload of global function [getline](https://www.cplusplus.com/string:getline).
>
> <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100156520.png" alt="image-20211110015649451" style="zoom:50%;" />

也就是说如果我们使用`>>`将数据读入字符串，那么他会尝试着一个单词一个单词地读取。该过程的实现也是借助于一个由指针`sb`指向的`streambuf object`，每次我们都在向该`streambuf`写入数据，在向`streambuf`写入完毕之后，将`streambuf object`中的内容写给`string`对象。**所有的stream对象，都有一个与之关联的`streambuf object`**.

#### Again--About Whitespaces!

下边来看这样两个例子：

1. ```c++
   string a = " 12 3";
   stringstream iss(a);
   char b, c;
   iss >> std::noskipws >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b:  c: 1
   ```

   ```c++
   string a = " 12 3";
   stringstream iss(a);
   char b, c;
   iss >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b:1  c: 2
   ```

2. ```c++
   string a = " 12 3";
   stringstream iss(a);
   string b, c;
   iss >> std::noskipws >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b:  c: 
   ```

   ```c++
   string a = " 12 3";
   stringstream iss(a);
   string b, c;
   iss >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b: 12 c: 3
   ```

这两个例子中唯一的区别就是第一个我们提供了`char`类型，而第二个是`string`类型。首先我们不去关注代码中的`noskipws`，看第二个例子，即`string`的那一个：根据上一节的描述，当`istream >> string`遇到了**空白字符**时，他会停止读取，而恰好，在字符串`a`的最前边存在一个**空白字符**，所以我们想它应该会直接在开头处停止，不会读取到任何东西，所以最后返回的是空字符串。

但是我们发现如果尝试将代码中的`std::noskipws`去掉，那么返回的结果会与之前不同，这又是为什么呢？

首先我们需要了解运算符`>>`重载的第三种类型：`manipulators`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081624307.png" alt="image-20211108162408233" style="zoom:50%;" />

注意到`skipws/noskipws`这种类型，当`skipws`被设置时，`stream`默认会忽视所有的空白字符，[文档](https://www.cplusplus.com/reference/ios/skipws/)中提到：

> "For standard streams, the skipws flag **is set** on initialization."

也就是说，在默认情况下初始化的结果为设置了`skipws`，所以所有空白字符都会被读取之后跳过，直到我们又发现了一个**非空白字符**。如此一来，上边例子的结果就好理解了。需要注意的是，在C++中，对于所有的`formatted input`（即可以格式化成我们需要的类型的，比如C中的`prinf, scanf`，C++中使用`>>`操作的），默认都是`noskipws=false`，也就是说会**跳过空白字符**；而对于所有的`unformatted input`（比如`getchar(char), getline(string)`）均设置为`noskipws=true`。

> 关于格式化输入与非格式化输入，我是这么理解的，格式化输入意味着我们可以把输入的数据变成我们想要的类型，比如当我们使用`>>`操作符时，我们可以读入整型，也可以读入一个字符串；但是非格式化输入只能读入`rawText type`，好比`geline(string)`我们输入了一个字符串那么接受类型就是一个字符串.

同时，`skipws`与`noskipws`两者是`sticky`的，也就是说我们只有重新设置，才能变回原来的状态。如果想要每一步都可以设置是否保留**空白字符**，我们可以使用`std::ws`，提取**空白字符**，直到遇到**非空白字符**。

> 设置`skipws`等的步骤是在为输入序列创建`sentry`对象时进行的.

除了上述提到的`skipws`这种`manipulator`之外，常见的可以用于`pad output`的还有：`left/right/internal`, `setw`, `setfill`等：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091756123.png" alt="image-20211109175615973" style="zoom:50%;" />

这几个`manipulator`在内部调用了内置的一些方法，比如`setfill`是调用了`basic::ios::fill(char_type)`，`left`是设置了名为`adjustfiled`的`flag value`，`setw`则和使用`width(n)`的效果相同，设置了`field width`–所以该函数指定的是输出序列中允许存在的**最少的字符数**。

#### set position

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081358479.png" alt="image-20211108135808429" style="zoom:50%;" />

需要注意的是，在`streamoff`中，`n`的值可正可负。常见的使用方法如下：

```c++
fpos = oss.tellp() + streamoff(3);
oss.seekp(pos);
// or
oss.seekp(streamoff(1), stringstream::cur);
```

### cin & cout

由于`cin`实际上是一种`istream object`，有些特性上边一节已经总结的差不多了…这里只总结两点：

1. 为什么明明输入流默认设置`skipws`，但是我们输入一个`\n`时，`console`内仍然会打印出新的一行？

这是因为控制台内的打印是由`consle software`控制的，与`cin`没有任何关系。

2. cin is *[tied](https://www.cplusplus.com/ios::tie)* to the standard output stream [cout](https://www.cplusplus.com/cout) (see [ios::tie](https://www.cplusplus.com/ios::tie)), which indicates that [cout](https://www.cplusplus.com/cout)'s buffer is *flushed* (see [ostream::flush](https://www.cplusplus.com/ostream::flush)) before each i/o operation performed on cin.

> The tied stream is an output stream object which is *[flushed](https://www.cplusplus.com/ostream::flush)* before each i/o operation in this stream object.

我们常用的`std::endl`就是**换行+刷新输出缓冲区**，所以如果我们仅仅使用`cout`而不添加`endl`，字符会首先存到`output buffer`中，**只有当`output buffer`满了或者程序终止时，才会调用`flush`方法**。

那么问题来了，`std::flush`是如何工作的？[这里](https://stackoverflow.com/questions/14105650/how-does-stdflush-work)给出了较为详细的解答。

言简意赅地说，`ostream::flush()`会在内部调用`streambuf::pubsync()`方法，对流缓冲区进行操作；流缓冲区的作用是负责“缓冲”字符并把数据发送给外部目的地–这发生在缓冲区已满或者内部数据**应当**与外部目的地进行**同步**的时候（比如`flush()`）。当需要同步时，缓冲区内部的数据立即发送给外部目的地，根据官方[文档](https://www.cplusplus.com/reference/ostream/ostream/flush/)：

> For *[stream buffer](https://www.cplusplus.com/streambuf)* objects that implement intermediate buffers, this function requests all characters to be written to the controlled sequence.

这意味着，如果我们正在尝试把数据输出到控制台上，那么此操作会立即把缓冲区内目前所有的字符输出输出流中，再显示到控制台界面上，这意味着清空了`stream buffer`。对于文件流效果是一样的，只不过外部目的地换成了**文件**而已。

所以何时需要进行`flush`操作呢？当然是我们接下来有可能需要向外部目的地写入数据的时候，因为如果此时缓冲区内还存有先前的数据，那毫无疑问的会造成影响！

3. 如果我们注意在输入过程中`internal error flag`的变化，则在每次`flush`之后，以及每次`cin`读取完数据后，内置错误标志位都会被设置成`eof`. 因为输入流意识到自己读到了字符串的末尾。需要注意的是，如果在输入过程中，标志位在某一刻被设置成`fail`，那么此后的所有尝试输入的操作均会失效，这一点我们在前边提到过，必须使用`clear()`清空状态才可以继续进行。

#### ignore

函数原型：

```c++
istream& ignore (streamsize n = 1, int delim = EOF);
```

注意到这种特殊的使用方法，可以帮助我们忽略掉当前`stream buffer`中所有的数据，直到**eof**：

```c++ 
con.ignore(numeric_limits<streamsize>::max(), ‘\n’);
```

### getline(string)

该函数常被用来读取一整行的数据，或者按照`delimiters`分割数据；这是一个`unformatted input function`，根据前几节所属的特点，非格式化输入函数默认设置`noskipws`，那么当遇到分割字符时，它的处理方法是：

> If the delimiter is found, it is extracted and discarded (i.e. it is not stored and the next input operation will begin after it).

同样的，该函数也会对`internal error flags`进行设置。

在文件读取中，如果我们读到了文件末尾，那么`getline`会设置一个`eofbit`，但是此时并不会设置`failbit`，而在继续的下一次读取中，因为我们没有读取到任何内容，**根据failbit**的定义，`sentry object`会置一个`failbit`，借助这一特点，我们在实际使用中常把读取循环写作如下形式而非`while(!input.fail())`，进而避免向数据结构中输入最后一次读取的`garbage value`：

```c++
ifstream file(filename);
while(true) {
    string line;
    getline(file, line);
    if (file.fail()) {
        break;
    }
    // process the read data
}
```

> 我们可以通过在`char*(c-string)`后加一个`s`字母的方式，将其转化为`C++ string`

## type deduction

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091508689.png" alt="image-20211109150854609" style="zoom:50%;" />

## structure

### pair

在C++中，传统的返回多个值的方法是使用`reference parameters`，但问题在于除非我们查看函数定义，否则引用参数并不明显。在C++11中提供了`pair`或者`tuple`，我们可以使用他们组合多个返回值：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091512437.png" alt="image-20211109151222334" style="zoom:50%;" />

```c++
std::pair<std::string, std::string> f(std::pair<std::string, std::string> p)
{
    return {p.second, p.first}; // list-initialization in return statement
}
```

### tuple

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091657348.png" alt="image-20211109165717288" style="zoom:50%;" />

### structured binding

在C++17中，与Python类似，我们可以做`unpack`（`structured binding`）：

```c++
auto [min, max] = findPriceRange(dist);
```

如果我们使用结构体作为以上函数的返回值，那么`structured binding`仍然可以使用。

我们还可以对引用使用`structured binding`:

```c++
void transformToDST(vector<Course>& courses) { 
    for (auto& [code, start, end, instructors] : courses) { 
        start++; 
        end++; 
    }
}
```

```c++
void print_map(std::string_view comment, const std::map<std::string, int>& m)
{
    std::cout << comment;
    for (const auto& [key, value] : m) {
        std::cout << key << " = " << value << "; ";
    }
    std::cout << "\n";
}
```

### Aggregate initialization

随着C++标准的不断更新，初始化的方式愈发多样化。`aggregate initialization`是一种`list-initilization`，在**C++20**中也被叫做`direct initialization`. 他应用于`arrays`以及`class type`，比如结构体或者联合，但是在使用时有一些特殊要求，可参见[文档](https://en.cppreference.com/w/cpp/language/aggregate_initialization)。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111111743654.png" alt="image-20211111174324498" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091539422.png" alt="image-20211109153853532" style="zoom:50%;" />

> 这里的`course`是一个结构体

需要注意的是，当使用`uniform initialization`时，对象会首先尝试使用`initilizer list constructor`而非普通的构造函数：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091548990.png" alt="image-20211109154855889" style="zoom:33%;" />

**当我们尝试使用`aggregate initialization`的方法初始化结构体等`class type`时，在C++11中被做了`不允许在存在默认初始化参数的情况下使用`的限制，这一限制条件在C++14中被取消。**：

```c++
struct A {
  string str;
  int n = 42;
  int m = -1;
};
A{.m=21}  // Initializes str with {}, which calls the default constructor
          // then initializes n with = 42
          // then initializes m with = 21
```

**文档截图中的初始化方案3，4被称为`designated initilizers`，这种初始化方法要保证所有元素的初始化顺序与定义顺序一样，但是我们可以缺省某个参数：**

```c++
struct A { int x; int y; int z; };
A a{.y = 2, .x = 1}; // error; designator order does not match declaration order
A b{.x = 1, .z = 2}; // ok, b.y initialized to 0
```

我们可以使用`designated initializers`来初始化联合，但是**union只允许我们提供一个初始化参数成员：**

```c++
union u { int a; const char* b; };
u f = { .b = "asdf" };         // OK, active member of the union is b
u g = { .a = 1, .b = "asdf" }; // Error, only one initializer may be provided
```

详细内容参见官方文档.

## STL

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111092139795.png" alt="image-20211109213909613" style="zoom:50%;" />

> `vector[i]` causes undefined behavior!

- `Sequence containers`

1. vector
2. deque（双端队列）
3. array
4. list（双向链表）
5. forward_list（单链表）

- `Container Adaptors`

1. stack
2. queue
2. priority_queue

这类容器之所以叫`adaptors`，是因为他们底层的结构实际上是由另一种容器构成的，我们也可以通过更换函数声明中的模板参数: stack和queue的底层是一个deque:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111092042210.png" alt="image-20211109204236062" style="zoom:50%;" />

- `Associative containers`

1. map
2. set
3. unordered_map
4. unordered_set
4. multimap/unordered_multimap
4. multiset/unordered_multiset

> 所谓`multimap`与`multiset`，是指的可以存在多个相同的键值（元素）.

需要注意的是，`map`方法`at(i)`和`[i]`的区别：`at`方法如果没有找到该元素，会抛出一个异常，而如果我们使用`[]`，那么在没有找到该元素时，会先进行创建。

### iterator

迭代器是STL的重要方法，我们所使用的`range for loop`就是使用迭代器在内部工作的。

> 注意`iterator`的`end`指向的是最后一个元素的后一位.

#### map iterator

`map`的迭代器比较特殊，它指向一个`pair`对象，所以我们可以使用`a.first`和`a.second`获取键与值：

```c++
map<int, int> m;
map<int, int>::iterator i = m.begin();
map<int, int>::iterator end = m.end();
while(i != end) {
    cout << (*i).first << (*i).second << endl;
    ++i;
}
```

在C++20之前，如果我们想要查找容器中是否存在某个键，那么需要调用`find`或者`end`方法，而在C++20中，我们只需要调用`contains`即可。

> 如果`find`成功，则`iterator`指向对应的元素，否则指向`end`. `count`方法通过调用`find`实现，所以`find`方法的速度更快.

#### lower_bound & upper_bound

`lower_bound`接受一个值`v`，返回一个`iterator`对象，该对象指向第一个**不小于**元素`v`的位置，如果没有找到，则指向`end`。

`upper_bound`与`lower_bound`的工作方式类似，但是其返回的迭代器对象指向第一个**大于**元素`v`的位置。

#### Iterator Types Introduction

共有五种基本的迭代器类型：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100017458.png" alt="image-20211110001729377" style="zoom:50%;" />

上图中的箭头我们可以理解成*继承*关系。对于所有的迭代器类型，他们都具备以下几种基本操作功能：

- Is *[copy-constructible](https://www.cplusplus.com/CopyConstructible)*, [copy-assignable](https://www.cplusplus.com/CopyAssignable) and [destructible](https://www.cplusplus.com/Destructible)
- can be advanced using `++`
- can be derederenced using `*`

1. `Input Iterators`

应用对象：**连续**+**单向**输入，下边来分别解释这两个限制条件的意思：

- **连续**，表示所应用的数据结构不可以是`queue`，`stack`等（不包括`deque`，因为`deque`实际效果上是一个优化了前序插入的`vector`）
- **单向**（`single-pass`），迭代器对应的每个位置只能允许被*经过*一次，这个限制条件之后会详细解释

`input iterators`只能作为右值（`rvalue`）被解引用：

```c++
int val = *itr;
```

这种迭代器的应用场景有之前提到过的`find`以及`count`函数等。这种迭代器类型数据是**只读的**。

2. `output iterators`

它的应用条件与`input iterators`相同，但是它只能作为左值（`lvalue`）被解引用：

```c++
*itr = 12;
```

该迭代器对象的应用场景主要有`copy`以及`output streams`等。它是**只写的**。

3. `forward iterators`

这种迭代器类型与把前两种类型结合起来的效果类似，不同的是，他可以做`multiple pass`. 应用场景主要有`replace`函数以及`forward_list`中。

4. `bidirectional iterators`

承接`forward iterators`，但是可以做`--`操作：

```c++
vector<int>::iterator itr = v.begin();
--itr;
```

应用场景主要有`reverse`函数，`map`, `set`以及`list`等。

5. `random Access iterators`

承接上一种类型，但是支持`+=n`与`-=n`操作，同时可以使用`offset dereference operator ([])`，应用在容器`vector`, `deque`, `string`以及**指针**上。

> Instead of being defined by specific types, each category of iterator is defined by the operations that can be performed on it. This definition means that any type that supports the necessary operations can be used as an iterator -- for example, a pointer supports all of the operations required by [*LegacyRandomAccessIterator*](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator), so a pointer can be used anywhere a [*LegacyRandomAccessIterator*](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator) is expected.

关于迭代器类型，补充以下一些内容：

除了上述提到的5种基本类型的迭代器，**C++**后来新增了一种基本迭代器类型：`Contiguous Iterator`，这种迭代器类型在`randomAccess Iterators`的基础上保证了**其中的数据在内存必须连续存储**。

在[**C++20**](https://en.cppreference.com/w/cpp/iterator)中，根据新的关键字`concept`以及`requires`对迭代器类型根据新的系统设计了一套定义，但是基本的类型是相似的；

> 我们可以简单地将这两个关键字的功能理解为：为模板参数制定一些限制，使得在*编译*阶段就能够进行`evaluation`。应用他们的主要优点是可以得到更加清晰地编译器报错。这里不去深究，[这篇文章](https://www.cppstories.com/2021/concepts-intro/)写的较为清楚。

新的迭代器定义基本方法是先使用这两个关键字定义了一种`input_or_output_iterator`类型，之后扩展的每一种类型均满足这种基本迭代器类型的要求，从定义中可以看到，这种基本类型支持两种操作：解引用+递增操作符：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101555478.png" alt="image-20211110155516376" style="zoom: 33%;" />

新定义的迭代器类型除了`output_iterator`是直接在`input_or_output_iterator`基础上增加了写入功能之外，其余的迭代器类型均[继承](https://en.cppreference.com/w/cpp/concepts/derived_from)自**C++20**之前的迭代器类型，比如对于`input iterator`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101600970.png" alt="image-20211110160016902" style="zoom:50%;" />

#### What is single-pass?

什么是`single-pass`？为什么只能`single-pass`？**C++标准库**中提到：

> **For input iterators, a == b does not imply ++a == ++b.** (*Equality does not guarantee the substitution property or referential transparency.*) Algorithms on input iterators should never attempt to pass through the same iterator twice. They should be single pass algorithms. Value type T is not required to be an Assignable type (23.1). These algorithms can be used with istreams as the source of the input data through the istream_iterator class.

[这里](https://stackoverflow.com/questions/5947683/for-input-iterators-why-a-b-does-not-imply-a-b)对该问题进行了细致的讨论。在讨论`input iterators`时，常使用`istream_iterator`作为例子，该迭代器类型从输入流中读取数据，我们可以想到，无论该读取过程是否需要用到`stream buffer`，读取都是发生在迭代器不断向前推进的时候，而输入流某个位置在被读取之后，我们就不能够再次对流中同一个位置的元素进行操作了，也就是说我们**只能用一个迭代器，单向，走一次**：

> `std::istream_iterator` is a single-pass input iterator that reads successive objects of type `T` from the [std::basic_istream](https://en.cppreference.com/w/cpp/io/basic_istream) object for which it was constructed, by calling the appropriate `operator>>`. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object is read when the iterator is constructed. Dereferencing only returns a copy of the most recently read object.
>
> The default-constructed `std::istream_iterator` is known as the *end-of-stream* iterator. When a valid `std::istream_iterator` reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.

所以在标准文档给出的说明中，`++a==++b`为什么此时不能够保证成立呢？这里首先我们要明确以下`++`操作符的作用机理：

##### Increment/decrement operators

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101700052.png" alt="image-20211110170018954" style="zoom:50%;" />

根据[官方文档](https://en.cppreference.com/w/cpp/language/operator_incdec)中的解释，**前置**递增操作符的运算过程与`x += 1`完全相同，在对元素递增之后，**返回一个该元素的引用**；而**后置**递增操作符则是先保存一下元素副本，对该元素本身（引用）进行递增之后，**把副本（保存着原值）返回**。

在清楚了`++`操作符的作用机理后，我们把目光转回到`iterator`上。在表达式`++a==++b`上，如果我们已经进行了`++a`的操作，那么根据`istream_iterator`的特性，已经对流内的数据进行了读取，那么此时`iterator b`就找不到流内原位上的数据了，换而言之，`iterator b`**失效了**！

> 如果我们读取的是字符，那么需要用到`stream buffer`，此时使用[std::istreambuf_iterator](https://en.cppreference.com/w/cpp/iterator/istreambuf_iterator)是效率更高的选择，因为他不需要对每一个字符建立一个`sentry object`，程序在开始时先建立一个`sentry object`，之后把所有数据放入缓冲区，再使用迭代器进行读取.

所以，在`count`以及`find`函数中，我们确实只需要走一次就可以获得我们想要的结果，于是只需要使用一个`input iterator`即可。对应着`output iterator`的`ostream_iterator`也是一样的道理。

#### Write our own iterator?

在C++17之前的版本中，如果我们想给自己的类写一个`iterator`，那么一般的方法是继承`std::iterator`的类模板，并在类模板中指定所谓的`iterator_category`：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101732699.png" alt="image-20211110173203619" style="zoom:50%;" />

迭代器标签关联着之前所述的迭代器实体。但是自**C++17**起，`std::iterator`的类模板遭到舍弃，[详情参见](https://stackoverflow.com/questions/37031805/preparation-for-stditerator-being-deprecated)。所以现在，我们只能手写迭代器，具体可以看[这里](https://segmentfault.com/a/1190000040879971)。

## Template–Generic Programming

### function template

函数模板的基本形式是：

```c++
template<typename T>
T getInteger(const string& prompt, const string& reprompt) {
    while (true) {
        cout << prompt; 
        string line; 
        T result; 
        char extra; 
        if (!getline(cin, line))
            throw domain_error(“[shortened]”);
        istringstream iss(line);
        if (iss >> result && !(iss >> extra)) 
            return result; 
        cout << reprompt << endl; 
    }
}
```

#### instantiation（explicit/implicit）

在调用模板函数时，我们可以显式指定对应的模板参数类型（`explicit instantiation`）,也可以不显式指定模板参数类型（`implicit instantiation`），让模板函数进行**类型推断（`Template Argument Deduction`）**，需要注意的是，如果我们省略`<>`符号，那么`overload resolution`会查找所有的模板类型重载与非模板类型重载，而不是仅仅查找模板类型重载。

> 什么是`overload resolution`?后边有提到.

#### implicit inference

在模板函数中，我们可能会隐含着一些使用参数的限定条件，比如对于下图所示的函数：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111131433705.png" alt="image-20211113143322516" style="zoom:50%;" />

其实隐含着这样一些限定参数使用条件：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111131434734.png" alt="image-20211113143458651" style="zoom:50%;" />

这些限定条件意味着如果我们在调用函数时给出了不恰当的参数，那么该模板函数会报出一些非常凌乱的错误…

在**C++20**中给出了新的关键字`concepts`与`requires`，也就是在之前我们提到过用于重写`iterator`的两个关键字，他们可以帮助我们在编译阶段就检查出参数错误，将报错的位置从函数主体转移到这两个关键字的位置上：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111131442975.png" alt="image-20211113144241875" style="zoom:50%;" />

既然`concepts`关键字可以方便解决模板编译与运行过程中的报错问题的，那么接下来就针对模板的编译过程进行分析。

### Compile a template function call

接下来所述的概念来自于官方文档以及这两篇[1](https://www.cppstories.com/2016/02/notes-on-c-sfinae/#improved-code)[2](https://www.cppstories.com/2018/03/ifconstexpr/#c20)博客. 根据作者原文给出的例子:

```cpp
truct Bar {
    typedef double internalType;  
};

template <typename T> 
typename T::internalType foo(const T& t) { 
    cout << "foo<T>\n"; 
    return 0; 
}

int main() {
    foo(Bar());
    foo(0); // << error!
}
```

当我们向程序中添加了一个新的非模板函数重载`int foo(int i)`时，程序便不会报错，为什么呢？我们需要了解函数整个的编译过程。

#### name lookup

根据[官方文档](https://en.cppreference.com/w/cpp/language/overload_resolution),为了编译一个函数调用，程序首先会进行`name lookup`，这一步是将程序中出现的名字与引入它的**声明**联系起来，比如对于如下语句，程序正是通过`name lookup`的方式来解析这条语句中出现的各个名字：

```c++
std::cout << std::endl;
```

> 在进行`name lookup`时，我们依赖的是`scope`这个概念，也即名称的**声明**所在地，`scope`有很多[种类](https://en.cppreference.com/w/cpp/language/scope)，`namespace`,`function`,`class`,`block`,`enumeration`,`template parameter`都拥有自己的`scope`.

##### unqualified name lookup & qualified name lookup

在上边的例子中，编译器首先会对名称`std`进行`unqualified name`查找，在头文件`<iostream>`中找到它；之后再对`cout, endl`做`qualified name`的查找，即在命名空间`std`中进行的查找过程。

> `qualified name`即在作用域解析符`::`右侧出现的名称，所以他包括：
>
> - class member
> - namespace member
> - enumerator
>
> 同样地，`unqualified name`即没有在作用域解析符`::`右侧出现的名称

需要注意的是，如果作用域解析符`::`左侧没有东西，那么程序会默认在`global namespace scope`或者由`using`引入的命名空间中进行查找：

```c++
#include <iostream>
int main() {
  struct std{};
  std::cout << "fail\n"; // Error: unqualified lookup for 'std' finds the struct
  ::std::cout << "ok\n"; // OK: ::std finds the namespace std
}
```

##### Argument-dependent lookup (ADL)

[这种](https://en.cppreference.com/w/cpp/language/adl)名称查找方式也属于一种`unqualified name lookup`，叫`Koenig lookup`，用于查找`function-call expressions`中的`unqualified function names`（包括运算符重载时对函数的隐式调用），这种查找方式的存在使得在进行函数调用时，程序不仅仅会查找一般的`unqualified name lookup`的`scope`和命名空间，还会查找**函数参数们所在的命名空间**：

该示例来自于官方文档：

```c++
#include <iostream>
int main()
{
    std::cout << "Test\n"; // There is no operator<< in global namespace, but ADL
                           // examines std namespace because the left argument is in
                           // std and finds std::operator<<(std::ostream&, const char*)
    operator<<(std::cout, "Test\n"); // same, using function call notation
 
    // however,
    std::cout << endl; // Error: 'endl' is not declared in this namespace.
                       // This is not a function call to endl(), so ADL does not apply
 
    endl(std::cout); // OK: this is a function call: ADL examines std namespace
                     // because the argument of endl is in std, and finds std::endl
 
    (endl)(std::cout); // Error: 'endl' is not declared in this namespace.
                       // The sub-expression (endl) is not a function call expression
}
```

#### Template Argument Deduction

在进行完`name lookup`这一步之后，程序会进行`Template Argument Deduction`：

> In order to instantiate a [function template](https://en.cppreference.com/w/cpp/language/function_template), every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some [other contexts](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts).

这一机制以及上一节提到的`ADL`，让我们使用`template operator`成为可能，因为在使用`template operator`时，我们无法显式指定所用的模板参数的类型：

```c++
#include <iostream>
 
int main() 
{
    std::cout << "Hello, world" << std::endl;
    // operator<< is looked up via ADL as std::operator<<,
    // then deduced to operator<<<char, std::char_traits<char>> both times
    // std::endl is deduced to &std::endl<char, std::char_traits<char>>
}
```

#### Template Argument Substitution

现在，我们已经获取到了所使用的模板参数类型，在这一步我们要将所有出现在原本的模板中的参数`T`替换为我们推断出的参数类型。

> When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.

需要注意的是如果在替换过程中，出现了错误，比如在先前给出的例子中，我们获得了一个`int::interalType`的类型，那么此时，我们需要把这一参数类型（一个替换方案）剔除出`overload set`，这一[操作](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error)被称为**SFINAE–*Substitution failure is not an error***.

#### overload resolution

在做完`Template Argument Substitution`这一步后，如果`overload set`中已然没有可用的函数，那么编译失败，但存在这样一种情况：即目前有多个`candicate function`可供选用，那么此时`overload resolution`便会派上用场。

> In order to compile a function call, the compiler must first perform [name lookup](https://en.cppreference.com/w/cpp/language/lookup), which, for functions, may involve [argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl), and for function templates may be followed by [template argument deduction](https://en.cppreference.com/w/cpp/language/template_argument_deduction). If these steps produce more than one *candidate function*, then *overload resolution* is performed to select the function that will actually be called.

> 这是一种针对于`function call`的通用概念，并非只针对`template`.

当我们试图在模板函数中应用`overload resolution`以选择最佳匹配重载函数时，会使用`partial ordering of overloaded function templates`的[方法](https://en.cppreference.com/w/cpp/language/function_template)来选择最佳匹配。什么是最佳匹配重载函数？

> Informally "A is more specialized than B" means "A accepts fewer types than B".

*StackOverflow*上有一篇很详细的[文章](https://stackoverflow.com/questions/17005985/what-is-the-partial-ordering-procedure-in-template-deduction)描述这一机理。

#### SFINAE

在上一节的`template argument substituion`中，我们提到了`SFINAE`的内部作用机理，那么我们要如何写出这样的代码或者说这一机理有什么用处呢？

##### Why we need SFINAE?

在这篇[文章](https://www.cppstories.com/2018/03/ifconstexpr/#c20)里，其实解释的很清楚。这里是我的一个总结。简而言之，对于我们自己的函数模板代码，如果其中存在`if-else`分支，那么程序很有可能会在编译阶段报错，因为他会编译`if-else`两个分支，之后程序发现自己无法`reject the invalid code (for this case)`，而我们要做的，就是让程序在编译阶段把在当前情况下不正确的分支给剔除，从`overload set`中将其去掉，只编译符合要求的部分，这也对应着`SFINAE`的定义。

##### How to leverage SFINAE?

为了解决这个问题，**C++11/14/17/20**提出了多种方案：

###### [Tag Dispatching](https://www.cppstories.com/2016/02/notes-on-c-sfinae/#improved-code)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132349840.png" alt="image-20211113234948754" style="zoom:50%;" />

###### enable_if

> **std::enable_if** can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter.

[这一语法](https://en.cppreference.com/w/cpp/types/enable_if)自**C++11**提出，但当时的写法是`enable_if`，在**C++14/17**中，提出了`enable_if_t`.

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132147605.png" alt="image-20211113214738450" style="zoom:50%;" />

也就是说，当`B==true`时，`enable_if`具备一个`typedef type`，即`T`，否则没有该成员，于是当我们写成如下代码：

```cpp
template <class T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type
```

或者参看文档中的`alias`–`enable_if_t`的定义时，如果其不具备成员`type`但是我们却使用了`::type`，那么编译就会出错，并使用`SFINAE`机制处理。在**C++14**及以后的版本中，上述代码可被简化为：

```c++
template <class T>
typename std::enable_if_t<std::is_arithmetic_v<T>, T> 
```

`enable_if`常与`type traits`一起使用：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132152195.png" alt="image-20211113215251103" style="zoom:50%;" />

`type traits`在**编译阶段**用以确定模板特征和属性。在**C++14**中也提出了类似于`is_arithmetic_v`的形式（原本的`value`当`T`为`arithmetic type`是返回`true`，反之`false`）

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132155450.png" alt="image-20211113215505370" style="zoom:50%;" />

借助于`enable_if_t`，我们可以将本节最初的代码更改为：

```cPP
template <typename T>
enable_if_t<is_convertible_v<T, string>, string> strOld(T t) {
    return t;
}

template <typename T>
enable_if_t<!is_convertible_v<T, string>, string> strOld(T t) {
    return to_string(t);
}
```

> 关于`enable_if`的缺点，*StackOverflow*上的一篇[文章](https://stackoverflow.com/questions/14600201/why-should-i-avoid-stdenable-if-in-function-signatures)进行了探讨。

###### Notes

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132229957.png" alt="image-20211113222941812" style="zoom:50%;" />

> 需要注意的是，这里提到的是`only differ in default template arguments`，如果两个模板的`default template argument`一样但是`template parameters`不一样，那么不会发生编译错误.

###### if constexpr

在**C++17**中，我们可以将`if conxtexpr statement`使用在模板中，起到与`enable_if_t`相同的作用：

```c++
template <typename T>
auto get_value(T t) {
    if constexpr (std::is_pointer_v<T>)
        return *t; // deduces return type to int for T = int*
    else
        return t;  // deduces return type to int for T = int
}
```

###### concepts-requires

终于，我们来到了`concepts`。

```cpp
// concept:
template<typename T>
concept Hashable = requires(T a) {
    { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;
};
```

在这里，我们定义一个`concept`，将一个`requires-expression`赋值给它。`requires`关键字有很多种写法：

- requires clauses

```c++
template<typename T>
void f(T&&) requires Eq<T>; // can appear as the last element of a function declarator
 
template<typename T> requires Addable<T> // or right after a template parameter list
T add(T a, T b) { return a + b; }
```

- requires expressions

```c++
template<typename T>
concept Addable = requires (T x) { x + x; }; // requires-expression
```

- simple requirements

```c++
template<typename T>
concept Addable =
requires (T a, T b) {
    a + b; // "the expression a+b is a valid expression that will compile"
};
```

> 因为所有以关键字`requires`开头的`requirements`都会被解释成`nested requirement`，所以`simple requirements`不会以`requires`开头

- Type requirements

```c++
template<typename T> using Ref = T&;
template<typename T> concept C =
requires {
    typename T::inner; // required nested member name
    typename S<T>;     // required class template specialization
    typename Ref<T>;   // required alias template substitution
};
```

- Compound requirements

- Nested requirements

###### Abbreviated function template

自**C++20**始，提出了`Abbreviated function template`的做法，即使用`placeholder types(auto, concept auto)`出现在函数声明或者函数模板声明中：

```c++
void f1(auto); // same as template<class T> void f(T)
void f2(C1 auto); // same as template<C1 T> void f2(T), if C1 is a concept
void f3(C2 auto...); // same as template<C2... Ts> void f3(Ts...), if C2 is a concept
void f4(const C3 auto*, C4 auto&); // same as template<C3 T, C4 U> void f4(const T*, U&);
template <class T, C U>
void g(T x, U y, C auto z); // same as template<class T, C U, C W> void g(T x, U y, W z);
```

于是对于原博客中给出的例子：

```cpp
// requires:
template <typename T>
requires std::is_floating_point_v<T>
constexpr bool close_enough20(T a, T b) {
   return absolute(a - b) < precision_threshold<T>;
}
constexpr bool close_enough20(auto a, auto b) {
   return a == b;
}
```

根据[官方文档](https://en.cppreference.com/w/cpp/language/function_template#Abbreviated_function_template)，我们利用`constrained auto`将其改写为：



```cpp
constexpr bool close_enough20(std::floating_point auto a,
                              std::floating_point auto b) {
   return absolute(a - b) < precision_threshold<std::common_type_t<decltype(a), decltype(b)>>;
}
constexpr bool close_enough20(std::integral auto a, std::integral auto b) {
   return a == b;
}
```

这里有一篇[文章](https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/)作了较为详细的介绍。

### Lambda Expressions

[1](https://www.cppstories.com/2020/08/lambda-generic.html/)话题的引入来自于该函数中的`predicate`，我们尝试着将它写做一个非固定最大值的版本，即将下边的5替换为一个`limit`变量：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111140037577.png" alt="image-20211114003742461" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111140038721.png" alt="image-20211114003814642" style="zoom:50%;" />

> call it by using function pointers

#### Pre-C++11(Functors)

在**C++11**之前，我们使用如下方法：

```c++
// by value
class GreaterThan {
public:
    GreaterThan(int limit) : limit(limit) {}
    // note: this should have a const
    bool operator() (int val) const {return val >= limit};
private:
    int limit; /* the value we captured outside*/
}

// by reference
class GreaterThan {
public:
    GreaterThan(int &limit) : limit(limit) {}/* pass by reference */
    // note: this should have a const
    bool operator() (int val) const {return val >= limit};
private:
    int& limit; /* the value we captured outside, by reference*/
}
```

在**C++11**中引入了`lambda expression`:

```cpp
auto func = [capture-clause](parameters) -> return-value {
// body
};

// the simplest lambda:
[]{};
```

> - `return-value` is optional
> - can use `=` to capture all by value (**not** recommend)
> - can use `&` to capture all by reference (**not** recommend)

#### C++14

1. can use `auto` as the parameters to templatize the lambda–**generic lambda**

2. can capture with an initialiser–`z = x + y`

#### C++17

1. use `constexpr` :

```cpp
constexpr auto Square = [](int n) { return n * n; };
```

2. can capture `*this`

#### C++20

We can pass a template tail:

```cpp
auto ForwardToTestFunc = []<typename ...T>(T&& ...args) {
  return TestFunc(std::forward<T>(args)...);
};
```

#### mutable

让我们把注意力移回到**C++11**之前的版本，严格来说，成员函数`operator()`的重载应当设置一个**指向常量对象的常量指针**，即写为：

```cpp
void operator()(...) const {
    // since there is a const,
    // if captured by reference, we can change the values captured
    // if captured by value, we cannot change it.
}
```

所以关键字`mutable`允许我们改变捕获的值。

#### globals & statics

`lambda`表达式仅允许捕捉具有`automatic storage duration`的变量，所以我们不能够捕捉`global/static variables`:

##### storage duration

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111142007243.png" alt="image-20211114200707114" style="zoom:50%;" />

### std::bind

除了`lambda expression`之外，我们还可以使用头文件`<functional>`中的`bind`方法来写先前我们所需要的`predicate`函数,根据[官方文档](https://en.cppreference.com/w/cpp/utility/functional/bind)给出的示例，我们可以结合占位符`std::placeholders`来使用该函数：

```cpp
using namespace std::placeholders;  // for _1, _2, _3...

std::cout << "1) argument reordering and pass-by-reference: ";
int n = 7;
// (_1 and _2 are from std::placeholders, and represent future
// arguments that will be passed to f1)
auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
n = 10;
f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused
                // makes a call to f(2, 42, 1, n, 7)
```

在该段示例代码中，`std::cref(n)`的作用是为`n`创建一个`reference_wrapper`的对象，与之有相同作用的还有函数`std::ref(n)`：

>`std::reference_wrapper` is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like [std::vector](https://en.cppreference.com/w/cpp/container/vector "cpp/container/vector")) which cannot normally hold references.

比如，我们可以使用如下语法：

```c++
std::vector<std::reference_wrapper<int>> v(l.begin(), l.end());
```

如此一来，`v`内所有元素均是`vector l`内元素的引用。

`bind()`函数会给原函数创建一个`call wrapper`，调用`wrapper`函数相当于`invoke f with some of its arguments bound to args`.值得注意的是，`bind`函数声明也是通过**可变函数参数**实现的。

### Variadic template

#### Variadic arguments

[1](https://eli.thegreenplace.net/2014/variadic-templates-in-c/)在**C++11**之前，如果我们想让一个函数接受任意参数，那么我们需要使用`...`的语法配合`va_`系列的宏来使用，[文档](https://en.cppreference.com/w/cpp/utility/variadic)给出了一个例子：

```cpp
#include <iostream>
#include <cstdarg>
 
void simple_printf(const char* fmt...) // C-style "const char* fmt, ..." is also valid
{
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int i = va_arg(args, int);
            std::cout << i << '\n';
        } else if (*fmt == 'c') {
            // note automatic conversion to integral type
            int c = va_arg(args, int);
            std::cout << static_cast<char>(c) << '\n';
        } else if (*fmt == 'f') {
            double d = va_arg(args, double);
            std::cout << d << '\n';
        }
        ++fmt;
    }
 
    va_end(args);
}
 
int main()
{
    simple_printf("dcff", 3, 'a', 1.999, 42.5); 
}
```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111141728044.png" alt="image-20211114172837870" style="zoom:50%;" />

我们首先建立一个`va_list`的对象用于储存余下几个宏需要的信息，之后调用`va_start`，允许程序访问后随具名参数`parm_n`的可变参数：

```cpp
void va_start( std::va_list ap, parm_n );
```

之后每当我们调用一次`va_arg`，就可以获取`va_list`内的下一个参数；最终调用`va_end`终止这一过程。

需要注意的是，在使用`variadic arguments`时，`...`必须跟随在参数列表之后，而不允许被放到参数列表的前边。但是在**C++**中，这样的使用方式是被允许的：

```cpp
int printz(...)
```

这种使用方式在模板重载中被作为`SFINAE`的`fallback overload`使用，因为`...`最不`specialized`，所以在`overload resolution`中具有最低的优先级。

> fallback is a function that does not take any arguments and does not return anything.

#### Parameter pack

在上一节中提到的`variadic argument`与`parameter pack`不一样：

> Note: this is different from a function [parameter pack](https://en.cppreference.com/w/cpp/language/parameter_pack) expansion, which is indicated by an ellipsis that is a part of a parameter declarator, rather than an ellipsis that appears after all parameter declarations. Both parameter pack expansion and the "variadic" ellipsis may appear in the declaration of a function template, as in the case of [std::is_function](https://en.cppreference.com/w/cpp/types/is_function).

`parameter pack`是构成`variadic template`的基础：

> A template with at least one parameter pack is called a *variadic template*.

共有两种参数包：**模板参数包**与**函数参数包**：

```cpp
template <typename T, typename... Args> // a template parameter packet
void foo(const T &t, const Args&... rest); // a function parameter packet
```

我们如何理解上边的语句？可以举例来想，**模板参数包**中将各种不同的可能出现的类型（`int, double, char* ...`）打包，之后把这个包交给函数，函数对包`Args`做**包扩展（`packet expansion`）**，传入的**每一种类型**都可能存在多个元素，比如`double a, double b...`，于是对每一种类型（即模板参数包中的每一个对应元素）打包、组合成一个名为`rest`的**函数参数包**。

> 需要注意的是，对于`class template`，参数包只能出现在最后一个参数的位置上。但是对于`function template`，参数包可以出现在任意位置上。

#### Packet expansion

在上一节中，提到了包扩展：*pattern…*，**扩展一个包就是将他分解为构成的元素，并对每个元素应用模式`pattern`**:

```cpp
template<class ...Us> void f(Us... pargs) {}
template<class ...Ts> void g(Ts... args) {
    f(&args...); // “&args...” is a pack expansion
                 // “&args” is its pattern
}
g(1, 0.2, "a"); // Ts... args expand to int E1, double E2, const char* E3
                // &args... expands to &E1, &E2, &E3
                // Us... pargs expand to int* E1, double* E2, const char** E3
```

包扩展可以出现在函数调用符`()`内部，根据[官方文档](https://en.cppreference.com/w/cpp/language/parameter_pack#Pack_expansion)：

```cpp
f(&args...); // expands to f(&E1, &E2, &E3)
f(n, ++args...); // expands to f(n, ++E1, ++E2, ++E3);
f(++args..., n); // expands to f(++E1, ++E2, ++E3, n);
f(const_cast<const Args*>(&args)...);
// f(const_cast<const E1*>(&X1), const_cast<const E2*>(&X2), const_cast<const E3*>(&X3))
f(h(args...) + args...); // expands to 
// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)
```

一个包扩展的例子可参见*C++ Primer* P621，需要注意的是，在例中进行函数调用时的包扩展，先将包中第一个参数剥离（`peel off`），对应了`const T &t`,余下的元素构成了新的参数包，并递归调用，直到我们遇到了`base case`，并使用对应了非可变参数函数模板：

```c++
// base case function
template<typename T>
ostream &print(ostream &os, const T &t) {
    return os << t;
}

template<typename T, typename... Args>
// the first packet expansion, using pattern `const Args&`
ostream& print(ostream &os, const T &t, const Args&... rest) {
    os << t << ", ";
    // the second packet expansion, using pattern `rest`
    // then peel off the first element in the expansion list to be `const T &t`
    // recursion with the list with other elements
    return print(os, rest...);
}
```

#### `sizeof...`

我们可以通过使用`sizeof...`得到包中参数的数目。

#### Performance

摘自：https://eli.thegreenplace.net/2014/variadic-templates-in-c/

> If you're concerned with the performance of code that relies on variadic templates, worry not. As there's no actual recursion involved, all we have is a sequence of function calls pre-generated at compile-time. This sequence is, in practice, fairly short (variadic calls with more than 5-6 arguments are rare). Since modern compilers are aggressively inlining code, it's likely to end up being compiled to machine code that has absolutely no function calls. What you end up with, actually, is not unlike loop unrolling.
>
> Compared to the C-style variadic functions, this is a marked win, because C-style variadic arguments have to be resolved at runtime. The `va_` macros are literally manipulating the runtime stack. Therefore, variadic templates are often a performance optimization for variadic functions.

### range

在**C++20**中，提出了`range`的概念，写了一个`range`库，其中包含`range`, `view`, `range adaptor`等……但这里不打算深究，具体详见官方文档以及[这篇文章](https://www.zhihu.com/column/p/86809598)。

### Object-Oriented Programming

#### Const

几种不同的`const`含义：

```c++
// 指向整型常量的指针(可修改指针本身，不可修改指针指向的对象)
const int* a;
// or:
int const* a;

// 指向整形的常量指针(不可修改指针本身，可修改指针指向的对象)
int* const a;

// 根据《C++ Primer》，this指针默认为指向非常量对象的常量指针，
// 此操作将this指针设定为指向常量对象的常量指针
void func() const
```

##### Why initialization-list?

加入我们将对象定义为`const`类型，那么在声明之后，对象就不可以再改变了，这意味着一般的构造函数初始化方法会出现问题（先建立对象，再挨个初始化其元素）。而`initialization list`在建立对象的同时立即初始化其所有元素：

```c++
test(int num1, double str1): num(num1), str(str) {};
```

#### friend

**相同class的各个objects互为友元**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111181413064.png" alt="img" style="zoom:50%;" />

#### Operators

基本的用例略过，这里记录课件中几点关键的原则：

##### General rule of thumb

1. Some operators must be implemented as members (
   eg. [], (), ->, =) due to C++ semantics.

> 因为成员函数隐藏的第一个参数一定是`this`，即对象的地址，而使用这些操作符时我们无法在别处提供对象地址.

2. Some must be implemented as non-members (eg. <<,
   if you are writing class for rhs, not lhs).

> 因为第一个参数要是`ostream& os`，所以必不可能为成员函数.

3. If unary operator (eg. ++), implement as member.

4. If binary operator and treats both operands equally (eg.
   both unchanged) implement as non-member (maybe
   friend). Examples: +, <.

> **根据官方文档：**
>
> Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if `operator+` is a member function of the complex type, then only `complex+integer` would compile, and not `integer+complex`). 

何为`symmetric`?

> 根据**Wikipedia**：
>
> A corresponding property exists for binary relations; a binary relation is said to be **symmetric** if the relation applies **regardless of the order of its operands**.

因为定义为非成员函数，所以需要友元，以下是最习惯的一种重载二元运算符的方式：

```cpp
// friends defined inside class body are inline and are hidden from non-ADL lookup
  friend X operator+(X lhs,        // passing lhs by value helps optimize chained a+b+c
                     const X& rhs) // otherwise, both parameters may be const references
  {
    lhs += rhs; // reuse compound assignment
    return lhs; // return the result by value (uses move constructor)
  }
```

5. If binary operator and not both equally (changes lhs),
   implement as member (allows easy access to lhs private
   members). Examples: +=

```cpp
  X& operator+=(const X& rhs) // compound assignment (does not need to be a member,
  {                           // but often is, to modify the private members)
    /* addition of rhs to *this takes place here */
    return *this; // return the result by reference
  }
```

##### []

一般来说，我们需要重载`operator []`的两种形式（`const`与非`const`），这是为了解决当我们定义的对象本身即为`const`类型时可能出现的问题：

由于`this`指针默认是一个指向非常量对象的常量指针，如果对象被声明为`const`，则指`this`为指向常量对象的常量指针，只有在我们将成员函数后加上`const`，才可以使得参数中实参类型为`const test*`，否则势必**丢失底层`const`**。（这也是为什么`const`成员函数内只允许调用`const`成员函数的原因）。同时需要注意，该函数可以返回引用，引用前也应当有`const`，确保不能改变对象：

```cpp
const string& vector<string>::operator[](size_t index) const {
    // do something
}
```

##### Principle of Least Astonishment (POLA)

这里只提几点：当我们实现了`+`的重载时，我们最好也要实现类似于`+=`的重载，类推:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111172313712.png" alt="image-20211117231351569" style="zoom:50%;" />

同时，我们也要注意能够链式使用重载运算符的计算结果（靠运算符重载函数返回对象或者对象的引用来实现）:

```cpp
ostream& operator<<(ostream& out, const Fraction& f) {
    out << f.num << “/”<< f.denom;
    return os;
}
```

##### Converting constructor & Conversion operator

###### Converting constructor

> 如果构造函数**可以只接受一个实参**（包括对其余所有形参提供了默认值的情况），则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为**转换构造函数**。

> *C++ Primer*P264:
>
> 编译器只会自动执行一步隐式转换，也就是说如果我们接受一个`string`类型的参数，那么我们不能直接把`char*`放进去，否则自动转换为`string`后，不会继续隐式转换了.(但我们可以做显式转换)

我们可以通过关键字`explicit`来抑制构造函数定义的隐式转换。需要多个实参的构造函数不能用于执行隐式转换，所以无需将其定义为`explicit`的。同时，只能在类内声明构造函数时使用`explicit`关键字，在类外部定义时不应重复。

> 注意，当拷贝构造函数被声明为`explicit`时，表明拷贝构造函数不能被隐式调用，所以，如果我们尝试使用`=`进行拷贝初始化（**隐式调用了拷贝构造函数**），也是不被允许的。

`explicit`可以避免我们写出二义性的代码。

###### Conversion operator

`explicit`关键字除了可以用在构造函数之前外，还可以用在类型转换运算符前：

```c++
explicit operator double() const {
    // do something
}
```

> 该规定存在一个例外，**如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它**。`operator bool`一般定义成`explicit`的.

#### Special member functions

这些函数会由编译器自动生成一份：

- Default construction
- Copy construction
- Copy assignment
- Destruction

##### Most vexing parse

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111180150966.png" alt="image-20211118015039848" style="zoom:50%;" />

根据*Wikipedia*的解释：

> The **most vexing parse** is a counterintuitive form of syntactic [ambiguity resolution](https://en.wikipedia.org/wiki/Ambiguous_grammar) in the [C++](https://en.wikipedia.org/wiki/C%2B%2B) programming language. In certain situations, the C++ grammar cannot distinguish between the [creation](https://en.wikipedia.org/wiki/Initialization_(programming)) of an object [parameter](https://en.wikipedia.org/wiki/Parameter_(computer_programming)) and [specification of a function's type](https://en.wikipedia.org/wiki/Type_declaration). In those situations, the compiler is required to interpret the line as a function type specification.

也就是说，在这种情况下，他被当作一个函数来处理了。**所以不要这么写！**

##### shallow copy & deep copy

编译器在默认情况下生成的`copy assignment`就是一种`shallow copy`，而我们需要的往往是`deep copy`，`shallow copy`带来的问题很明显，它并没有完全复制所有的数据，而是用指针指向了源数据存放的位置：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111180155717.png" alt="image-20211118015546603" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111180156728.png" alt="image-20211118015632623" style="zoom:50%;" />

##### Copy constructor

```cpp
StringVector::StringVector(const StringVector& other) :
        _logicalSize(other._logicalSize),
        _allocatedSize(other._allocatedSize) {
            
    _elems = new ValueType[_allocatedSize];
    std::copy(other.begin(), other.end(), begin());
}
```

##### Copy assignment

需要注意的是，在`copy assignment`中，我们要考虑到`copy`的对象与源对象是同一个的情况（`self-assignment`）:

```c++
StringVector& StringVector::operator=(const StringVector& rhs) {
    if (this != &rhs) {
        delete [] _elems;
        _logicalSize = rhs._logicalSize;
        _allocatedSize = rhs._allocatedSize;
        _elems = new ValueType[_allocatedSize];
        std::copy(other.begin(), other.end(), begin());
    }
    return *this;
}
```

> 不可以用`*this != rhs`，因为这需要我们重载`!=`操作符.

##### =delete & =default

如果我们的类不需要拷贝/移动操作，我们需要在`public`域中使用`=delete`将其禁用（但`=delete`关键字并非只适用于这几种函数，该关键字意为“弃用”）：

```c++
test(const test&) =delete;
test& operator=(const test&) =delete;
```

如果我们需要默认的行为，可以要求编译器提供生成默认构造函数（一般此时我们还需要其它类型的构造函数），这就可以避免`Most vexing parse`的发生：

```c++
test() = default;
```

##### Write our own?

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111180206534.png" alt="image-20211118020633426" style="zoom:50%;" />

需要注意的是，`stream`对象均不可被复制，因为这样的操作没有意义，而在实现中，他们的复制构造函数也都被声明为`private`。

##### Rule Of Three

> If you explicitly define (or delete) a copy constructor, copy assignment, or destructor, you should define (or delete) all three.

因为当定义了这三种函数的任意一种时，就表明会出现`ownership issues`.

##### Rules of Zero

> If the default operations work, then don’t define your own custom ones.

#### Move semantics

##### emplace_back

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111182220012.png" alt="image-20211118222054939" style="zoom:50%;" />

该函数的参数声明是用了可变参数模板，并对参数包`Args`进行了`pattern=Args&&`的`pack expansion`操作。与`push_back`方法所不同的是，该方法借助**右值引用**，也就是我们接下来要谈的特性，避免了先创建一份数据，再复制的操作，而是直接给定需要的数据元素参数，加入数据队列中：

```c++
std::vector<President> elections;
std::cout << "emplace_back:\n";
auto& ref = elections.emplace_back("Nelson Mandela", "South Africa", 1994);
assert(ref.year == 1994 && "uses a reference to the created object (C++17)");
 
std::vector<President> reElections;
std::cout << "\npush_back:\n";
reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));
```

##### Without copy elision

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111182246321.png" alt="image-20211118224658231" style="zoom:50%;" />

在上图所示的代码中，需要注意的是，在不进行RVO等优化机制时，`return`这一步会创建一个`temporary object`，这需要我们调用复制构造函数，将变量`names`复制到临时对象中。

##### Basic idea

根据[这篇文章](http://thbecker.net/articles/rvalue_references/section_02.html)，为了提高运行效率，我们尝试使用某种方法避免一些不必要的数据复制过程，比如当给到这样一个函数：

```c++
X& X::operator=(X const & rhs)
{
  // [...]
  // Make a clone of what rhs.m_pResource refers to.
  // Destruct the resource that m_pResource refers to. 
  // Attach the clone to m_pResource.
  // [...]
}
```

我们**希望避免这些复制过程**，如果我们能够直接交换`m_pResource`与`rhs.m_pResource`的内容多好！这种操作（想法）被叫做`move semantics`，于是我们有了一个期望的函数模板：

```c++
X& X::operator=(<mystery type> rhs)
{
  // [...]
  // swap this->m_pResource and rhs.m_pResource
  // [...]  
}
```

因为我们此处想要实现的也是一种`copy assignment overload`，所以传入的也要是一种引用类型，这也是`rvalue reference(&&)`引入的地方，我们期望该类型具备如下的行为特征：

> rvalues must prefer the mystery type, while lvalues must prefer the ordinary reference.

那么这种行为是通过什么途径实现的呢？就是我们先前所提到的`overlaod resolution`：

> Rvalue references allow a function to branch at compile time (via overload resolution) on the condition "Am I being called on an lvalue or an rvalue?"

##### lvalues & rvalues

根据[官方文档](https://en.cppreference.com/w/cpp/language/value_category)，每一个`Expression`都具备两个独立属性：

1. `type`(e.g. int, double, class, …)
2. `value category`

如果按照标准定义，共有三种基本的`value category`: `prvalue`, `xvalue`, `lvalue`。在这里，我们做两个粗略的定义：**左值**与**右值**：

###### lvalue

> An **lvalue** is an expression that has a name/identity. In other words, we can find address using address-of operator(&var)

###### rvalue

> An **rvalue** is an expression that does not have a name/identity.
>
> - temporaray values
> - cannot find address using address-of operator (&var)

从直观上来说，左值可以出现在表达式的左侧或者右侧，但是右值一定只能出现在右侧。



右值引用，利用`rvalue`的结果，但本身为`lvalue`.

###### l/rvalue reference

需要注意的是，我们只能够将**左值引用绑定到左值，右值引用绑定到右值**，

```c++
// rvalue reference
// here, v1 + v2 is a temporary object, which is a rvalue
auto&& v4 = v1 + v2;
```

一种特殊情况是：可以将`const lvalue reference`绑定到`rvalue`上：

```c++
const auto& ptr3 = ptr + 5;
```

原因如下：

> Normally, a temporary object lasts only until the end of the full expression in which it appears. However, **C++ deliberately specifies that binding a temporary object to a reference *to const* on the stack lengthens the lifetime of the temporary to the lifetime of the reference itself**, and thus avoids what would otherwise be a common dangling-reference error. In the example above, the temporary returned by f() lives until the closing curly brace. (**Note this only applies to stack-based references. It doesn’t work for references that are members of objects.**)

简而言之，使用`const reference`可以延长临时对象的生命周期，但这仅限于`local const reference`，在如下语句中，是不会产生实际效应的：

```c++
Sandbox(const string& n): member(n) {};
```

这也很好理解，这里的`const reference`对应的`scope`为构造函数本身，当构造函数栈退出后，该`reference object`也随之消亡了。

###### l/rvalue reference & l/rvalue

对函数声明`test(T&& a)`的形式产生了一点疑问，这里的`a`是一个`lvalue`而不是`rvalue`。为什么？

首先我们要知道，根据先前的介绍，表达式具备两个独立的特性：

- `type`
- `value category`

在该函数参数中，`type`为`rvalue reference`，而我们这里所说的`lvalue`，是指的该表达式的`value category`。那么问题来了，为什么它的`value category`为`lvalue`呢？这是因为**C++**的这条规定：



> Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: *if it has a name*, then it is an lvalue. Otherwise, it is an rvalue.

这里的`T&& a`显然是一个`name variable`，而不是类似于`3`或者`goo()`这种的`unnamed variable`。为什么**C++**要做出这种规定，详见[这篇文章](http://thbecker.net/articles/rvalue_references/section_05.html)。

```c++
void foo(X&& x) {
    X anotherX = x; // calls X(X const & rhs)
}

X&& goo();
X x = goo(); // calls X(X&& rhs) because the thing on the righ side has no name
```

简而言之，如果在代码`X anotherX = x`中的`x`被归类为一个`rvalue`，那么这意味着此式之后，根据`move semantics`的原则，如果`x`是一个`rvalue`，则应该被设置为不再可以访问，它应该是消亡了：

> 1. An object that is an **l-value** is **NOT** disposable, so you can
>    copy from, but definitely **cannot** move from.
> 2. An object that is an **r-value** is disposable, so you **can** either
>    copy or move from.

但是在这里显然我们仍然可以通过`&x`获取关于`x`的信息，所以`move semantics`不应该在这里被应用，`x`本身应该被视为一个`lvalue`。

而当我们试图给函数`foo(X&& x)`传递参数的时候，我们也要保证传入的参数本身是一个右值(这里也是说的参数的`value category`)，因为我们只允许将**右值绑定到右值引用上**.这也是`std::move()`会派上用场的地方。

##### Move Constructor & Move assignment

```c++
StringVector(StringVector&& other);
StringVector& operator=(StringVector&& rhs);
```

在写这两个函数的时候，我们需要注意一点，即之前谈到的函数参数中的`StringVector&& other`的`value category`其实是`lvalue`，这意味着我们可以写出如下的代码：

```c++
Axess& operator=(Axess&& rhs) {
    students = rhs.students;
}
```

我们还是把数据copy了一份…

为了避免这个问题，引入方法`std::move()`。

##### move()

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111191736625.png" alt="image-20211119173654522" style="zoom:50%;" />

首先一个疑惑就是，既然右值引用只能被绑定到右值上，那为什么我们可以将左值`rhs`传入到声明为`move(T&& t)`的参数中呢？这是因为这里的`T&& t`并非`rvalue reference`，而是一种**forwarding references(universal references)**。（下边会介绍）

使用`move`函数可以帮助我们强制执行`move semantics`(`Forcing Move Semantics`)，它将参数转化为一个`rvalue`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111191801959.png" alt="image-20211119180156845" style="zoom:50%;" />

##### Perfect Forwarding

什么是`perfect forwarding`?通俗的讲，就是如果我们通过一个函数将一个参数转发给另一个函数处理，在传递的过程中，参数始终能够保持先前的特征，比如右值始终未为右值，左值始终为左值。

##### Universal References

根据[这篇文章](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)，如果一个类型为`T&&`的变量或者参数，其中`T`为`deduced type`，那么此时该参数或者变量即为`universal reference`. `universal reference`**到底是左值引用还是右值引用完全取决于我们如何初始化它**：

> - If the expression initializing a universal reference is an lvalue, the universal reference becomes an lvalue reference.
> - If the expression initializing the universal reference is an rvalue, the universal reference becomes an rvalue reference.

而根据官方文档，`universal reference`主要应用于这两个地方：

> Forwarding references are a special kind of references that preserve the value category of a function argument, making it possible to *forward* it by means of [std::forward](https://en.cppreference.com/w/cpp/utility/forward). Forwarding references are either:
>
> 1. **function parameter of a function template** declared as rvalue reference to cv-unqualified [type template parameter](https://en.cppreference.com/w/cpp/language/template_parameters#Type_template_parameter) of that same function template.
> 2. **auto&&** except when deduced from a brace-enclosed initializer list:

> **cv-unqualified**:
>
> A type is "cv-unqualified" if it doesn't have any cv-qualifiers. A cv-qualifer is either `const` or `volatile`

其实在`auto&&`的这种情况中，与`function template parameters`的情况基本完全相同，也是在做`type deduction`而已。比如在这个例子当中，`auto&&`就是一个`lvalue reference`:

```c++
std::vector<int> v;
...
auto&& val = v[0];
```

因为`v[0]`本身返回的是一个左值引用，而所有的左值引用（`type`）必定都是左值(`value category`)。

###### Notice! Where type decution takes place?

在*Scott Meyers*的文章中，有这么一个例子：

```c++
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    void push_back(T&& x);       // fully specified parameter type ⇒ no type deduction;
    ...                          // && ≡ rvalue reference
};
```

这就是`vector`的`push_back`方法，在这里`T&&`是一个`rvalue reference`而非`universal reference`，因为类型推断并没有发生在`push_back`函数的声明处，只要`class T`的类型被确定，`push_back`便不再需要`type deduction`了，所以`universal reference`只会出现在`type deduction`的位置上。所以在`emplace_back`的声明里：

```c++
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    template <class... Args>
    void emplace_back(Args&&... args); // deduced parameter types ⇒ type deduction;
    ...                                // && ≡ universal references
};
```

这里的`&&`就是一个`universal reference`了。

##### reference to reference

通常意义上，以下语句是不合法的：

```c++
Widget w1;
Widget& & w2 = w1;
```

但是我们无法在编译过程中避免出现如上所示的情况：

###### reference-collapsing

当我们对`universal reference`类型的模板参数做类型推断时，需要注意的是，`lvalue` `T`(`value category`)会被推断为`T&`（`type`），而`rvalue` `T(`value category`)`则被推断为`T`（`type`）。这意味着，我们一定会遇到`& &&`的类似情况，由于这看起来不太合理，**C++**是用了**引用折叠**（`reference-collapsing`）的方法解决这一问题：

> - An rvalue reference to an rvalue reference becomes (“collapses into”) an rvalue reference.
> - All other references to references (i.e., all combinations involving an lvalue reference) collapse into an lvalue reference.

而当**一个变量的类型本身就是引用时，情况有所不同：变量类型（`type`）的引用部分会被直接忽视**：

```c++
int x;
int&& r1 = 10;                   // r1’s type is int&&
int& r2 = x;                     // r2’s type is int&

f(r1);
f(r2);
```

所以何时会发生引用折叠呢？除了模板实例化（`template instantiation`）以外，当然还包括`auto`，以及`typedef`和`delctype`:

```c++
// typedef:
template<typename T>
class Widget {
    typedef T& LvalueRefType;
};
// use
Widget<int&> w;
```



##### Rule Of Five

> If you explicitly define (or delete) a copy constructor, copy assignment, move constructor, move assignment, or destructor, you should define (or delete) all five. 
>
> The fact that you defined one of these means one of your members has ownership issues that need to be resolved.

#### Copy elision & return value optimization(RVO)





