---
layout:		post
title:		CS基础课程4
subtitle:	Stanford CS 106L
date:		2021-11-07
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C++
    - CS基础课程笔记
---

我将2019秋季Stanford的CS 106L作业发布在我的[Github仓库](https://github.com/SongShaopu1998/Stanford-CS-106L).

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091826467.png" alt="image-20211109182644300" style="zoom:50%;" />

## stream

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091455815.png" alt="image-20211109145516729" style="zoom:50%;" />

### stringstream

以下内容来自官方文档：

> Stream class to operate on strings.
>
> Objects of this class use a *[string buffer](https://www.cplusplus.com/stringbuf)* that contains a sequence of characters. This sequence of characters can be accessed directly as a [string](https://www.cplusplus.com/string) object, using member [str](https://www.cplusplus.com/stringstream::str).
>
> Characters can be inserted and/or extracted from the stream using any operation allowed on both *[input](https://www.cplusplus.com/istream)* and *[output](https://www.cplusplus.com/ostream)* streams.
>
> **stream buffer**: "A stream buffer is an object in charge of performing the reading and writing operations of the *stream* object it is associated with: the stream delegates all such operations to its associated *stream buffer* object, which is **an intermediary between the *stream* and its *controlled input and output sequences***."
>
> <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100150967.png" alt="image-20211110015005910" style="zoom:50%;" />
>
> <img src="https://upload.cppreference.com/mwiki/images/7/75/std-streambuf.svg" alt="std-streambuf.svg"  />

> **All *stream* objects, no matter whether buffered or unbuffered, have an associated *stream buffer***: Some *stream buffer* types may then be set to either use an intermediate *buffer* or not.

`stringstream`类继承自几个`ios`基础类：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081327496.png" alt="image-20211108132713194" style="zoom:50%;" />

`stringbuf`继承自`streambuf`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111090021218.png" alt="image-20211109002123175" style="zoom:50%;" />

#### read & write

该类在实际使用中，常常用于分割字符（按空格）。它将`string`存放到一个`string buffer`（继承自`streambuf`）中：

> Internally, its [iostream](https://www.cplusplus.com/iostream::iostream) base constructor is passed a pointer to a [stringbuf](https://www.cplusplus.com/stringbuf) object constructed with str and which as arguments.

我们可以通过参数`stringstream::ate`指定指针位置在末端；如果我们使用的是`istringstream`，那么可以使用`stringstream::bin`的方式以二进制读取。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081336407.png" alt="image-20211108133647355" style="zoom:33%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081337944.png" alt="image-20211108133704904" style="zoom:33%;" />

每当我们使用`stringstream object`向该`string buffer`中读入数据时，指针会不断向后做相应移动，就像这样：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081338230.png" alt="image-20211108133834185" style="zoom:33%;" />

我们还可以使用`.str()`方法将存放于`string buffer`中的内容读取成字符串。

#### about ">>"

我们可以指定类型，之后使用`>>`操作符将内容读入指定类型的变量中。在C++官方[文档页面](https://www.cplusplus.com/reference/istream/istream/operator%3E%3E/)上，对这一操作进行了详细的描述，该运算符被多次重载用以接受以下三种参数：

- `arithmetic types`
- `stream buffers`
- `manipulators`

具体的操作可以参见上边的链接，总之就是要借助于继承自`istream`的`sentry`类来辅助处理输入流（接受一个`stream object parameter`），**它首先会检测当前`internal error flags`的状态，如果为`good`，则继续进行，否则不会对流做任何操作，这一点需要注意。**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100144760.png" alt="image-20211110014417695" style="zoom:50%;" />

在运算过程中，程序通过设定`ios_base::iostate`的值来告诉目前`stream`的情况--还提供了相应的函数帮助我们进行判断，这几个常量被称为`internal error state flags`，具体见下表:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081426342.png" alt="image-20211108142645284" style="zoom:50%;" />

我们可以通过调用方法`ios::rdstate() const`来获取当前`internal error state flags`的值，或者使用`basic_ios::setstate()`来修改当前标志位的值。需要注意的是，已经设置了的`bitflag`是不会自动清除的(`sticky!`)，需要通过调用`basic_ios::clear(iostate state = goodbit)`来替换当前状态。

> 需要注意的是，`End-Of-File`并不是什么存在于文件末尾的字符，`EOF`是定义于标准库内的一个宏(`macro`):
>
> ```c++
> #define EOF (-1)
> ```
>
> 当文件或者字符串被读取到末尾时，**读取函数会返回`-1`**，所以我们也说`eof reached`.当文件（字符串）末尾到达后，程序设置`eofbit`，但是需要注意此时`failbit`与`badbit`也可能同时被设置.
>
> > "Reaching the *End-of-File* sets the eofbit. But note that operations that reach the *End-of-File* may also set the failbit if this makes them fail (thus setting both eofbit and failbit)."

那么问题来了，`>>`会在什么时候设置这几个`bitflag`呢？官方[文档](https://www.cplusplus.com/reference/istream/istream/operator%3E%3E/)也给出了详细说明（啥都没发生就是`goodbit`）:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081445541.png" alt="image-20211108144549477" style="zoom:50%;" />

当内置错误标志为`fail`时，我们也可以利用C++库的从`istream object&`到`bool`的隐式转换`ss >> ch`作为`!ss.fail()`的替代:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111102311395.png" alt="image-20211110231100308" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111102311243.png" alt="image-20211110231116176" style="zoom:50%;" />

在本课的`stringToInteger`函数中，我们见到如下使用方式：

```c++
int stringToInteger(const string& str) {
    istringstream iss(str);
    int result;
    iss >> result;
    cout << "result: " << result << endl;
    if (iss.fail())
        throw domain_error("error1");
    char remain;
    iss >> remain;
    cout << "remain: " << remain << endl;
    if (!iss.fail())
        throw domain_error("error2");
    return result;
}

// case 1:
// result: 5, remain: l
// error2
stringToInetger("5lol");
// case 2:
// result: 0
// error1
stringToInteger("lol");
```

为什么会出现如上的情况？这要考虑到`>>`第一种重载模式，即用来读取算术类型的内置操作：

> "Extracts and parses characters sequentially from the stream to interpret them as the representation of a value of the proper type, which is stored as the value of val.
> Internally, the function accesses the input sequence by first constructing a [sentry](https://www.cplusplus.com/istream::sentry) object (with noskipws set to `false`). Then (if [good](https://www.cplusplus.com/ios::good)), it calls [num_get::get](https://www.cplusplus.com/num_get::get) (using the stream's *[selected locale](https://www.cplusplus.com/ios_base::getloc)*) to perform both the extraction and the parsing operations, adjusting the stream's *[internal state flags](https://www.cplusplus.com/basic_ios::rdstate)* accordingly. Finally, it destroys the [sentry](https://www.cplusplus.com/istream::sentry) object before returning."

注意到此时在内部是使用了`num_get::get`方法对数字进行读取的，如果成功读取，把结果存储在参数`val`中，并利用此函数更新`internal error flags`(利用传递给`get`方法的`ios_base::iostate& err`参数)：

> - "The function stops reading characters from the sequence as soon as one character cannot be part of a valid numerical expression (or end is reached). The next character in the sequence is pointed by the iterator returned by the function."
>
> - "*Return value*: The next character in the sequence right after where the extraction operation ended."
> - <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081615482.png" alt="image-20211108161553419" style="zoom:50%;" />

当尝试使用`int type`读入字符串`"5lol"`时，首先`num_get::get`方法读取数字5，由于下一个`char`不是`part of valid numerical expression`，所以他立即停止读取，此时`val`的数值为`5`. 指针指向`5`的下一个字符`l`.

当尝试使用`int type`读入字符串`"lol"`时，首先`num_get::get`方法读取字符`l`，发现` The sequence did not match the expected format`，所以他立即停止读取，此时`val`的数值为`0`. 指针仍然指向头部，并设置了一个`failbit`，于是当我们返回到`>>`的处理过程中时，就会显示`fail()`了，这也与`>>`产生`failbit`的条件吻合，因为此时相当于没有新的字符被成功提取，同时`sb`此时也是一个`null pointer`.(因为我们用的是`int type`处理)。并且`result`的输出值为`0`，这也是`num_get::get`方法中`val`被存储的值。

> 如果我们把第二次读取的类型换成`double`，并尝试读入字符串“5.2”时，不会出现任何问题，因为在第一次读取`5`之后，序列中余下的`.2`被程序理解为`0.2`，也是我们第二次读取输出的结果。

#### white space separating？

为什么使用`stringstream`之后`istream >> string`读取字符串能够自动以空白字符作为分割？

这是因为`string`类本身也对`extraction operator`进行了重载：

```c++
istream& operator>> (istream& is, string& str);
```

按照*StackOverflow*的说法，该函数的实现类似于**C**中的*scanf %s*，他会持续读取直到遇到空白字符（包括空格、tab等）下一次从空白字符开始读取（但是默认会`skipws`）。在官方[文档](https://www.cplusplus.com/reference/string/string/operator%3E%3E/)中，我们找到了依据：

> Notice that the [istream](https://www.cplusplus.com/istream) extraction operations use whitespaces as separators; Therefore, this operation will only extract what can be considered a word from the stream. To extract entire lines of text, see the [string](https://www.cplusplus.com/string) overload of global function [getline](https://www.cplusplus.com/string:getline).
>
> <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100156520.png" alt="image-20211110015649451" style="zoom:50%;" />

也就是说如果我们使用`>>`将数据读入字符串，那么他会尝试着一个单词一个单词地读取。该过程的实现也是借助于一个由指针`sb`指向的`streambuf object`，每次我们都在向该`streambuf`写入数据，在向`streambuf`写入完毕之后，将`streambuf object`中的内容写给`string`对象。**所有的stream对象，都有一个与之关联的`streambuf object`**.

#### Again--About Whitespaces!

下边来看这样两个例子：

1. ```c++
   string a = " 12 3";
   stringstream iss(a);
   char b, c;
   iss >> std::noskipws >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b:  c: 1
   ```

   ```c++
   string a = " 12 3";
   stringstream iss(a);
   char b, c;
   iss >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b:1  c: 2
   ```

2. ```c++
   string a = " 12 3";
   stringstream iss(a);
   string b, c;
   iss >> std::noskipws >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b:  c: 
   ```

   ```c++
   string a = " 12 3";
   stringstream iss(a);
   string b, c;
   iss >> b >> c;
   cout << "b: " << b << " c: " << c << endl;
   // result: b: 12 c: 3
   ```

这两个例子中唯一的区别就是第一个我们提供了`char`类型，而第二个是`string`类型。首先我们不去关注代码中的`noskipws`，看第二个例子，即`string`的那一个：根据上一节的描述，当`istream >> string`遇到了**空白字符**时，他会停止读取，而恰好，在字符串`a`的最前边存在一个**空白字符**，所以我们想它应该会直接在开头处停止，不会读取到任何东西，所以最后返回的是空字符串。

但是我们发现如果尝试将代码中的`std::noskipws`去掉，那么返回的结果会与之前不同，这又是为什么呢？

首先我们需要了解运算符`>>`重载的第三种类型：`manipulators`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081624307.png" alt="image-20211108162408233" style="zoom:50%;" />

注意到`skipws/noskipws`这种类型，当`skipws`被设置时，`stream`默认会忽视所有的空白字符，[文档](https://www.cplusplus.com/reference/ios/skipws/)中提到：

> "For standard streams, the skipws flag **is set** on initialization."

也就是说，在默认情况下初始化的结果为设置了`skipws`，所以所有空白字符都会被读取之后跳过，直到我们又发现了一个**非空白字符**。如此一来，上边例子的结果就好理解了。需要注意的是，在C++中，对于所有的`formatted input`（即可以格式化成我们需要的类型的，比如C中的`prinf, scanf`，C++中使用`>>`操作的），默认都是`noskipws=false`，也就是说会**跳过空白字符**；而对于所有的`unformatted input`（比如`getchar(char), getline(string)`）均设置为`noskipws=true`。

> 关于格式化输入与非格式化输入，我是这么理解的，格式化输入意味着我们可以把输入的数据变成我们想要的类型，比如当我们使用`>>`操作符时，我们可以读入整型，也可以读入一个字符串；但是非格式化输入只能读入`rawText type`，好比`geline(string)`我们输入了一个字符串那么接受类型就是一个字符串.

同时，`skipws`与`noskipws`两者是`sticky`的，也就是说我们只有重新设置，才能变回原来的状态。如果想要每一步都可以设置是否保留**空白字符**，我们可以使用`std::ws`，提取**空白字符**，直到遇到**非空白字符**。

> 设置`skipws`等的步骤是在为输入序列创建`sentry`对象时进行的.

除了上述提到的`skipws`这种`manipulator`之外，常见的可以用于`pad output`的还有：`left/right/internal`, `setw`, `setfill`等：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091756123.png" alt="image-20211109175615973" style="zoom:50%;" />

这几个`manipulator`在内部调用了内置的一些方法，比如`setfill`是调用了`basic::ios::fill(char_type)`，`left`是设置了名为`adjustfiled`的`flag value`，`setw`则和使用`width(n)`的效果相同，设置了`field width`–所以该函数指定的是输出序列中允许存在的**最少的字符数**。

#### set position

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111081358479.png" alt="image-20211108135808429" style="zoom:50%;" />

需要注意的是，在`streamoff`中，`n`的值可正可负。常见的使用方法如下：

```c++
fpos = oss.tellp() + streamoff(3);
oss.seekp(pos);
// or
oss.seekp(streamoff(1), stringstream::cur);
```

### cin & cout

由于`cin`实际上是一种`istream object`，有些特性上边一节已经总结的差不多了…这里只总结两点：

1. 为什么明明输入流默认设置`skipws`，但是我们输入一个`\n`时，`console`内仍然会打印出新的一行？

这是因为控制台内的打印是由`consle software`控制的，与`cin`没有任何关系。

2. cin is *[tied](https://www.cplusplus.com/ios::tie)* to the standard output stream [cout](https://www.cplusplus.com/cout) (see [ios::tie](https://www.cplusplus.com/ios::tie)), which indicates that [cout](https://www.cplusplus.com/cout)'s buffer is *flushed* (see [ostream::flush](https://www.cplusplus.com/ostream::flush)) before each i/o operation performed on cin.

> The tied stream is an output stream object which is *[flushed](https://www.cplusplus.com/ostream::flush)* before each i/o operation in this stream object.

我们常用的`std::endl`就是**换行+刷新输出缓冲区**，所以如果我们仅仅使用`cout`而不添加`endl`，字符会首先存到`output buffer`中，**只有当`output buffer`满了或者程序终止时，才会调用`flush`方法**。

那么问题来了，`std::flush`是如何工作的？[这里](https://stackoverflow.com/questions/14105650/how-does-stdflush-work)给出了较为详细的解答。

言简意赅地说，`ostream::flush()`会在内部调用`streambuf::pubsync()`方法，对流缓冲区进行操作；流缓冲区的作用是负责“缓冲”字符并把数据发送给外部目的地–这发生在缓冲区已满或者内部数据**应当**与外部目的地进行**同步**的时候（比如`flush()`）。当需要同步时，缓冲区内部的数据立即发送给外部目的地，根据官方[文档](https://www.cplusplus.com/reference/ostream/ostream/flush/)：

> For *[stream buffer](https://www.cplusplus.com/streambuf)* objects that implement intermediate buffers, this function requests all characters to be written to the controlled sequence.

这意味着，如果我们正在尝试把数据输出到控制台上，那么此操作会立即把缓冲区内目前所有的字符输出输出流中，再显示到控制台界面上，这意味着清空了`stream buffer`。对于文件流效果是一样的，只不过外部目的地换成了**文件**而已。

所以何时需要进行`flush`操作呢？当然是我们接下来有可能需要向外部目的地写入数据的时候，因为如果此时缓冲区内还存有先前的数据，那毫无疑问的会造成影响！

3. 如果我们注意在输入过程中`internal error flag`的变化，则在每次`flush`之后，以及每次`cin`读取完数据后，内置错误标志位都会被设置成`eof`. 因为输入流意识到自己读到了字符串的末尾。需要注意的是，如果在输入过程中，标志位在某一刻被设置成`fail`，那么此后的所有尝试输入的操作均会失效，这一点我们在前边提到过，必须使用`clear()`清空状态才可以继续进行。

#### ignore

函数原型：

```c++
istream& ignore (streamsize n = 1, int delim = EOF);
```

注意到这种特殊的使用方法，可以帮助我们忽略掉当前`stream buffer`中所有的数据，直到**eof**：

```c++ 
con.ignore(numeric_limits<streamsize>::max(), ‘\n’);
```

### getline(string)

该函数常被用来读取一整行的数据，或者按照`delimiters`分割数据；这是一个`unformatted input function`，根据前几节所属的特点，非格式化输入函数默认设置`noskipws`，那么当遇到分割字符时，它的处理方法是：

> If the delimiter is found, it is extracted and discarded (i.e. it is not stored and the next input operation will begin after it).

同样的，该函数也会对`internal error flags`进行设置。

在文件读取中，如果我们读到了文件末尾，那么`getline`会设置一个`eofbit`，但是此时并不会设置`failbit`，而在继续的下一次读取中，因为我们没有读取到任何内容，**根据failbit**的定义，`sentry object`会置一个`failbit`，借助这一特点，我们在实际使用中常把读取循环写作如下形式而非`while(!input.fail())`，进而避免向数据结构中输入最后一次读取的`garbage value`：

```c++
ifstream file(filename);
while(true) {
    string line;
    getline(file, line);
    if (file.fail()) {
        break;
    }
    // process the read data
}
```

> 我们可以通过在`char*(c-string)`后加一个`s`字母的方式，将其转化为`C++ string`

## type deduction

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091508689.png" alt="image-20211109150854609" style="zoom:50%;" />

## structure

### pair

在C++中，传统的返回多个值的方法是使用`reference parameters`，但问题在于除非我们查看函数定义，否则引用参数并不明显。在C++11中提供了`pair`或者`tuple`，我们可以使用他们组合多个返回值：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091512437.png" alt="image-20211109151222334" style="zoom:50%;" />

```c++
std::pair<std::string, std::string> f(std::pair<std::string, std::string> p)
{
    return {p.second, p.first}; // list-initialization in return statement
}
```

### tuple

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091657348.png" alt="image-20211109165717288" style="zoom:50%;" />

### structured binding

在C++17中，与Python类似，我们可以做`unpack`（`structured binding`）：

```c++
auto [min, max] = findPriceRange(dist);
```

如果我们使用结构体作为以上函数的返回值，那么`structured binding`仍然可以使用。

我们还可以对引用使用`structured binding`:

```c++
void transformToDST(vector<Course>& courses) { 
    for (auto& [code, start, end, instructors] : courses) { 
        start++; 
        end++; 
    }
}
```

```c++
void print_map(std::string_view comment, const std::map<std::string, int>& m)
{
    std::cout << comment;
    for (const auto& [key, value] : m) {
        std::cout << key << " = " << value << "; ";
    }
    std::cout << "\n";
}
```

### Aggregate initialization

随着C++标准的不断更新，初始化的方式愈发多样化。`aggregate initialization`是一种`list-initilization`，在**C++20**中也被叫做`direct initialization`. 他应用于`arrays`以及`class type`，比如结构体或者联合，但是在使用时有一些特殊要求，可参见[文档](https://en.cppreference.com/w/cpp/language/aggregate_initialization)。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111111743654.png" alt="image-20211111174324498" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091539422.png" alt="image-20211109153853532" style="zoom:50%;" />

> 这里的`course`是一个结构体

需要注意的是，当使用`uniform initialization`时，对象会首先尝试使用`initilizer list constructor`而非普通的构造函数：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111091548990.png" alt="image-20211109154855889" style="zoom:33%;" />

**当我们尝试使用`aggregate initialization`的方法初始化结构体等`class type`时，在C++11中被做了`不允许在存在默认初始化参数的情况下使用`的限制，这一限制条件在C++14中被取消。**：

```c++
struct A {
  string str;
  int n = 42;
  int m = -1;
};
A{.m=21}  // Initializes str with {}, which calls the default constructor
          // then initializes n with = 42
          // then initializes m with = 21
```

**文档截图中的初始化方案3，4被称为`designated initilizers`，这种初始化方法要保证所有元素的初始化顺序与定义顺序一样，但是我们可以缺省某个参数：**

```c++
struct A { int x; int y; int z; };
A a{.y = 2, .x = 1}; // error; designator order does not match declaration order
A b{.x = 1, .z = 2}; // ok, b.y initialized to 0
```

我们可以使用`designated initializers`来初始化联合，但是**union只允许我们提供一个初始化参数成员：**

```c++
union u { int a; const char* b; };
u f = { .b = "asdf" };         // OK, active member of the union is b
u g = { .a = 1, .b = "asdf" }; // Error, only one initializer may be provided
```

详细内容参见官方文档.

## STL

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111092139795.png" alt="image-20211109213909613" style="zoom:50%;" />

> `vector[i]` causes undefined behavior!

- `Sequence containers`

1. vector
2. deque（双端队列）
3. array
4. list（双向链表）
5. forward_list（单链表）

- `Container Adaptors`

1. stack
2. queue
2. priority_queue

这类容器之所以叫`adaptors`，是因为他们底层的结构实际上是由另一种容器构成的，我们也可以通过更换函数声明中的模板参数: stack和queue的底层是一个deque:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111092042210.png" alt="image-20211109204236062" style="zoom:50%;" />

- `Associative containers`

1. map
2. set
3. unordered_map
4. unordered_set
4. multimap/unordered_multimap
4. multiset/unordered_multiset

> 所谓`multimap`与`multiset`，是指的可以存在多个相同的键值（元素）.

需要注意的是，`map`方法`at(i)`和`[i]`的区别：`at`方法如果没有找到该元素，会抛出一个异常，而如果我们使用`[]`，那么在没有找到该元素时，会先进行创建。

### iterator

迭代器是STL的重要方法，我们所使用的`range for loop`就是使用迭代器在内部工作的。

> 注意`iterator`的`end`指向的是最后一个元素的后一位.

#### map iterator

`map`的迭代器比较特殊，它指向一个`pair`对象，所以我们可以使用`a.first`和`a.second`获取键与值：

```c++
map<int, int> m;
map<int, int>::iterator i = m.begin();
map<int, int>::iterator end = m.end();
while(i != end) {
    cout << (*i).first << (*i).second << endl;
    ++i;
}
```

在C++20之前，如果我们想要查找容器中是否存在某个键，那么需要调用`find`或者`end`方法，而在C++20中，我们只需要调用`contains`即可。

> 如果`find`成功，则`iterator`指向对应的元素，否则指向`end`. `count`方法通过调用`find`实现，所以`find`方法的速度更快.

#### lower_bound & upper_bound

`lower_bound`接受一个值`v`，返回一个`iterator`对象，该对象指向第一个**不小于**元素`v`的位置，如果没有找到，则指向`end`。

`upper_bound`与`lower_bound`的工作方式类似，但是其返回的迭代器对象指向第一个**大于**元素`v`的位置。

#### Iterator Types Introduction

共有五种基本的迭代器类型：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111100017458.png" alt="image-20211110001729377" style="zoom:50%;" />

上图中的箭头我们可以理解成*继承*关系。对于所有的迭代器类型，他们都具备以下几种基本操作功能：

- Is *[copy-constructible](https://www.cplusplus.com/CopyConstructible)*, [copy-assignable](https://www.cplusplus.com/CopyAssignable) and [destructible](https://www.cplusplus.com/Destructible)
- can be advanced using `++`
- can be derederenced using `*`

1. `Input Iterators`

应用对象：**连续**+**单向**输入，下边来分别解释这两个限制条件的意思：

- **连续**，表示所应用的数据结构不可以是`queue`，`stack`等（不包括`deque`，因为`deque`实际效果上是一个优化了前序插入的`vector`）
- **单向**（`single-pass`），迭代器对应的每个位置只能允许被*经过*一次，这个限制条件之后会详细解释

`input iterators`只能作为右值（`rvalue`）被解引用：

```c++
int val = *itr;
```

这种迭代器的应用场景有之前提到过的`find`以及`count`函数等。这种迭代器类型数据是**只读的**。

2. `output iterators`

它的应用条件与`input iterators`相同，但是它只能作为左值（`lvalue`）被解引用：

```c++
*itr = 12;
```

该迭代器对象的应用场景主要有`copy`以及`output streams`等。它是**只写的**。

3. `forward iterators`

这种迭代器类型与把前两种类型结合起来的效果类似，不同的是，他可以做`multiple pass`. 应用场景主要有`replace`函数以及`forward_list`中。

4. `bidirectional iterators`

承接`forward iterators`，但是可以做`--`操作：

```c++
vector<int>::iterator itr = v.begin();
--itr;
```

应用场景主要有`reverse`函数，`map`, `set`以及`list`等。

5. `random Access iterators`

承接上一种类型，但是支持`+=n`与`-=n`操作，同时可以使用`offset dereference operator ([])`，应用在容器`vector`, `deque`, `string`以及**指针**上。

> Instead of being defined by specific types, each category of iterator is defined by the operations that can be performed on it. This definition means that any type that supports the necessary operations can be used as an iterator -- for example, a pointer supports all of the operations required by [*LegacyRandomAccessIterator*](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator), so a pointer can be used anywhere a [*LegacyRandomAccessIterator*](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator) is expected.

关于迭代器类型，补充以下一些内容：

除了上述提到的5种基本类型的迭代器，**C++**后来新增了一种基本迭代器类型：`Contiguous Iterator`，这种迭代器类型在`randomAccess Iterators`的基础上保证了**其中的数据在内存必须连续存储**。

在[**C++20**](https://en.cppreference.com/w/cpp/iterator)中，根据新的关键字`concept`以及`requires`对迭代器类型根据新的系统设计了一套定义，但是基本的类型是相似的；

> 我们可以简单地将这两个关键字的功能理解为：为模板参数制定一些限制，使得在*编译*阶段就能够进行`evaluation`。应用他们的主要优点是可以得到更加清晰地编译器报错。这里不去深究，[这篇文章](https://www.cppstories.com/2021/concepts-intro/)写的较为清楚。

新的迭代器定义基本方法是先使用这两个关键字定义了一种`input_or_output_iterator`类型，之后扩展的每一种类型均满足这种基本迭代器类型的要求，从定义中可以看到，这种基本类型支持两种操作：解引用+递增操作符：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101555478.png" alt="image-20211110155516376" style="zoom: 33%;" />

新定义的迭代器类型除了`output_iterator`是直接在`input_or_output_iterator`基础上增加了写入功能之外，其余的迭代器类型均[继承](https://en.cppreference.com/w/cpp/concepts/derived_from)自**C++20**之前的迭代器类型，比如对于`input iterator`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101600970.png" alt="image-20211110160016902" style="zoom:50%;" />

#### What is single-pass?

什么是`single-pass`？为什么只能`single-pass`？**C++标准库**中提到：

> **For input iterators, a == b does not imply ++a == ++b.** (*Equality does not guarantee the substitution property or referential transparency.*) Algorithms on input iterators should never attempt to pass through the same iterator twice. They should be single pass algorithms. Value type T is not required to be an Assignable type (23.1). These algorithms can be used with istreams as the source of the input data through the istream_iterator class.

[这里](https://stackoverflow.com/questions/5947683/for-input-iterators-why-a-b-does-not-imply-a-b)对该问题进行了细致的讨论。在讨论`input iterators`时，常使用`istream_iterator`作为例子，该迭代器类型从输入流中读取数据，我们可以想到，无论该读取过程是否需要用到`stream buffer`，读取都是发生在迭代器不断向前推进的时候，而输入流某个位置在被读取之后，我们就不能够再次对流中同一个位置的元素进行操作了，也就是说我们**只能用一个迭代器，单向，走一次**：

> `std::istream_iterator` is a single-pass input iterator that reads successive objects of type `T` from the [std::basic_istream](https://en.cppreference.com/w/cpp/io/basic_istream) object for which it was constructed, by calling the appropriate `operator>>`. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object is read when the iterator is constructed. Dereferencing only returns a copy of the most recently read object.
>
> The default-constructed `std::istream_iterator` is known as the *end-of-stream* iterator. When a valid `std::istream_iterator` reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.

所以在标准文档给出的说明中，`++a==++b`为什么此时不能够保证成立呢？这里首先我们要明确以下`++`操作符的作用机理：

##### Increment/decrement operators

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101700052.png" alt="image-20211110170018954" style="zoom:50%;" />

根据[官方文档](https://en.cppreference.com/w/cpp/language/operator_incdec)中的解释，**前置**递增操作符的运算过程与`x += 1`完全相同，在对元素递增之后，**返回一个该元素的引用**；而**后置**递增操作符则是先保存一下元素副本，对该元素本身（引用）进行递增之后，**把副本（保存着原值）返回**。

在清楚了`++`操作符的作用机理后，我们把目光转回到`iterator`上。在表达式`++a==++b`上，如果我们已经进行了`++a`的操作，那么根据`istream_iterator`的特性，已经对流内的数据进行了读取，那么此时`iterator b`就找不到流内原位上的数据了，换而言之，`iterator b`**失效了**！

> 如果我们读取的是字符，那么需要用到`stream buffer`，此时使用[std::istreambuf_iterator](https://en.cppreference.com/w/cpp/iterator/istreambuf_iterator)是效率更高的选择，因为他不需要对每一个字符建立一个`sentry object`，程序在开始时先建立一个`sentry object`，之后把所有数据放入缓冲区，再使用迭代器进行读取.

所以，在`count`以及`find`函数中，我们确实只需要走一次就可以获得我们想要的结果，于是只需要使用一个`input iterator`即可。对应着`output iterator`的`ostream_iterator`也是一样的道理。

#### Write our own iterator?

在C++17之前的版本中，如果我们想给自己的类写一个`iterator`，那么一般的方法是继承`std::iterator`的类模板，并在类模板中指定所谓的`iterator_category`：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111101732699.png" alt="image-20211110173203619" style="zoom:50%;" />

迭代器标签关联着之前所述的迭代器实体。但是自**C++17**起，`std::iterator`的类模板遭到舍弃，[详情参见](https://stackoverflow.com/questions/37031805/preparation-for-stditerator-being-deprecated)。所以现在，我们只能手写迭代器，具体可以看[这里](https://segmentfault.com/a/1190000040879971)。

## Template–Generic Programming

### function template

函数模板的基本形式是：

```c++
template<typename T>
T getInteger(const string& prompt, const string& reprompt) {
    while (true) {
        cout << prompt; 
        string line; 
        T result; 
        char extra; 
        if (!getline(cin, line))
            throw domain_error(“[shortened]”);
        istringstream iss(line);
        if (iss >> result && !(iss >> extra)) 
            return result; 
        cout << reprompt << endl; 
    }
}
```

#### instantiation（explicit/implicit）

在调用模板函数时，我们可以显式指定对应的模板参数类型（`explicit instantiation`）,也可以不显式指定模板参数类型（`implicit instantiation`），让模板函数进行**类型推断（`Template Argument Deduction`）**，需要注意的是，如果我们省略`<>`符号，那么`overload resolution`会查找所有的模板类型重载与非模板类型重载，而不是仅仅查找模板类型重载。

> 什么是`overload resolution`?后边有提到.

#### implicit inference

在模板函数中，我们可能会隐含着一些使用参数的限定条件，比如对于下图所示的函数：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111131433705.png" alt="image-20211113143322516" style="zoom:50%;" />

其实隐含着这样一些限定参数使用条件：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111131434734.png" alt="image-20211113143458651" style="zoom:50%;" />

这些限定条件意味着如果我们在调用函数时给出了不恰当的参数，那么该模板函数会报出一些非常凌乱的错误…

在**C++20**中给出了新的关键字`concepts`与`requires`，也就是在之前我们提到过用于重写`iterator`的两个关键字，他们可以帮助我们在编译阶段就检查出参数错误，将报错的位置从函数主体转移到这两个关键字的位置上：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111131442975.png" alt="image-20211113144241875" style="zoom:50%;" />

既然`concepts`关键字可以方便解决模板编译与运行过程中的报错问题的，那么接下来就针对模板的编译过程进行分析。

### Compile a template function call

接下来所述的概念来自于官方文档以及这两篇[1](https://www.cppstories.com/2016/02/notes-on-c-sfinae/#improved-code)[2](https://www.cppstories.com/2018/03/ifconstexpr/#c20)博客. 根据作者原文给出的例子:

```cpp
truct Bar {
    typedef double internalType;  
};

template <typename T> 
typename T::internalType foo(const T& t) { 
    cout << "foo<T>\n"; 
    return 0; 
}

int main() {
    foo(Bar());
    foo(0); // << error!
}
```

当我们向程序中添加了一个新的非模板函数重载`int foo(int i)`时，程序便不会报错，为什么呢？我们需要了解函数整个的编译过程。

#### name lookup

根据[官方文档](https://en.cppreference.com/w/cpp/language/overload_resolution),为了编译一个函数调用，程序首先会进行`name lookup`，这一步是将程序中出现的名字与引入它的**声明**联系起来，比如对于如下语句，程序正是通过`name lookup`的方式来解析这条语句中出现的各个名字：

```c++
std::cout << std::endl;
```

> 在进行`name lookup`时，我们依赖的是`scope`这个概念，也即名称的**声明**所在地，`scope`有很多[种类](https://en.cppreference.com/w/cpp/language/scope)，`namespace`,`function`,`class`,`block`,`enumeration`,`template parameter`都拥有自己的`scope`.

##### unqualified name lookup & qualified name lookup

在上边的例子中，编译器首先会对名称`std`进行`unqualified name`查找，在头文件`<iostream>`中找到它；之后再对`cout, endl`做`qualified name`的查找，即在命名空间`std`中进行的查找过程。

> `qualified name`即在作用域解析符`::`右侧出现的名称，所以他包括：
>
> - class member
> - namespace member
> - enumerator
>
> 同样地，`unqualified name`即没有在作用域解析符`::`右侧出现的名称

需要注意的是，如果作用域解析符`::`左侧没有东西，那么程序会默认在`global namespace scope`或者由`using`引入的命名空间中进行查找：

```c++
#include <iostream>
int main() {
  struct std{};
  std::cout << "fail\n"; // Error: unqualified lookup for 'std' finds the struct
  ::std::cout << "ok\n"; // OK: ::std finds the namespace std
}
```

##### Argument-dependent lookup (ADL)

[这种](https://en.cppreference.com/w/cpp/language/adl)名称查找方式也属于一种`unqualified name lookup`，叫`Koenig lookup`，用于查找`function-call expressions`中的`unqualified function names`（包括运算符重载时对函数的隐式调用），这种查找方式的存在使得在进行函数调用时，程序不仅仅会查找一般的`unqualified name lookup`的`scope`和命名空间，还会查找**函数参数们所在的命名空间**：

该示例来自于官方文档：

```c++
#include <iostream>
int main()
{
    std::cout << "Test\n"; // There is no operator<< in global namespace, but ADL
                           // examines std namespace because the left argument is in
                           // std and finds std::operator<<(std::ostream&, const char*)
    operator<<(std::cout, "Test\n"); // same, using function call notation
 
    // however,
    std::cout << endl; // Error: 'endl' is not declared in this namespace.
                       // This is not a function call to endl(), so ADL does not apply
 
    endl(std::cout); // OK: this is a function call: ADL examines std namespace
                     // because the argument of endl is in std, and finds std::endl
 
    (endl)(std::cout); // Error: 'endl' is not declared in this namespace.
                       // The sub-expression (endl) is not a function call expression
}
```

#### Template Argument Deduction

在进行完`name lookup`这一步之后，程序会进行`Template Argument Deduction`：

> In order to instantiate a [function template](https://en.cppreference.com/w/cpp/language/function_template), every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some [other contexts](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts).

这一机制以及上一节提到的`ADL`，让我们使用`template operator`成为可能，因为在使用`template operator`时，我们无法显式指定所用的模板参数的类型：

```c++
#include <iostream>
 
int main() 
{
    std::cout << "Hello, world" << std::endl;
    // operator<< is looked up via ADL as std::operator<<,
    // then deduced to operator<<<char, std::char_traits<char>> both times
    // std::endl is deduced to &std::endl<char, std::char_traits<char>>
}
```

#### Template Argument Substitution

现在，我们已经获取到了所使用的模板参数类型，在这一步我们要将所有出现在原本的模板中的参数`T`替换为我们推断出的参数类型。

> When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.

需要注意的是如果在替换过程中，出现了错误，比如在先前给出的例子中，我们获得了一个`int::interalType`的类型，那么此时，我们需要把这一参数类型（一个替换方案）剔除出`overload set`，这一[操作](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error)被称为**SFINAE–*Substitution failure is not an error***.

#### overload resolution

在做完`Template Argument Substitution`这一步后，如果`overload set`中已然没有可用的函数，那么编译失败，但存在这样一种情况：即目前有多个`candicate function`可供选用，那么此时`overload resolution`便会派上用场。

> In order to compile a function call, the compiler must first perform [name lookup](https://en.cppreference.com/w/cpp/language/lookup), which, for functions, may involve [argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl), and for function templates may be followed by [template argument deduction](https://en.cppreference.com/w/cpp/language/template_argument_deduction). If these steps produce more than one *candidate function*, then *overload resolution* is performed to select the function that will actually be called.

> 这是一种针对于`function call`的通用概念，并非只针对`template`.

当我们试图在模板函数中应用`overload resolution`以选择最佳匹配重载函数时，会使用`partial ordering of overloaded function templates`的[方法](https://en.cppreference.com/w/cpp/language/function_template)来选择最佳匹配。什么是最佳匹配重载函数？

> Informally "A is more specialized than B" means "A accepts fewer types than B".

*StackOverflow*上有一篇很详细的[文章](https://stackoverflow.com/questions/17005985/what-is-the-partial-ordering-procedure-in-template-deduction)描述这一机理。

#### SFINAE

在上一节的`template argument substituion`中，我们提到了`SFINAE`的内部作用机理，那么我们要如何写出这样的代码或者说这一机理有什么用处呢？

##### Why we need SFINAE?

在这篇[文章](https://www.cppstories.com/2018/03/ifconstexpr/#c20)里，其实解释的很清楚。这里是我的一个总结。简而言之，对于我们自己的函数模板代码，如果其中存在`if-else`分支，那么程序很有可能会在编译阶段报错，因为他会编译`if-else`两个分支，之后程序发现自己无法`reject the invalid code (for this case)`，而我们要做的，就是让程序在编译阶段把在当前情况下不正确的分支给剔除，从`overload set`中将其去掉，只编译符合要求的部分，这也对应着`SFINAE`的定义。

##### How to leverage SFINAE?

为了解决这个问题，**C++11/14/17/20**提出了多种方案：

###### [Tag Dispatching](https://www.cppstories.com/2016/02/notes-on-c-sfinae/#improved-code)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132349840.png" alt="image-20211113234948754" style="zoom:50%;" />

###### enable_if

> **std::enable_if** can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter.

[这一语法](https://en.cppreference.com/w/cpp/types/enable_if)自**C++11**提出，但当时的写法是`enable_if`，在**C++14/17**中，提出了`enable_if_t`.

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132147605.png" alt="image-20211113214738450" style="zoom:50%;" />

也就是说，当`B==true`时，`enable_if`具备一个`typedef type`，即`T`，否则没有该成员，于是当我们写成如下代码：

```cpp
template <class T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type
```

或者参看文档中的`alias`–`enable_if_t`的定义时，如果其不具备成员`type`但是我们却使用了`::type`，那么编译就会出错，并使用`SFINAE`机制处理。在**C++14**及以后的版本中，上述代码可被简化为：

```c++
template <class T>
typename std::enable_if_t<std::is_arithmetic_v<T>, T> 
```

`enable_if`常与`type traits`一起使用：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132152195.png" alt="image-20211113215251103" style="zoom:50%;" />

`type traits`在**编译阶段**用以确定模板特征和属性。在**C++14**中也提出了类似于`is_arithmetic_v`的形式（原本的`value`当`T`为`arithmetic type`是返回`true`，反之`false`）

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132155450.png" alt="image-20211113215505370" style="zoom:50%;" />

借助于`enable_if_t`，我们可以将本节最初的代码更改为：

```cPP
template <typename T>
enable_if_t<is_convertible_v<T, string>, string> strOld(T t) {
    return t;
}

template <typename T>
enable_if_t<!is_convertible_v<T, string>, string> strOld(T t) {
    return to_string(t);
}
```

> 关于`enable_if`的缺点，*StackOverflow*上的一篇[文章](https://stackoverflow.com/questions/14600201/why-should-i-avoid-stdenable-if-in-function-signatures)进行了探讨。

###### Notes

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111132229957.png" alt="image-20211113222941812" style="zoom:50%;" />

> 需要注意的是，这里提到的是`only differ in default template arguments`，如果两个模板的`default template argument`一样但是`template parameters`不一样，那么不会发生编译错误.

###### if constexpr

在**C++17**中，我们可以将`if conxtexpr statement`使用在模板中，起到与`enable_if_t`相同的作用：

```c++
template <typename T>
auto get_value(T t) {
    if constexpr (std::is_pointer_v<T>)
        return *t; // deduces return type to int for T = int*
    else
        return t;  // deduces return type to int for T = int
}
```

###### concepts-requires

终于，我们来到了`concepts`。

```cpp
// concept:
template<typename T>
concept Hashable = requires(T a) {
    { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;
};
```

在这里，我们定义一个`concept`，将一个`requires-expression`赋值给它。`requires`关键字有很多种写法：

- requires clauses

```c++
template<typename T>
void f(T&&) requires Eq<T>; // can appear as the last element of a function declarator
 
template<typename T> requires Addable<T> // or right after a template parameter list
T add(T a, T b) { return a + b; }
```

- requires expressions

```c++
template<typename T>
concept Addable = requires (T x) { x + x; }; // requires-expression
```

- simple requirements

```c++
template<typename T>
concept Addable =
requires (T a, T b) {
    a + b; // "the expression a+b is a valid expression that will compile"
};
```

> 因为所有以关键字`requires`开头的`requirements`都会被解释成`nested requirement`，所以`simple requirements`不会以`requires`开头

- Type requirements

```c++
template<typename T> using Ref = T&;
template<typename T> concept C =
requires {
    typename T::inner; // required nested member name
    typename S<T>;     // required class template specialization
    typename Ref<T>;   // required alias template substitution
};
```

- Compound requirements

- Nested requirements

###### Abbreviated function template

自**C++20**始，提出了`Abbreviated function template`的做法，即使用`placeholder types(auto, concept auto)`出现在函数声明或者函数模板声明中：

```c++
void f1(auto); // same as template<class T> void f(T)
void f2(C1 auto); // same as template<C1 T> void f2(T), if C1 is a concept
void f3(C2 auto...); // same as template<C2... Ts> void f3(Ts...), if C2 is a concept
void f4(const C3 auto*, C4 auto&); // same as template<C3 T, C4 U> void f4(const T*, U&);
template <class T, C U>
void g(T x, U y, C auto z); // same as template<class T, C U, C W> void g(T x, U y, W z);
```

于是对于原博客中给出的例子：

```cpp
// requires:
template <typename T>
requires std::is_floating_point_v<T>
constexpr bool close_enough20(T a, T b) {
   return absolute(a - b) < precision_threshold<T>;
}
constexpr bool close_enough20(auto a, auto b) {
   return a == b;
}
```

根据[官方文档](https://en.cppreference.com/w/cpp/language/function_template#Abbreviated_function_template)，我们利用`constrained auto`将其改写为：



```cpp
constexpr bool close_enough20(std::floating_point auto a,
                              std::floating_point auto b) {
   return absolute(a - b) < precision_threshold<std::common_type_t<decltype(a), decltype(b)>>;
}
constexpr bool close_enough20(std::integral auto a, std::integral auto b) {
   return a == b;
}
```

这里有一篇[文章](https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/)作了较为详细的介绍。

### Lambda Expressions

[1](https://www.cppstories.com/2020/08/lambda-generic.html/)话题的引入来自于该函数中的`predicate`，我们尝试着将它写做一个非固定最大值的版本，即将下边的5替换为一个`limit`变量：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111140037577.png" alt="image-20211114003742461" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111140038721.png" alt="image-20211114003814642" style="zoom:50%;" />

> call it by using function pointers

#### Pre-C++11

在**C++11**之前，我们使用如下方法：

```c++
// by value
class GreaterThan {
public:
    GreaterThan(int limit) : limit(limit) {}
    // note: this should have a const
    bool operator() (int val) const {return val >= limit};
private:
    int limit; /* the value we captured outside*/
}

// by reference
class GreaterThan {
public:
    GreaterThan(int &limit) : limit(limit) {}/* pass by reference */
    // note: this should have a const
    bool operator() (int val) const {return val >= limit};
private:
    int& limit; /* the value we captured outside, by reference*/
}
```

在**C++11**中引入了`lambda expression`:

```cpp
auto func = [capture-clause](parameters) -> return-value {
// body
};

// the simplest lambda:
[]{};
```

> - `return-value` is optional
> - can use `=` to capture all by value (**not** recommend)
> - can use `&` to capture all by reference (**not** recommend)

#### C++14

1. can use `auto` as the parameters to templatize the lambda–**generic lambda**

2. can capture with an initialiser–`z = x + y`

#### C++17

1. use `constexpr` :

```cpp
constexpr auto Square = [](int n) { return n * n; };
```

2. can capture `*this`

#### C++20

We can pass a template tail:

```cpp
auto ForwardToTestFunc = []<typename ...T>(T&& ...args) {
  return TestFunc(std::forward<T>(args)...);
};
```

#### mutable

让我们把注意力移回到**C++11**之前的版本，严格来说，成员函数`operator()`的重载应当设置一个**指向常量对象的常量指针**，即写为：

```cpp
void operator()(...) const {
    // since there is a const,
    // if captured by reference, we can change the values captured
    // if captured by value, we cannot change it.
}
```

所以关键字`mutable`允许我们改变捕获的值。

#### globals & statics

`lambda`表达式仅允许捕捉具有`automatic storage duration`的变量，所以我们不能够捕捉`global/static variables`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111142007243.png" alt="image-20211114200707114" style="zoom:50%;" />

### Variadic template

#### Variadic arguments

[1](https://eli.thegreenplace.net/2014/variadic-templates-in-c/)在**C++11**之前，如果我们想让一个函数接受任意参数，那么我们需要使用`...`的语法配合`va_`系列的宏来使用，[文档](https://en.cppreference.com/w/cpp/utility/variadic)给出了一个例子：

```cpp
#include <iostream>
#include <cstdarg>
 
void simple_printf(const char* fmt...) // C-style "const char* fmt, ..." is also valid
{
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int i = va_arg(args, int);
            std::cout << i << '\n';
        } else if (*fmt == 'c') {
            // note automatic conversion to integral type
            int c = va_arg(args, int);
            std::cout << static_cast<char>(c) << '\n';
        } else if (*fmt == 'f') {
            double d = va_arg(args, double);
            std::cout << d << '\n';
        }
        ++fmt;
    }
 
    va_end(args);
}
 
int main()
{
    simple_printf("dcff", 3, 'a', 1.999, 42.5); 
}
```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111141728044.png" alt="image-20211114172837870" style="zoom:50%;" />

我们首先建立一个`va_list`的对象用于储存余下几个宏需要的信息，之后调用`va_start`，允许程序访问后随具名参数`parm_n`的可变参数：

```cpp
void va_start( std::va_list ap, parm_n );
```

之后每当我们调用一次`va_arg`，就可以获取`va_list`内的下一个参数；最终调用`va_end`终止这一过程。

需要注意的是，在使用`variadic arguments`时，`...`必须跟随在参数列表之后，而不允许被放到参数列表的前边。但是在**C++**中，这样的使用方式是被允许的：

```cpp
int printz(...)
```

这种使用方式在模板重载中被作为`SFINAE`的`fallback overload`使用，因为`...`最不`specialized`，所以在`overload resolution`中具有最低的优先级。

> fallback is a function that does not take any arguments and does not return anything.

#### Parameter pack

在上一节中提到的`variadic argument`与`parameter pack`不一样：

> Note: this is different from a function [parameter pack](https://en.cppreference.com/w/cpp/language/parameter_pack) expansion, which is indicated by an ellipsis that is a part of a parameter declarator, rather than an ellipsis that appears after all parameter declarations. Both parameter pack expansion and the "variadic" ellipsis may appear in the declaration of a function template, as in the case of [std::is_function](https://en.cppreference.com/w/cpp/types/is_function).

`parameter pack`是构成`variadic template`的基础：

> A template with at least one parameter pack is called a *variadic template*.

共有两种参数包：**模板参数包**与**函数参数包**：

```cpp
template <typename T, typename... Args> // a template parameter packet
void foo(const T &t, const Args&... rest); // a function parameter packet
```

我们如何理解上边的语句？可以举例来想，**模板参数包**中将各种不同的可能出现的类型（`int, double, char* ...`）打包，之后把这个包交给函数，函数对包`Args`做**包扩展（`packet expansion`）**，传入的**每一种类型**都可能存在多个元素，比如`double a, double b...`，于是对每一种类型（即模板参数包中的每一个对应元素）打包、组合成一个名为`rest`的**函数参数包**。

> 需要注意的是，对于`class template`，参数包只能出现在最后一个参数的位置上。但是对于`function template`，参数包可以出现在任意位置上。

#### Packet expansion

在上一节中，提到了包扩展：*pattern…*，**扩展一个包就是将他分解为构成的元素，并对每个元素应用模式`pattern`**:

```cpp
template<class ...Us> void f(Us... pargs) {}
template<class ...Ts> void g(Ts... args) {
    f(&args...); // “&args...” is a pack expansion
                 // “&args” is its pattern
}
g(1, 0.2, "a"); // Ts... args expand to int E1, double E2, const char* E3
                // &args... expands to &E1, &E2, &E3
                // Us... pargs expand to int* E1, double* E2, const char** E3
```

包扩展可以出现在函数调用符`()`内部，根据[官方文档](https://en.cppreference.com/w/cpp/language/parameter_pack#Pack_expansion)：

```cpp
f(&args...); // expands to f(&E1, &E2, &E3)
f(n, ++args...); // expands to f(n, ++E1, ++E2, ++E3);
f(++args..., n); // expands to f(++E1, ++E2, ++E3, n);
f(const_cast<const Args*>(&args)...);
// f(const_cast<const E1*>(&X1), const_cast<const E2*>(&X2), const_cast<const E3*>(&X3))
f(h(args...) + args...); // expands to 
// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)
```

#### `sizeof...`

我们可以通过使用`sizeof...`得到包中参数的数目。

#### Performance

摘自：https://eli.thegreenplace.net/2014/variadic-templates-in-c/

> If you're concerned with the performance of code that relies on variadic templates, worry not. As there's no actual recursion involved, all we have is a sequence of function calls pre-generated at compile-time. This sequence is, in practice, fairly short (variadic calls with more than 5-6 arguments are rare). Since modern compilers are aggressively inlining code, it's likely to end up being compiled to machine code that has absolutely no function calls. What you end up with, actually, is not unlike loop unrolling.
>
> Compared to the C-style variadic functions, this is a marked win, because C-style variadic arguments have to be resolved at runtime. The `va_` macros are literally manipulating the runtime stack. Therefore, variadic templates are often a performance optimization for variadic functions.

