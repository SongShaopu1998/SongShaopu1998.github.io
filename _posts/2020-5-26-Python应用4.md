---
layout:		post
title:		Python应用
subtitle:	自由变量与闭包
date:		2020-5-26
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
    - Python
---

# 由lambda引发的自由变量与闭包讨论

在上次学完lambda之后，我偶然在[一篇博客](https://www.cnblogs.com/xiangnan/p/3900285.html)中看到了如下的示例：

```python
#---CASE 1

fs = map(lambda i:(lambda j: i*j),range(6))
print([f(2) for f in fs])

#---CASE 2

fs = [lambda j:i*j for i in range(6)]
print([f(2) for f in fs])

#---CASE 3

fs = []
for i in range(6):
    fs.append(lambda j:i*j)
    if i==3:
        break
print([f(2) for f in fs])

#---CASE 4

fs = [(lambda i:lambda j:i*j)(i) for i in range(6)]
print([f(2) for f in fs])

[0, 2, 4, 6, 8, 10]
[10, 10, 10, 10, 10, 10]
[6, 6, 6, 6]
[0, 2, 4, 6, 8, 10]
```

这个例子还是蛮有意思的，在上边的四种情况中，只有CASE1和CASE4能够得到我们想要的结果。这是为什么呢？

其实如果从上次对于lambda的讨论直接入手来看，我们大概能发现一些规律，CASE1和CASE4有一个共同的特点，就是最外层函数中定义的变量作为了第二层（第三层）的**参数**，但是CASE2与CASE3并不具备这个特定，我们来看下深层的原因是什么。

Python是一种解释型语言，在Python解释器开始执行后，在内存中开辟了一个空间，如果遇到变量，那就把变量名和值的对应关系记录下来；但是在遇到函数时，解释器把函数读入内存之后，函数的内部逻辑，解释器此时并不知情，我们拿CASE2举例：

变量**i**对于匿名函数lambda来说，就是我们所说的自由变量（先不给准确定义，自由变量在这里提到只是为了方便理解和简化书写），我们把这个lambda匿名函数定义为f​. [原博客](https://www.cnblogs.com/xiangnan/p/3900285.html)的分析十分到位，这里我们直接拿来用：

> **函数$f$**在定义时，解释器并没有把变量i和我们看到的对应的for循环中的值捆绑在一起，而只是明确了：在f​中，存在一个名为i的自由变量；
>
> 在函数f​被调用时，解释器会明确：
>
> 1. 空间上：f​要到**被定义时**的外层作用域查找自由变量i对应的对象，假设这个namespace为X.
> 2. 时间上: 是在你**当前运行时**, X 里面的 i 对应的对象

那么很显然，CASE2中的i所用的值都是5，因为调用的时候i值已经更新到了for循环中的最后一个。

但是对于CASE1和CASE4来讲，自由变量i不再是循环变量i，而是循环变量i所指对象在栈上的拷贝，由于每一次i所指对象都不相同，所以函数f​的自由变量自然而然地指向了不同对象；那么为什么会发生这种情况呢？在讲匿名函数lambda的那一篇中我们已经提到，这其实相当于在函数参数中给了一个默认参数(x=i)，由于默认参数的作用机制，**必须马上初始化默认参数**，自由变量被指向了不同的值。

形象化的定义这个过程，就出现了Python的**延迟绑定（迟绑定）**机制。啥叫迟绑定呢？那就是你以为他该绑定了，结果没绑定，绑定的晚了呗，这个论述的对象就是我们前边一直在说的**自由变量(free variable)**。

定义：

> If a name is bound in a block, it is a **local variable** of that block, unless declared as nonlocal. If a name is bound at the module level, it is a **global variable**. (The variables of the module code block are local and global.) If a variable is used in a code block but not defined there, it is a **free variable**.
>
> --Python doc.

用不太标准的语言去解释，就是在一个代码块内部被调用，然而却在不在本代码块内定义，就叫自由变量。

有了自由变量的概念，下边我们该看闭包了。

