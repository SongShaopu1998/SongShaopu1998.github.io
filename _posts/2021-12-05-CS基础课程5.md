---
layout:		post
title:		CS基础课程5
subtitle:	Berkeley CS 61C
date:		2021-12-05
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C
    - Computer Architecture (Machine Structures)
    - CS基础课程笔记
---

## Number representation

1. **进制转换表**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182043678.png" alt="image-20211206182043678" style="zoom:33%;" />

2. **Number representations**

共有五种表示方法，其中较为常用的，比较适用于计算机使用的方法有三种。

- `Unsigned`

这种方法即不带有符号的表示方法，是最简单的一种表示，当我们有五位可以用来表示数字的时候，无符号表示方法可以记录`0~31`的数字，但是接下来的有符号表示只能记录`-16~15`的区间了（因为最高位用以记录正负–没有免费午餐定理）。

- `Sign and Magnitude`

这种方法根据老师的描述，就是我们数电课程中学过的**原码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182536990.png" alt="image-20211206182536990" style="zoom:50%;" />

这种方法主要有两大缺点：

1. 零位重合
2. 正数与负数的计算方向是相反的（依上图）

- `One's Complement`

这种方法就是**反码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182709493.png" alt="image-20211206182709493" style="zoom:50%;" />

反码相比源码，虽然从负数到正数的计算方向保持了一致，但是仍然存在**零位重合**的问题。

- `Two's Complement`

这就是我们所说的**补码**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182913504.png" alt="image-20211206182913504" style="zoom:50%;" />

根据上图我们可以看出，补码完美的解决了先前方法存在的问题，`11111`这里不再是`-0`，而是`-1`了。公式：**补码=反码+1.（正数的反码与补码均是其本身）**

- `Bias Encoding`

这种编码方式常用于将一个`unsigned representation`转化成`signed`的形式（比如要把一段在$$x$$轴上方的正弦波抬到中轴处），我们通过给入程序一个`bias`为$$-(2^{N-1}-1)$$的数值来辅助实现这一变换，在进行了$$unsigned+bias$$的操作之后，他最终形成的表示范围（以$$N=5$$为例）是`-15~16`(与补码不同)！也就是说，原本的`00000`现在变成了最小的那一个**负数**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206184425110.png" alt="image-20211206184425110" style="zoom:50%;" />



在上述的众多方法中，我们常使用的是`unsigned`,`two's complement`,`bias encoding`.

3. **overflow**

在计算的过程中，可能会发生**溢出**的情况，那到底什么时候才算做溢出呢？当我们**舍弃掉最高位进位后，如果发现运算结果是错的，那就说明确实是溢出**了，一般来讲，我们使用**双高位判定法**来判断是否发生溢出：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206190532715.png" alt="image-20211206190532715" style="zoom:50%;" />

**当最高数据位向符号位进位不等于符号位进位时，即发生溢出！**

## C Programming

### Pointing to Different Size Objects

#### 32？64？

首先我们要有**存储单元**的概念，在现代的微型存储器中，一个**存储单元**是8个`bit`，也就是一个`byte`，换句话说：这些机器是`byte-addressable`的 – 微型存储器的容量是以`byte`为最小单位计算的。

需要注意的是，当我们谈论*32位机器*或者*64位机器*（`cpu`）时，我们所指的是它**一次能够处理的数据的长度**，也就是**寄存器的位数**，也被叫做**字长(`word length`)**，它和我们所说的**数据总线**，**地址总线**等没有*直接*关系。

**数据总线**的长度一般要**等于**`cpu`的**字长**，这是为了保证`cpu`的数据处理能力得到充分利用，所以我们可以说字长由[微处理器](https://baike.baidu.com/item/微处理器)对外数据通路的[数据总线](https://baike.baidu.com/item/数据总线)条数决定。同时，由于**指针**也是数据，所以地址在进行数据传送时会被匹配到同样的位数，但这不代表**地址总线**长度要和**字长**或者**数据总线**的长度一样，**地址总线**的长度由`cpu`自身设计决定，与`cpu`的位数没有直接关系，但由于**地址总线**决定了`cpu`的寻址能力，所以**地址总线**所能够支持的寻址一定要大于**数据总线**的位数，不论通过什么方法来实现这一要求。

#### word alignment

在实际使用时，我们常常会遇到**内存对齐**的说法，什么是内存对齐？为什么我们需要这样做？

比如对于一个32位的处理器，它一次能够处理数据的能力为`32 bits`，换算成内存单元就是`4 bytes`。`cpu`正是按照这个`4 bytes`的**块(`chunk`)**来读写内存的，块的大小被我们定义为**内存访问粒度**。

我们可以把内存想成一个无穷大的`array`，寻址从`0`位开始，我们的数据存储也正是从这个地址开始，如果**内存访问粒度**是`4 bytes`，那么`0`,`4`,`8`等等都是`aligned address`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207141611819.png" alt="image-20211207141611819" style="zoom:50%;" />

那如果我们的数据没有做到`word alignment`会发生什么后果呢？对于某些处理器而言，这会让它们进行多次的内存访存（**速度变慢**），分别访问每一个**内存单元**，读取其中需要的数据，最后再把多个单元读取到的数据进行`merge`，放到**寄存器**中。而对于某些`cpu`，则不会支持**非内存对齐**的数据存储形式，会直接产生报错。

#### some notice on pointers

这里还是记录一下关于**指针**的使用事项。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207200933346.png" alt="image-20211207200933346" style="zoom:50%;" />

上面的这幅图很好的包含了我们需要注意的关键点。首先我们可以看到：指针与整型均占4个`bytes`，之后我们声明了一个包含4个元素的整型数组，所以占据了28、32、36、40总共4个**内存单元**。

而在此之后，我们调用`malloc`函数，分配了一段内存，并让先前定义的指针`p`指向了这块我们刚刚分配的内存，但此时，这**段新分配的内存里边的值还是垃圾值**。相应的，指针`p`的值就变成了指向的那个地址，也就是40了！

> 我们一定要**先分配内存再使用内存**，如果在定义指针后没有使用`malloc`分配内存就直接`*p=1`，是不可以的。

最后，我们注意到对于数组`a`，`a`与`&a`的值是一样的，**不同于先前我们所定义的`变量`的表现！**这一点我们在*CS 106L*的课程笔记中也有提过，该课程的汇编部分会再次提到这一话题。

> 需要注意的是，数组名称**不可以被重新赋值**（`reassigned`），所以我们也不能对其进行`++a`的操作。这一点也是与指针有很大差异的一点.

- 此外，我们还要注意，在实际编程中，我们可能经常需要**向一个函数传递数组**，如果我们想在函数内部利用`sizeof`操作符获取数组大小，那么由于传入函数的是一个指针，我们只会得到指针的大小而非实际的数组大小–此时我们必须要向函数传递一个额外的`size`参数；当然，如果我们在处理一个**字符数组**，我们完全可以利用其`null terminator`的特征来定位整个数组。
- 在**C**中使用字符串（字符数组）时，末尾的`\0`在**ASCII**码中对应了**NUL**，即**ASCII**码中的**0**！所以我们在判定字符串是否到达末尾时，可以直接将`*str++*`作为判定条件，而无需和`\0`比较。我们需要注意，当使用字符数组来储存字符形成字符串时，我们需要手动添加一个`\0`，但是在使用`string literals`会自动添加，不需要我们手动操作.

### Memory locations

首先关于**声明**:

> - **Structure** declaration **does not** allocate memory.
> - **Variable** declaration **does** allocate memory.

在先前的**C++**课程中，其实也简短的[提到过](https://shaopu.tech/2021/11/07/CS%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B4/#globals--statics)，变量的生命周期（`storage duration`）有三种，我们形容为`static`,`automatic`,`dynamic`.分别对应着静态、全局变量；局部变量；动态分配内存的变量.

相应的，这三种不同的变量也被存储在不同类型的**内存池**中：

- **Static storage**:储存全局变量，生命周期为整个程序运行的时间
- **The Stack**: 储存**局部变量**、**函数参数**、**返回地址**
- **The heap**: 使用`malloc`动态分配的数据，直到`free`生命周期结束（这里的生命周期结束其实并非变量消失，后便会提到）

#### Memory management

在一个程序中，共有四种类型的**地址空间**，除了在上一小节中提到的三种内存池之外，还包括`code`段，他们的分布形式如下图所示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208000712193.png" alt="image-20211208000712193" style="zoom: 33%;" />

**从上至下**，**地址空间从最高一直到0**；与之相对应的，分别用以存储`stack`,`heap`,`static data`以及`code`:

- 当我们向`stack`中存入数据时，它会向下分配新的内存，而`heap`则是向上分配内存（我们不需要在这里考虑两个内存池发生重叠的问题，*CS 162*会介绍处理方法）.
- `static data`与`code`均是在程序运行过程中**不会发生改变**的内存区域，`code`主要用以存储运行需要的代码，在程序一开始即生成。

##### Stack

在上边我们提到，`stack`用于存储以下三种类型的数据：

1. `Return "instruction" address`
2. `Parameters`
3. `Space for other local variables`

`stack`区的内存分配是**连续**的。他有一个**栈指针**(`stack pointer`)，指向当前**栈顶**的位置（随着新开辟的栈区域不断地向下改变位置）：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208001902974.png" alt="image-20211208001902974" style="zoom:50%;" />

当我们结束了一个`procedure`时，栈内存被自动"释放"，之所以这里加了引号，是因为栈内存释放的方式与我们常理解的释放不同，**它在释放的过程中将栈指针不断上移到上一个还没有被释放的栈块的栈顶，而先前存放在已经被"释放"额区域内的数据，其实仍然保留在其中！**

栈内存的分配与释放都是**很快**的！

##### Heap

与栈不同，堆的内存分配**不是连续**的。两段看起来应当被分配在前后未知的动态内存，很可能彼此离得很远。相应地，**堆的内存分配和释放过程相比起栈是很慢的！**在使用堆时，我们想尽量避免碎片(`fragmentation`)化的出现：

> In this case, we might have many free bytes but not be able to satisfy a large request since the free bytes are not contiguous in memory.

那么堆内存的分配和释放等等过程究竟是如何实现的呢？

每一块堆内存的头部都有这样两组数据：

1. 该块的大小(`size of the block`)
2. 指向下一个块的指针(`a pointer to the next block`)–有点像指针

所有的**空内存块**被保存在一个**循环链表**中！（在一块已经被分配走的内存中，上述的`pointer field`是处于不被使用的状态）。

而函数`malloc`便会从这个**循环链表**中替我们寻找可用的内存，寻找的方法有这样几种：

1. `best-fit`:在循环链表中**选择满足大小要求的最小的内存块**
2. `first-fit`:**选择第一个满足大小要求的内存块**
3. `next-fit`:进行`first-fit`，但是记忆上一次搜索完的位置，下一次从此处继续搜索可用内存

而相对应地，`free`函数在将指针指向的内存块释放后会**检查前后的内存区域是否也是空内存块**，

- 如果是，则将几段内存`merge`;
- 如果不是，则将刚**被释放的内存加入循环链表中**

#### When memory goes bad

在课程中，提到了几种应当避免出现的内存分配和释放问题，这里说几个：

- <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208004619281.png" alt="image-20211208004619281" style="zoom:50%;" />

这个情况其实很`tricky`，观察结果我们发现，第一次使用`content`和第二次的结果不一样，why？

注意到这里**我们把指向栈内数据的指针作为了函数返回值**，当栈内存被释放后，根据前边的描述，其中的数据其实并没有被抹掉，所以我们仍能够通过返回的指针`stackAddr`获取原先的数据，所以第一个`printf`没有问题。

但是`printf`也是一个函数，也被分配到了**栈**上，由于栈内存是连续分配的，他恰好占用了原本数据`y`的位置，导致`y`被毁掉了–这就导致第二次我们再次尝试获取`y`的数据时，指针把我们带到了垃圾值上！

- `Realloc`

`Realloc`函数也是可能诱发内存分配问题的：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208005401436.png" alt="image-20211208005401436" style="zoom:50%;" />

在使用`realloc`时，如果程序发现接下来的空**堆内存块不够扩展到指定大小，他会将原来的数据一起搬运到新的能够存放整体大小的内存块上**！这就导致我们原本指向`foo`的指针`g`现在不可用了。

- `calloc`

除了`malloc`和`realloc`外，我们还有一个`calloc`函数，可以避免我们忘记了初始化刚分配的内存空间的问题：

```c
// define a n*m matrix of int
int **mat = (int **)calloc(n, sizeof(int *));
for (int i = 0; i < n; ++i) {
    mat[i] = (int *)calloc(m, sizeof(int));
}
```

需要注意的是，该函数可以直接给出初始化的**空间+初始化值**–**0**（真正意义上的**0**，比如*NULL*或者数值的0之类的…）



几种会出现`segfault`的情况：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211213235209723.png" alt="image-20211213235209723" style="zoom: 33%;" />

#### some notice on memory menagement

- 对于程序中定义的**常数(`constants`)**,它可能存放的位置有：

1. Code段：`x=x+1`,其中`1`在编译阶段直接被存储到`machine instruction`中，以及`#define y 5`时
2. static段：全局变量：`const int x = 1`中的`1`
3. stack段：将常量定义在函数中：`int total = 1`

- 此外，`string literals`被存放在`static`段中，具体可见[这里](https://shaopu.tech/2021/11/07/CS%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B4/#storage-duration).

- 与**C++**不同的是，**C**中没有*引用*的说法，所以当我们在对一些数据结构比如链表进行内存的分配和释放时，我们不能够传递指针的引用，需要传递指针的指针.

### Stream

这里主要说一下关于**C**中的**流**这一概念，以及之前我一直没懂的`FILE`这个对象。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211210194228562.png" alt="image-20211210194228562" style="zoom: 33%;" />

其中，`stdin`是输入**流**，因为在`linux`中一切皆文件，所以他也是标准**输入文件**。同理，`stdout`是输出**流**–标准**输出文件**。

我们也可以这样理解：**linux**通过**文件**的形式实现了输入/输出流，文件们分别对应着不同的**文件描述符**，每当我们打开`文件`（也是**广义**的！）时，就有一个代表着该打开文件的**文件描述符**，程序启动时默认打开三个`I/O`设备文件：标准输入文件`stdin`，标准输出文件`stdout`，标准错误输出文件`stderr`，分别得到文件描述符 `0`, `1`, `2`:

> **[文件描述符](https://segmentfault.com/a/1190000009724931)**在形式上是一个非负整数。实际上，它是一个**索引值**，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开.

在*Stanford CS 106L*最开始的笔记章节中，我们对`stream`对象做了很多的分析，有了初步的了解。`stdin`默认从键盘接收输入，`stdout`默认将内容输出到屏幕上，但这不是它们唯一可行的路径和流入（出）方式，比如读入/写入文件当中，我们可以使用`redirection`（[重定向](http://c.biancheng.net/view/942.html)）的方法改变其输入/输出的对象.

> `</>`重定向在使用`gdb`调试时也可使用

需要注意的是，我们经常使用的`FILE`和我们日常所说的狭义的*文件*没有任何关系！根据**C++**官方文档：

> **Object containing information to control a stream**
>
> Object type that **identifies a stream and contains the information needed to control it**, including a pointer to its buffer, its position indicator and all its state indicators.

换句话说，他可以用来表示一个`stream`对象。这也是为什么我们在函数`fgetc(FILE *stream)`中，可以使用`fgetc(stdin)`的原因。

### Bit operation

在*Fa 2021 lab 02*中，我们需要解决三个位操作的函数，查看[Github仓库](https://github.com/SongShaopu1998/Berkeley-CS-61C/blob/main/labs/fa21-lab-starter-main/lab02/bit_ops.c)。分别为：

- 获取某位
- 改变某位
- 翻转(`flip`)某位

在后两种操作中，我们需要注意的是使用一个所有位均为`1`的参考值辅助操作，同时将原本的二进制数分为前后两个部分加以处理（`flip`）可以将需要`flip`的位单独拿出来，最后使用`|`合并.

## Floating Point

这一节来处理浮点数.

### Basic Representation

首先，我们如何把一个二进制浮点数计算成我们习惯的十进制的样子？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211175738895.png" alt="image-20211211175738895" style="zoom:50%;" />

为什么叫`floating point`?这是因为在一开始，我们思考的储存方式是**固定小数点的位置**，这种方法被称为`fixed point`，而与之相对应地`floating point`则是允许小数点在数字之间移动–这种表示模式允许我们记录**更大范围的数字**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182809936.png" alt="image-20211211182809936" style="zoom:50%;" />

为了表示一个`floating point`，我们的基本思路是用一段`bits`表示**需要记录的数字部分**，再用另一段`bits`表示**小数点所在的位置**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182739063.png" alt="image-20211211182739063" style="zoom:50%;" />

按照如上的思想，我们需要将浮点数在内存中用如下方式表示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182857518.png" alt="image-20211211182857518" style="zoom:50%;" />

`float`共使用`32`bits记录，其中，浮点数本身的最前边的`1`我们**不在这里单独记录**–因为除了`0`，其他的任何一个浮点数按照**科学计数法（`Normalization`）**的模式，都需要有一个`1`在前边。（后边我们会看到，即使是`0`，我们也有办法在不使用这个开头的数字的前提下表示出来！）

`float`(*Single Precision*)的储存形式整体上分为三个部分：

1. `Sign bit`-1 bit
2. `Exponent bits`-8 bits(对于`double`为`11 bits`)
3. `Signtificand bits`-23 bits(对于`double`(*Double Precision*),为`52 bits`)

我们可以先对这种表示模式进行一下思考：其中的`Exponent`部分应当使用一种类似于`Two's complement`的表示方法，因为我们需要最终表示形式的指数部分**可正可负**。`Significand`部分则是直接存储了二进制浮点数小数点后的二进制数字序列。

但是使用`Two's Complement`的一个问题在于，当机器上不存在**用于浮点数比较的硬件（如早期的计算机）时，我们无法直接通过整数比较的方法来比较浮点数**，并且，即使存在用于浮点数比较的硬件，浮点数比较的过程也是远远慢于整数比较的！

当我们使用`Two's Complement`来表示`Exponent`时，当`Ex`**所记录的整数**越大，我们并不能够得出对应的`float`越大的结论（在其他部分相同的前提下）– 当`Ex`从`00...0`到`11...1`，实际的`Exponent`值，在此时也可以用于表示实际的浮点数值会从`0~+MAX`，再到`-MAX~0`变化！

于是我们想到了`Bias Encoding/Notation`!在这种表示模式下，`Ex`所代表的整数的变化趋势与实际值的变化趋势是完全一致的，所以对于`float`，我们使用`bias=-127`，相对应地，`double`中`bias=-1023`. 

这样一来，我们的比较过程可以设计为：

1. `sort the sign field by just +/-`
2. `sort by more significant exponent`
3. `If Exponent the same, using mantissa sorting`

于是，以`float32`为例，最终我们的计算公式为：



$$(-1)^S\times (1+significand)\times 2^{(Exponent - 127)}$$



同时，显然，这种表示方法对于数字范围是存在限制的，这意味着我们会遇到`overflow`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211184944361.png" alt="image-20211211184944361" style="zoom:50%;" />

### Special Numbers

#### ∞

在浮点数的表示方法中，我们可以表示一些特殊数字，比如首先我们会想到表示正/负无穷。那么**IEEE 754**是如何表示∞的呢？

- **Most positive exponent** reserved for ∞
- **Significands all zeros**

也就是说，当我们从`1111110|11...1`再加一个1，就变成`∞`了！如果`sign bit`为1，那么就是`-∞`.

#### 0

其实严格意义上来讲，0并不能算作`special number`，因为他的表示与一般的方法是一样的，需要注意的是，在浮点数中，有一个`+0`，也有一个`-0`，从数学意义上来说，这两个0并非真正的0，而是指的从两个方向无限趋近于真正的**0**。他们都是合理的：



**+0: 0 00000000 00000000000000000000000**
**-0: 1 00000000 00000000000000000000000**

如此一来，我们用`significand`和`Exponent`均为`0`的方法来表示数字`0`（或者说数字0和这种表示方法是等价的）–>这允许我们不使用整数部分的数字，也能够表示0了.

所以我们在偌大的浮点数数字范围中，还有哪些区域的数字表示没有被使用？我们还需要表示那些特殊数字？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211202701559.png" alt="image-20211211202701559" style="zoom:50%;" />

根据上图，我们还有两个数字区域没有使用，分别是`Exponent`为0以及255，且`significand`(小数部分)不为0的情况.

> 为什么我们把正常数字的`Exponent`范围限制到`1-254`?这是因为我们刻意为`special numbers`保留了范围.

#### NaN

我们使用`Exponent`为**255**，`Significand`**不为0**的情况，来表示所谓的**NaN**(**Not-a-Number**).也即是说，当我们从`inf`再往前走一步，就回到了`Nan sea`.

那么NaN有什么用呢？

- 可以提供`debug`讯息
- op(NaN, X)=NaN

需要注意的是，NaN与任何东西比较的结果都是`false`，并且`NaN != NaN`.

#### Denorms

首先，什么是`normalization`? 通俗地讲，`normalization`就是将一个数字表示成科学计数法的`1`打头的表示，那么如果我们想把开头的数字搞成`0`而非`1`，这就叫`denorm`.

对于浮点数，我们当然希望它的**尺度**是均衡的，换句话说，我们希望在一段范围内，浮点数之间的距离是恒定的.

我们来计算一下现在的情况是否满足这一条款：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211215921254.png" alt="image-20211211215921254" style="zoom:50%;" />

显然，从0到a的距离…实在是相比起来有点太大了…

所以我们怎么解决这个巨大的`gap`的问题？奔着制造一个尺度均衡分布的数字范围的目标，我们利用还没有被分配任务的`Exponent`为0，且`significand`不为0的范围，提出`DEnormalizaed number`:

**No leading 1, implicit exponent = -126 (rather than -127)**

如此一来：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211221234402.png" alt="image-20211211221234402" style="zoom:50%;" />

需要注意的是，随着`Exponent`部分的变化，我们在`significand`的每一段的尺度也会发生变化，在最开始时每一段的间隔为$$2^{-149}$$，当`Exponent`加1之后，`significand`的间隔会变为$$2^{-149}\times 2$$. 换句话说：

> Exponent tells Significand how much (2^i) to count by (..., 1/4, 1/2, 1, 2, ...).

当存储内部的`Exponent`为150时，`significand`的间隔会变为1（$$2^{(150-127)}\times 2^{-23}=1$$）



最终，我们得到了完整的浮点数表示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211221437771.png" alt="image-20211211221437771" style="zoom:50%;" />

> 当我们试图从`00...0`一直加到`11...1`时，浮点数的大小变化范围和我们先前提到的`Sign and magnitude`（**原码**）一致！

#### Attributes

首先，浮点数运算不具备**关联性**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211230807221.png" alt="image-20211211230807221" style="zoom:50%;" />

其次，正如我们在写程序中经常遇到的，浮点数存在`rounding`这一机制，通常，浮点数硬件带有额外的两个`bit`，之后使用`rounding`机制将浮点数表示为合适的值。`rounding`发生在将`double`转为`float`时，也发生在将`float`转为`int`时：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211232700680.png" alt="image-20211211232700680" style="zoom:50%;" />

需要注意的是，当浮点数恰好位于`rounding`的分界线上时，我们将浮点数`rounding`到**偶数**上。

再者，浮点数的**加法运算**并不像整数的加法运算那样简单，我们可能先需要将浮点数`denormalize`，以匹配其指数部分，在完成`significands`的加法运算后，再将结果`normalize`.

我们可以使用**强制转换**机制，这一机制在内部通过`rounding`来实现。需要注意的是，由于浮点数尺度的问题，它并不能表示某些整数！所以：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211233056007.png" alt="image-20211211233056007" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211233254194.png" alt="image-20211211233254194" style="zoom:50%;" />



除了上述的`float`以及`double`之外，还有其他一些表示方式：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211212000057633.png" alt="image-20211212000057633" style="zoom:50%;" />

特别的是，由于机器学习并不需要太高的精度要求，`bfloat16`类型被使用在ML中，它牺牲了一部分`significand`空间以换取更大的范围（`Exponent`）.

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211212000317259.png" alt="image-20211212000317259" style="zoom:50%;" />

特别的是，有一种观点提出，我们可以对`float point`做进一步优化，使得`Exponent`和`Significant`的长度都可以变化，以适应不同的场景。同时，携带一个`u-bit`来表示这个浮点数是否经过了`rounding`.换而言之，他是一个准确的值还是一个估计值。

## RISC-V Instructions

汇编语言的操作数(`operand`)是**寄存器(`register`)**!

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211214232809988.png" alt="image-20211214232809988" style="zoom:50%;" />

在**RISC-V**中，共有**32**个寄存器，其中`x0`是最特殊的，他始终保有`0`值！这意味着我们只允许使用其他31个寄存器来存储变量！

关于**RISC-V**的几个基本的操作，如`add`,`addi`,`sub`这里不详述.

### storing data in memory

我们首先要知道CPU与内存交互的两种基本模式：

1. **Write** Data – Store **To Memory**
2. **Read** Data – Load **from Memory**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216122249838.png" alt="image-20211216122249838" style="zoom:50%;" />

其次，在`word alignment`的一节我们已经提到过，一个`8bit`的块被称为`byte`，是一个微型存储单元（`byte-addressable`）。字(`word`)在`32`位CPU中，是`4 bytes`，内存读取按照`word`读取（**内存访问粒度**）……(参见原章节)

那么每一个`word`在内存中是以什么样的格式存储的呢？在这里，我们的存储方式为**Little-endian convention**:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216123319753.png" alt="image-20211216123319753" style="zoom: 33%;" />

> Word address is same as address of rightmost byte – least-significant byte.

也就是说，`word`中最低的那一个`byte`被安排在了最小的地址上。与之相对的是**Big-endian convention**:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216124545397.png" alt="image-20211216124545397" style="zoom:50%;" />

需要注意的是，无论是哪一种`bytes`的存储方式，其中`bits`的存储方式是不变的.

### Data Transfer Instructions

在**RISC-V**中，一个寄存器为4bytes，共有32个寄存器，也就是128bytes。而相对应的`Memory`有2GB-64GB，这也意味着寄存器一定要比内存（`DRAM`）更快，大概是它的50~500倍。所以我们更想让指令(`Instructions`)在寄存器中被操作，而不是直接在内存中操作–这就需要内存与寄存器的双向数据交互。

- <u>Load word from</u> Memory to Register

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216161325926.png" alt="image-20211216161325926" style="zoom: 33%;" />

**lw**这个语句的含义是将储存在`x15`中的`base pointer`的值加上`12bytes`的地址里储存的内容，即`A[3]`复制到x10中. 与之相对应地，是从寄存器向内存中储存内容的**sw**：

- <u>Store word from</u> Register to Memory

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216161736950.png" alt="image-20211216161736950" style="zoom:33%;" />

除了对于`word`存取的操作指令外，我们还可以直接对`Bytes`进行操作：

- Loading and Storing Bytes

分别于**lw**,**sw**相对应地：

- **lb**
- **sb**

E.g.

```assembly
lb x10,3(x11)
```

该指令将指针指向的内容**复制**到寄存器`x10`的`low byte position`.

#### Sign-extend

**sign-extend**的意义在于保证一个有符号数字(可能不到32bits)在被储存进寄存器(32bits)时仍然保证是一个有符号数字：

> 如果在前边所有的高位里都存储**0**，那么对于这个寄存器内的32位数字来说，就始终是一个`positive number`了.

所以，在**lb**中采用了如下方法：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216164345305.png" alt="image-20211216164345305" style="zoom:50%;" />

需要注意的是，在**sb**中没有`sign-extend`的说法，我们只需要将寄存器中的内容取出来就好，`sign-extend`在**sb**中没有意义。

> RISC-V也有一种储存`unsigned byte`的方法：**lbu**，顾名思义，是使用`zero extend`的方法来填充寄存器.

#### Why need addi?

我们发现，这两种写法具有相同的效果：

```assembly
// first
lw x10,12(x5)
add x12,x12,x10

// second
addi x12, value
```

那为什么我们需要`addi`这个指令呢？（RISC-V提出了最小指令集的要求）这是因为第一种写法要求从`memory`加载数据，这一操作相对较慢，而直接使用`immediate value`可以利用寄存器序列中的`temporary`(专门用于存储临时值的寄存器)来实现运算.

### Decision Making

什么是`Decision Making`?就是我们在高级语言中常用的`if`判断等.

#### Conditional Branch

1. `beq reg1, reg2, L1`

> L1 branch if reg1 == reg2

2. `bne reg1, reg2, L1`

> L1 branch if reg1 != reg2

3. `bge reg1, reg2, L1`

> L1 branch if reg1 >= reg2

4. `blt reg1, reg2, L1`

> L1 branch if reg1 < reg2

5. **unsigned version**–`bltu`, `bgeu`

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216173548887.png" alt="image-20211216173548887" style="zoom:50%;" />

#### Unconditional branch

- `j Label`(`jump Label`)

#### Loop

书写循环的关键在于使用**Conditional branch**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216173706372.png" alt="image-20211216173706372" style="zoom:50%;" />

### Logical instructions

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216182826110.png" alt="image-20211216182826110" style="zoom:50%;" />

- and-andi(`andi x5, x6, 3`)
- sll-slli(`slli x11, x12, 2`)
- srl-srli(`Right shifting`)
- …

- 不存在**NOT**这一指令的，因为我们可以使用`xor 1111111`。
- **Arithmetic Shifting**

又名**Shift right arithmetic**: `sra-srai`，应用于**signed numbers**。这两条指令使用**sign bit**填充右移需要的位。这一操作看起来像是将原本的数除以2，但事实并非如此。这是因为**C语言要求`round towards zero`**.

### A bit about Machine Program

我们的高级语言程序在经过处理之后成为汇编指令(Instructions)，储存在`memory`中：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216190734553.png" alt="image-20211216190734553" style="zoom:50%;" />

那么程序是如何被执行的呢？

从宏观上讲，当然是通过CPU与内存的交互–CPU从内存中读取指令+数据，之后将数据写入内存。

进一步分析，是CPU的**Control Unit**（控制器）读取指令，控制CPU中**Datapath**（运算器）里的寄存器们，并由CPU内部的**PC(Program Counter)**寄存器记录**需要执行的指令的`byte address`**（update PC）实现的：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216191436104.png" alt="image-20211216191436104" style="zoom:50%;" />

### Helpful Assembler Features

1. Symbolic register names

- **a0-a7 (x10-x17)**: eight *<u>argument</u>* registers to pass parameters & two *<u>return values</u>* (**a0-a1**)
- **ra (x1)**: one *<u>return address</u>* register to return to the point of origin
- **s0-s1(x8-x9), s2-s11(x18-x27)**: saved registers
- …(More)

2. Pseudo-instructions

- **mv rd, rs(addi rd, rs, 0)**(actually copy)
- **li rd, 13(addi rd, x0, 13)**
- **nop(addi x0, x0, 0)**

### Function calls (single/nested)

在RISC-V中的函数调用需要经过哪些步骤？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216202401580.png" alt="image-20211216202401580" style="zoom:50%;" />

需要注意的是，对于RISC-V，所有的指令都是`4 bytes`，被存储在`memory`中，就如同**data**一样.

我们以一段程序为例，展示这一过程：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216202608172.png" alt="image-20211216202608172" style="zoom:50%;" />

在函数调用之前，我们先要将被储存在`saved register`中的两个变量a, b放入用于储存函数参数的寄存器**a0**与**a1**中。（如果此时这几个寄存器的容量不足以存储函数参数，那么需要借助`stack`，这个后边会提到）。在函数执行时，我们把结果（`return value`）放到寄存器**a0**中。

之后我们需要把函数调用结束后需要返回的位置存储在寄存器**ra**中(**link**)，再跳转到函数的位置执行函数代码（相当于把控制权交给函数）(**jump**)。

当函数调用结束后，我们通过`jr ra`的指令返回储存的需要跳转回的位置。之所以不在这里使用`j label`的指令，是因为**函数可能在程序中被多次在不同位置调用，所以我们需要把跳转回的位置储存在一个变量中**（该语句也是函数代码的一部分）

#### jump in Function calls

在上述函数调用的过程中，我们首先将`return address`储存在寄存器**ra**中，之后使用**j**指令跳转，这两条指令可以合并为一句（**jump and link**）:

```assembly
jal sum # ra=1012, goto sum
```

> 这也是一个pseudo-instruction，真正的指令为**jump-and-link**：
>
> ```assembly
> jal x1, sum
> ```

与之类似的，**jr**也是一个`pseudo-instruction`，对应的`base-instruction`为**jump-and-link register**：

```assembly
jalr rd, rs, imm
```

指令**jr ra**还可以缩写为**ret**。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216214513552.png" alt="image-20211216214513552" style="zoom:50%;" />

#### Nested Calls & Register Conventions

在写出具体的解决方案之前，我们先来思考如下的案例：

```C
int leaf(int g, int h, int i, int j) {
    int f;
    f = (g + h) - (i + j);
    return f;
}
```

我们需要用到寄存器**a0, a1, a2, a3**来储存函数参数与函数返回值，同时**s0, s1**这两个`saved register`被用来存储我们的`local variables`.

那么问题来了，既然我们需要用到这么多寄存器？那原本存储在寄存器中的值怎么办？直接毁掉（`clobber`）吗？当然不是，我们需要保存原本储存在寄存器中的值–借助`stack`来实现：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216220928653.png" alt="image-20211216220928653" style="zoom:50%;" />

在有的汇编语言指令集中，是有**push**和**pop**这两个指令的，但是RISC-V没有，所以需要我们自己去实现它。

复习一下先前关于**stack**的知识：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216221114317.png" alt="image-20211216221114317" style="zoom:50%;" />

举个例子，对于函数`leaf`，编译后是这样:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216221340465.png" alt="image-20211216221340465" style="zoom:50%;" />

可以看到，在函数最开始我们调整栈顶指针的位置，开辟新的栈空间，同时将寄存器**s0**,**s1**存入刚开辟的栈空间内。在程序结束之后，恢复寄存器的内容，并释放栈空间。这前后两段操作分别被称为**prologue**与**epilogue**。

那么问题来了，如果我们面对的是**嵌套函数调用**，怎么办？哪些寄存器里的内容应当暂时被放到栈内保存？（因为要考虑用于存储函数参数与函数返回地址的寄存器的内容了）

```c
int sumSquare(int x, int y) {
    return mult(x,x)+ y;
}
```

一个与嵌套函数调用相关的是在RISC-V中使用递归，我写了一个递归版本的斐波那契，在我的[Github仓库](https://github.com/SongShaopu1998/RISC-V-Recursive-Fibonacci/blob/main/fib.s)中。在课程提供的**lab3**中，也有几个递归调用的例子。

#### Register Conventions

区分**caller**与**callee**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216222800860.png" alt="image-20211216222800860" style="zoom:50%;" />

**caller**表示调用函数的那个“人”，**callee**表示被调用的函数。根据`register convention`，我们将寄存器分为这两大类：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216223552640.png" alt="image-20211216223552640" style="zoom:50%;" />

对于第一类，**caller**假定这几个寄存器中的内容在函数调用的过程中**不会发生改变**–所以如果内容有改变，那这是**callee**应该负责的事情；

而与之相对应地，**caller**不能够认为第二类寄存器里的内容在函数调用的过程中不发生改变–所以如果内容需要改变，**caller**应当首先把这些个寄存器中的内容**push**到栈中。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216224149786.png" alt="image-20211216224149786" style="zoom:50%;" />

### Memory Allocation

一个问题，如果寄存器的空间**不够**储存一个**局部变量**咋办？



使用**栈**解决问题！

> **Procedure frame** or **activation record**: segment of stack with saved registers and local variables.

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216224612879.png" alt="image-20211216224612879" style="zoom:50%;" />

当我们想在栈内分配新空间时，就将栈指针**减去**需要的内存大小！

所以，对于之前的嵌套函数调用，RISC-V代码如下（包含了**push**与**pop**的过程）：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216224850731.png" alt="image-20211216224850731" style="zoom:50%;" />

代码也符合上图我们`Procedure frame`中分配的顺序：首先储存**ra**，之后储存**a1**，即函数参数。在函数调用结束后，**pop**栈内存，恢复寄存器内容。

在调用`SumSquare`之前，我们要先把它需要的两个参数储存到正确的寄存器-**a0 & a1**中，之后我们使用上边的代码调用该函数–因为需要嵌套函数调用，我们要开辟一个栈空间来存储可能改变的寄存器。接下来，我们开始对内部函数的调用做些准备–比如把参数存放到指定的寄存器里。

在调用函数结束之后，恢复栈内存与寄存器内容，并把控制权转移给上一级函数（`jr ra`）.

> 我们不要把**jal**指令默认成函数调用的唯一方式，我们之所以使用**jal**来调用函数，是因为函数的调用通常通过给入一个**label**的方式来实现（在内部其实是通过程序自动计算`PC-relative offset`来完成指定函数调用）。
>
> 但是，**jalr**其实也是可以调用函数的，他调用函数的方式一般是通过`absolute address`而不是`PC-relative address`实现。我们把一个地址存放到某个寄存器中，然后把它交给**jalr**指令。

#### Stack/Heap/Static/Code

这里列出他们在**RISC-V32**中的储存位置：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216225700500.png" alt="image-20211216225700500" style="zoom:50%;" />

> - **PC**段存储了系统运行的关键信息
> - Stack must be aligned on 16-byte boundary **here**
> - RISC-V convention global pointer (**gp**) points to static

## Instruction formats

现在需要解决的问题是，机器是如何理解我们写出的汇编代码的？或者说，前边所述的这些汇编代码对应的二进制表示是什么？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221181146759.png" alt="image-20211221181146759" style="zoom:50%;" />

-  **Everything Has a Memory Address**

在介绍他们的二进制表示之前，我们首先要清楚，这些指令(`Instruction`)是如何被机器执行的。我们知道，无论是**指令**还是**数据**，都是存放在内存(`memory`)区域的，并对应着不同的地址(`address`)。而前边我们提到过，需要执行的指令的地址是保存在**PC(`Program Counter`)**中的：

> - Basically a pointer to memory
> - Intel calls it Instruction Pointer (IP)

我们正是通过不断更新**PC**的值，来告诉机器我们将要执行的指令在哪里。

- **Binary Compatibility**

另一方面，由于产品需要不断的更新迭代，当时我们不想在每一次更新迭代产品之后都需要重新为原本的软件和应用准备一套新的二进制代码表示，或者说我们想要在新的机器上运行旧的程序，这就需要指令集具备**backward-compatible**的特征。



在正式开始介绍之前，我们需要知道：无论是**RV32**,**RV64**还是**RV128**，他们使用的都是`32-bit`的指令集。

### Different Instruction formats

为了让机器明白我们的汇编代码包含哪些信息，需要执行哪些功能，我们将这个`32-bit`的指令分成了很多个`field`.

根据`field`被划分的不同的格式，指令被分为如下六种：

- **R-format** for **register-register** arithmetic operations
- **I-format** for **register-immediate** arithmetic operations and loads
- **S-format** for **stores**
- **B-format** for **branches** (minor variant of S-format)
- **U-format** for **20-bit upper immediate** instructions
- **J-format** for **jumps** (minor variant of U-format)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221191847346.png" alt="image-20211221191847346" style="zoom:50%;" />

观察上图我们可以发现，所有需要的**寄存器**或者是**立即数**，基本都被存放在同一段位置，这是为了方便电脑进行查找与运算。正是为了这一特性，可以看到，可能一个**立即数**被分成了几段来存放。

- 其中，`opcode`指定了这几个不同的指令类型–在同一类指令中，它们将永远一样。
- 由于我们总共有32个寄存器，所以我们需要使用5 bits来表示使用的寄存器。
- `funct`帮助我们确定同一类指令中的具体指令。

#### R-Format

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221195051110.png" alt="image-20211221195051110" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221192903460.png" alt="image-20211221192903460" style="zoom:50%;" />

> **slt**: set-less-than (`rd = (rs1 < rs2) ? 1 : 0`)

同时我们注意到，在**R-Format**中的`funct7`段，指令`sub`与`sra`的次高位是1–这表示，**它们的操作需要进行`sign extension`**.

#### I-Format

之所以要单独出现一个立即数格式，是因为汇编指令在将立即数指令转化为二进制代码时，是需要**将立即数编入二进制代码的**。而如果我们直接将**R-Format**中的`rd`段作为立即数使用，很明显，我们只能表示一个极为有限的立即数范围。所以我们需要一种新的指令格式。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221195115381.png" alt="image-20211221195115381" style="zoom:50%;" />

需要注意的是，立即数被在算术运算中使用时，需要**sign-extend**到`32 bits`.

另一方面，由于这里用于表示具体指令的段只有`funct3`这一个，而我们总共需要表示9种**I-Format**指令，我们需要使用一种特殊技巧：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221203437919.png" alt="image-20211221203437919" style="zoom:50%;" />

因为对于32位寄存器而言，我们再进行**移位操作**时最多移动$$2^5$$位，所以我们不需要使用12位来表示这里的立即数，从而，如同**R-Format**所述，我们可以利用次高位表示是否进行**sign-extend**.

#### Loads(also I-type)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221210750463.png" alt="image-20211221210750463" style="zoom:50%;" />

12位的立即数（`offset`）被加到`base register`，`rs1`中存储的地址中，得到新的地址，并放入`dest register`内。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221212354952.png" alt="image-20211221212354952" style="zoom:50%;" />

需要注意的是，**load**指令的`opcode`与`i-type`中的不同。在这里，我们引入了一个新的指令`lh`与`lhu`，传入一个`2 bytes`的数据，之后将其`(un)sign extend`到`32 bits`.

#### S-Format

这种指令格式是给存储指令设计的：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221214234345.png" alt="image-20211221214234345" style="zoom:50%;" />

在格式上类似于**R-Format**，但是存储指令不向寄存器内部写数据，而是像内存写数据。这种将立即数分段设计的原因我们在先前提到过，是为了保证机器查找寄存器未知的方便。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211221214834695.png" alt="image-20211221214834695" style="zoom:50%;" />

#### B-Format

这种格式应用于**条件跳转**指令。`branches`常被用于**循环**中（while, for, if-else）.这一类循环通常间隔的指令较少，如果我们需要跳转到一个很远的地方，那么此时我们可能需要`jump instructions(J-Format)`.

而由于指令的地址被存放在`Program Counter`中，
