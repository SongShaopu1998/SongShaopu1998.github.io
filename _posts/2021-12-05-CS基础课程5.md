---
layout:		post
title:		CS基础课程5
subtitle:	Berkeley CS 61C
date:		2021-12-05
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C
    - Computer Architecture (Machine Structures)
    - CS基础课程笔记
---

## Number representation

1. **进制转换表**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182043678.png" alt="image-20211206182043678" style="zoom:33%;" />

2. **Number representations**

共有五种表示方法，其中较为常用的，比较适用于计算机使用的方法有三种。

- `Unsigned`

这种方法即不带有符号的表示方法，是最简单的一种表示，当我们有五位可以用来表示数字的时候，无符号表示方法可以记录`0~31`的数字，但是接下来的有符号表示只能记录`-16~15`的区间了（因为最高位用以记录正负–没有免费午餐定理）。

- `Sign and Magnitude`

这种方法根据老师的描述，就是我们数电课程中学过的**原码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182536990.png" alt="image-20211206182536990" style="zoom:50%;" />

这种方法主要有两大缺点：

1. 零位重合
2. 正数与负数的计算方向是相反的（依上图）

- `One's Complement`

这种方法就是**反码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182709493.png" alt="image-20211206182709493" style="zoom:50%;" />

反码相比源码，虽然从负数到正数的计算方向保持了一致，但是仍然存在**零位重合**的问题。

- `Two's Complement`

这就是我们所说的**补码**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182913504.png" alt="image-20211206182913504" style="zoom:50%;" />

根据上图我们可以看出，补码完美的解决了先前方法存在的问题，`11111`这里不再是`-0`，而是`-1`了。公式：**补码=反码+1.（正数的反码与补码均是其本身）**

- `Bias Encoding`

这种编码方式常用于将一个`unsigned representation`转化成`signed`的形式（比如要把一段在$$x$$轴上方的正弦波抬到中轴处），我们通过给入程序一个`bias`为$$-(2^{N-1}-1)$$的数值来辅助实现这一变换，在进行了$$unsigned+bias$$的操作之后，他最终形成的表示范围（以$$N=5$$为例）是`-15~16`(与补码不同)！也就是说，原本的`00000`现在变成了最小的那一个**负数**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206184425110.png" alt="image-20211206184425110" style="zoom:50%;" />



在上述的众多方法中，我们常使用的是`unsigned`,`two's complement`,`bias encoding`.

3. **overflow**

在计算的过程中，可能会发生**溢出**的情况，那到底什么时候才算做溢出呢？当我们**舍弃掉最高位进位后，如果发现运算结果是错的，那就说明确实是溢出**了，一般来讲，我们使用**双高位判定法**来判断是否发生溢出：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206190532715.png" alt="image-20211206190532715" style="zoom:50%;" />

**当最高数据位向符号位进位不等于符号位进位时，即发生溢出！**

## C Programming

### Pointing to Different Size Objects

#### 32？64？

首先我们要有**存储单元**的概念，在现代的微型存储器中，一个**存储单元**是8个`bit`，也就是一个`byte`，换句话说：这些机器是`byte-addressable`的 – 微型存储器的容量是以`byte`为最小单位计算的。

需要注意的是，当我们谈论*32位机器*或者*64位机器*（`cpu`）时，我们所指的是它**一次能够处理的数据的长度**，也就是**寄存器的位数**，也被叫做**字长(`word length`)**，它和我们所说的**数据总线**，**地址总线**等没有*直接*关系。

**数据总线**的长度一般要**等于**`cpu`的**字长**，这是为了保证`cpu`的数据处理能力得到充分利用，所以我们可以说字长由[微处理器](https://baike.baidu.com/item/微处理器)对外数据通路的[数据总线](https://baike.baidu.com/item/数据总线)条数决定。同时，由于**指针**也是数据，所以地址在进行数据传送时会被匹配到同样的位数，但这不代表**地址总线**长度要和**字长**或者**数据总线**的长度一样，**地址总线**的长度由`cpu`自身设计决定，与`cpu`的位数没有直接关系，但由于**地址总线**决定了`cpu`的寻址能力，所以**地址总线**所能够支持的寻址一定要大于**数据总线**的位数，不论通过什么方法来实现这一要求。

#### word alignment

在实际使用时，我们常常会遇到**内存对齐**的说法，什么是内存对齐？为什么我们需要这样做？

比如对于一个32位的处理器，它一次能够处理数据的能力为`32 bits`，换算成内存单元就是`4 bytes`。`cpu`正是按照这个`4 bytes`的**块(`chunk`)**来读写内存的，块的大小被我们定义为**内存访问粒度**。

我们可以把内存想成一个无穷大的`array`，寻址从`0`位开始，我们的数据存储也正是从这个地址开始，如果**内存访问粒度**是`4 bytes`，那么`0`,`4`,`8`等等都是`aligned address`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207141611819.png" alt="image-20211207141611819" style="zoom:50%;" />

那如果我们的数据没有做到`word alignment`会发生什么后果呢？对于某些处理器而言，这会让它们进行多次的内存访存（**速度变慢**），分别访问每一个**内存单元**，读取其中需要的数据，最后再把多个单元读取到的数据进行`merge`，放到**寄存器**中。而对于某些`cpu`，则不会支持**非内存对齐**的数据存储形式，会直接产生报错。

#### some notice on pointers

这里还是记录一下关于**指针**的使用事项。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207200933346.png" alt="image-20211207200933346" style="zoom:50%;" />

上面的这幅图很好的包含了我们需要注意的关键点。首先我们可以看到：指针与整型均占4个`bytes`，之后我们声明了一个包含4个元素的整型数组，所以占据了28、32、36、40总共4个**内存单元**。

而在此之后，我们调用`malloc`函数，分配了一段内存，并让先前定义的指针`p`指向了这块我们刚刚分配的内存，但此时，这**段新分配的内存里边的值还是垃圾值**。相应的，指针`p`的值就变成了指向的那个地址，也就是40了！

> 我们一定要**先分配内存再使用内存**，如果在定义指针后没有使用`malloc`分配内存就直接`*p=1`，是不可以的。

最后，我们注意到对于数组`a`，`a`与`&a`的值是一样的，**不同于先前我们定义的变量的表现！**这一点我们在*CS 106L*的课程笔记中也有提过，该课程的汇编部分会再次提到这一话题。

### Memory locations

首先关于**声明**:

> - **Structure** declaration **does not** allocate memory.
> - **Variable** declaration **does** allocate memory.

在先前的**C++**课程中，其实也简短的[提到过](https://shaopu.tech/2021/11/07/CS%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B4/#globals--statics)，变量的生命周期（`storage duration`）有三种，我们形容为`static`,`automatic`,`dynamic`.分别对应着静态、全局变量；局部变量；动态分配内存的变量.

相应的，这三种不同的变量也被存储在不同类型的**内存池**中：

- **Static storage**:储存全局变量，生命周期为整个程序运行的时间
- **The Stack**: 储存**局部变量**、**函数参数**、**返回地址**
- **The heap**: 使用`malloc`动态分配的数据，直到`free`生命周期结束（这里的生命周期结束其实并非变量消失，后便会提到）

#### Memory management

在一个程序中，共有四种类型的**地址空间**，除了在上一小节中提到的三种内存池之外，还包括`code`段，他们的分布形式如下图所示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208000712193.png" alt="image-20211208000712193" style="zoom: 33%;" />

**从上至下**，地址空间从最高一直到0；与之相对应的，分别用以存储`stack`,`heap`,`static data`以及`code`:

- 当我们向`stack`中存入数据时，它会向下分配新的内存，而`heap`则是向上分配内存（我们不需要在这里考虑两个内存池发生重叠的问题，*CS 162*会介绍处理方法）.
- `static data`与`code`均是在程序运行过程中**不会发生改变**的内存区域，`code`主要用以存储运行需要的代码，在程序一开始即生成。

##### Stack

在上边我们提到，`stack`用于存储以下三种类型的数据：

1. `Return "instruction" address`
2. `Parameters`
3. `Space for other local variables`

`stack`区的内存分配是**连续**的。他有一个**栈指针**(`stack pointer`)，指向当前**栈顶**的位置（随着新开辟的栈区域不断地向下改变位置）：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208001902974.png" alt="image-20211208001902974" style="zoom:50%;" />

当我们结束了一个`procedure`时，栈内存被自动"释放"，之所以这里加了引号，是因为栈内存释放的方式与我们常理解的释放不同，**它在释放的过程中将栈指针不断上移到上一个还没有被释放的栈块的栈顶，而先前存放在已经被"释放"额区域内的数据，其实仍然保留在其中！**

栈内存的分配与释放都是**很快**的！

##### Heap

与栈不同，堆的内存分配**不是连续**的。两段看起来应当被分配在前后未知的动态内存，很可能彼此离得很远。相应地，**堆的内存分配和释放过程相比起栈是很慢的！**在使用堆时，我们想尽量避免碎片(`fragmentation`)化的出现：

> In this case, we might have many free bytes but not be able to satisfy a large request since the free bytes are not contiguous in memory.

那么堆内存的分配和释放等等过程究竟是如何实现的呢？

每一块堆内存的头部都有这样两组数据：

1. 该块的大小(`size of the block`)
2. 指向下一个块的指针(`a pointer to the next block`)–有点像指针

所有的**空内存块**被保存在一个**循环链表**中！（在一块已经被分配走的内存中，上述的`pointer field`是处于不被使用的状态）。

而函数`malloc`便会从这个**循环链表**中替我们寻找可用的内存，寻找的方法有这样几种：

1. `best-fit`:在循环链表中**选择满足大小要求的最小的内存块**
2. `first-fit`:**选择第一个满足大小要求的内存块**
3. `next-fit`:进行`first-fit`，但是记忆上一次搜索完的位置，下一次从此处继续搜索可用内存

而相对应地，`free`函数在将指针指向的内存块释放后会**检查前后的内存区域是否也是空内存块**，

- 如果是，则将几段内存`merge`;
- 如果不是，则将刚**被释放的内存加入循环链表中**

#### When memory goes bad

在课程中，提到了几种应当避免出现的内存分配和释放问题，这里说几个：

- <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208004619281.png" alt="image-20211208004619281" style="zoom:50%;" />

这个情况其实很`tricky`，观察结果我们发现，第一次使用`content`和第二次的结果不一样，why？

注意到这里**我们把指向栈内数据的指针作为了函数返回值**，当栈内存被释放后，根据前边的描述，其中的数据其实并没有被抹掉，所以我们仍能够通过返回的指针`stackAddr`获取原先的数据，所以第一个`printf`没有问题。

但是`printf`也是一个函数，也被分配到了**栈**上，由于栈内存是连续分配的，他恰好占用了原本数据`y`的位置，导致`y`被毁掉了–这就导致第二次我们再次尝试获取`y`的数据时，指针把我们带到了垃圾值上！

- `Realloc`

`Realloc`函数也是可能诱发内存分配问题的：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208005401436.png" alt="image-20211208005401436" style="zoom:50%;" />

在使用`realloc`时，如果程序发现接下来的空**堆内存块不够扩展到指定大小，他会将原来的数据一起搬运到新的能够存放整体大小的内存块上**！这就导致我们原本指向`foo`的指针`g`现在不可用了。

### Stream

这里主要说一下关于**C**中的**流**这一概念，以及之前我一直没懂的`FILE`这个对象。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211210194228562.png" alt="image-20211210194228562" style="zoom: 33%;" />

其中，`stdin`是输入**流**，因为在`linux`中一切皆文件，所以他也是标准**输入文件**。同理，`stdout`是输出**流**–标准**输出文件**。

我们也可以这样理解：**linux**通过**文件**的形式实现了输入/输出流，文件们分别对应着不同的**文件描述符**，每当我们打开`文件`（也是**广义**的！）时，就有一个代表着该打开文件的**文件描述符**，程序启动时默认打开三个`I/O`设备文件：标准输入文件`stdin`，标准输出文件`stdout`，标准错误输出文件`stderr`，分别得到文件描述符 `0`, `1`, `2`:

> **[文件描述符](https://segmentfault.com/a/1190000009724931)**在形式上是一个非负整数。实际上，它是一个**索引值**，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开.

在*Stanford CS 106L*最开始的笔记章节中，我们对`stream`对象做了很多的分析，有了初步的了解。`stdin`默认从键盘接收输入，`stdout`默认将内容输出到屏幕上，但这不是它们唯一可行的路径和流入（出）方式，比如读入/写入文件当中，我们可以使用`redirection`（[重定向](http://c.biancheng.net/view/942.html)）的方法改变其输入/输出的对象.

> `</>`重定向在使用`gdb`调试时也可使用

需要注意的是，我们经常使用的`FILE`和我们日常所说的狭义的*文件*没有任何关系！根据**C++**官方文档：

> **Object containing information to control a stream**
>
> Object type that **identifies a stream and contains the information needed to control it**, including a pointer to its buffer, its position indicator and all its state indicators.

换句话说，他可以用来表示一个`stream`对象。这也是为什么我们在函数`fgetc(FILE *stream)`中，可以使用`fgetc(stdin)`的原因。

### Floating Point

这一节来处理浮点数.

#### Basic Representation

首先，我们如何把一个二进制浮点数计算成我们习惯的十进制的样子？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211175738895.png" alt="image-20211211175738895" style="zoom:50%;" />

为什么叫`floating point`?这是因为在一开始，我们思考的储存方式是**固定小数点的位置**，这种方法被称为`fixed point`，而与之相对应地`floating point`则是允许小数点在数字之间移动–这种表示模式允许我们记录**更大范围的数字**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182809936.png" alt="image-20211211182809936" style="zoom:50%;" />

为了表示一个`floating point`，我们的基本思路是用一段`bits`表示**需要记录的数字部分**，再用另一段`bits`表示**小数点所在的位置**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182739063.png" alt="image-20211211182739063" style="zoom:50%;" />

按照如上的思想，我们需要将浮点数在内存中用如下方式表示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182857518.png" alt="image-20211211182857518" style="zoom:50%;" />

`float`共使用`32`bits记录，其中，浮点数本身的最前边的`1`我们**不在这里单独记录**–因为除了`0`，其他的任何一个浮点数按照**科学计数法（`Normalization`）**的模式，都需要有一个`1`在前边。

`float`(*Single Precision*)的储存形式整体上分为三个部分：

1. `Sign bit`-1 bit
2. `Exponent bits`-8 bits
3. `Signtificand bits`-23 bits(对于`double`(*Double Precision*),为`52 bits`)

我们可以先对这种表示模式进行一下思考：其中的`Exponent`部分应当使用一种类似于`Two's complement`的表示方法，因为我们需要最终表示形式的指数部分**可正可负**。`Significand`部分则是直接存储了二进制浮点数小数点后的二进制数字序列。

但是使用`Two's Complement`的一个问题在于，当机器上不存在**用于浮点数比较的硬件（如早期的计算机）时，我们无法直接通过整数比较的方法来比较浮点数**，并且，即使存在用于浮点数比较的硬件，浮点数比较的过程也是远远慢于整数比较的！

当我们使用`Two's Complement`来表示`Exponent`时，当`Ex`**所记录的整数**越大，我们并不能够得出对应的`float`越大的结论（在其他部分相同的前提下）– 当`Ex`从`00...0`到`11...1`，实际的`Exponent`值，在此时也可以用于表示实际的浮点数值会从`0~+MAX`，再到`-MAX~0`变化！

于是我们想到了`Bias Encoding/Notation`!在这种表示模式下，`Ex`所代表的整数的变化趋势与实际值的变化趋势是完全一致的，所以对于`float`，我们使用`bias=-127`，相对应地，`double`中`bias=-1023`. 

这样一来，我们的比较过程可以设计为：

1. `sort the sign field by just +/-`
2. `sort by more significant exponent`
3. `If Exponent the same, using mantissa sorting`

于是，以`float32`为例，最终我们的计算公式为：



$$(-1)^S\times (1+significand)\times 2^{(Exponent - 127)}$$



同时，显然，这种表示方法对于数字范围是存在限制的，这意味着我们会遇到`overflow`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211184944361.png" alt="image-20211211184944361" style="zoom:50%;" />

#### Special Numbers





> 当我们试图从`00...0`一直加到`11...1`时，浮点数的大小变化范围和我们先前提到的`Sign and magnitude`（**原码**）一致！
