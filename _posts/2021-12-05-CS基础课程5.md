---
layout:		post
title:		CS基础课程5
subtitle:	Berkeley CS 61C
date:		2021-12-05
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C
    - Computer Architecture (Machine Structures)
    - CS基础课程笔记
---

## Number representation

1. **进制转换表**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182043678.png" alt="image-20211206182043678" style="zoom:33%;" />

2. **Number representations**

共有五种表示方法，其中较为常用的，比较适用于计算机使用的方法有三种。

- `Unsigned`

这种方法即不带有符号的表示方法，是最简单的一种表示，当我们有五位可以用来表示数字的时候，无符号表示方法可以记录`0~31`的数字，但是接下来的有符号表示只能记录`-16~15`的区间了（因为最高位用以记录正负–没有免费午餐定理）。

- `Sign and Magnitude`

这种方法根据老师的描述，就是我们数电课程中学过的**原码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182536990.png" alt="image-20211206182536990" style="zoom:50%;" />

这种方法主要有两大缺点：

1. 零位重合
2. 正数与负数的计算方向是相反的（依上图）

- `One's Complement`

这种方法就是**反码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182709493.png" alt="image-20211206182709493" style="zoom:50%;" />

反码相比源码，虽然从负数到正数的计算方向保持了一致，但是仍然存在**零位重合**的问题。

- `Two's Complement`

这就是我们所说的**补码**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182913504.png" alt="image-20211206182913504" style="zoom:50%;" />

根据上图我们可以看出，补码完美的解决了先前方法存在的问题，`11111`这里不再是`-0`，而是`-1`了。公式：**补码=反码+1.（正数的反码与补码均是其本身）**

- `Bias Encoding`

这种编码方式常用于将一个`unsigned representation`转化成`signed`的形式（比如要把一段在$$x$$轴上方的正弦波抬到中轴处），我们通过给入程序一个`bias`为$$-(2^{N-1}-1)$$的数值来辅助实现这一变换，在进行了$$unsigned+bias$$的操作之后，他最终形成的表示范围（以$$N=5$$为例）是`-15~16`(与补码不同)！也就是说，原本的`00000`现在变成了最小的那一个**负数**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206184425110.png" alt="image-20211206184425110" style="zoom:50%;" />



在上述的众多方法中，我们常使用的是`unsigned`,`two's complement`,`bias encoding`.

3. **overflow**

在计算的过程中，可能会发生**溢出**的情况，那到底什么时候才算做溢出呢？当我们**舍弃掉最高位进位后，如果发现运算结果是错的，那就说明确实是溢出**了，一般来讲，我们使用**双高位判定法**来判断是否发生溢出：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206190532715.png" alt="image-20211206190532715" style="zoom:50%;" />

**当最高数据位向符号位进位不等于符号位进位时，即发生溢出！**

## C Programming

### Pointing to Different Size Objects

#### 32？64？

首先我们要有**存储单元**的概念，在现代的微型存储器中，一个**存储单元**是8个`bit`，也就是一个`byte`，换句话说：这些机器是`byte-addressable`的 – 微型存储器的容量是以`byte`为最小单位计算的。

需要注意的是，当我们谈论*32位机器*或者*64位机器*（`cpu`）时，我们所指的是它**一次能够处理的数据的长度**，也就是**寄存器的位数**，也被叫做**字长(`word length`)**，它和我们所说的**数据总线**，**地址总线**等没有*直接*关系。

**数据总线**的长度一般要**等于**`cpu`的**字长**，这是为了保证`cpu`的数据处理能力得到充分利用，所以我们可以说字长由[微处理器](https://baike.baidu.com/item/微处理器)对外数据通路的[数据总线](https://baike.baidu.com/item/数据总线)条数决定。同时，由于**指针**也是数据，所以地址在进行数据传送时会被匹配到同样的位数，但这不代表**地址总线**长度要和**字长**或者**数据总线**的长度一样，**地址总线**的长度由`cpu`自身设计决定，与`cpu`的位数没有直接关系，但由于**地址总线**决定了`cpu`的寻址能力，所以**地址总线**所能够支持的寻址一定要大于**数据总线**的位数，不论通过什么方法来实现这一要求。

#### word alignment

在实际使用时，我们常常会遇到**内存对齐**的说法，什么是内存对齐？为什么我们需要这样做？

比如对于一个32位的处理器，它一次能够处理数据的能力为`32 bits`，换算成内存单元就是`4 bytes`。`cpu`正是按照这个`4 bytes`的**块(`chunk`)**来读写内存的，块的大小被我们定义为**内存访问粒度**。

我们可以把内存想成一个无穷大的`array`，寻址从`0`位开始，我们的数据存储也正是从这个地址开始，如果**内存访问粒度**是`4 bytes`，那么`0`,`4`,`8`等等都是`aligned address`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207141611819.png" alt="image-20211207141611819" style="zoom:50%;" />

那如果我们的数据没有做到`word alignment`会发生什么后果呢？对于某些处理器而言，这会让它们进行多次的内存访存（**速度变慢**），分别访问每一个**内存单元**，读取其中需要的数据，最后再把多个单元读取到的数据进行`merge`，放到**寄存器**中。而对于某些`cpu`，则不会支持**非内存对齐**的数据存储形式，会直接产生报错。

#### some notice on pointers

这里还是记录一下关于**指针**的使用事项。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207200933346.png" alt="image-20211207200933346" style="zoom:50%;" />

上面的这幅图很好的包含了我们需要注意的关键点。首先我们可以看到：指针与整型均占4个`bytes`，之后我们声明了一个包含4个元素的整型数组，所以占据了28、32、36、40总共4个**内存单元**。

而在此之后，我们调用`malloc`函数，分配了一段内存，并让先前定义的指针`p`指向了这块我们刚刚分配的内存，但此时，这**段新分配的内存里边的值还是垃圾值**。相应的，指针`p`的值就变成了指向的那个地址，也就是40了！

> 我们一定要**先分配内存再使用内存**，如果在定义指针后没有使用`malloc`分配内存就直接`*p=1`，是不可以的。

最后，我们注意到对于数组`a`，`a`与`&a`的值是一样的，**不同于先前我们定义的变量的表现！**这一点我们在*CS 106L*的课程笔记中也有提过，该课程的汇编部分会再次提到这一话题。

### Memory locations

首先关于**声明**:

> - **Structure** declaration **does not** allocate memory.
> - **Variable** declaration **does** allocate memory.

在先前的**C++**课程中，其实也简短的[提到过](https://shaopu.tech/2021/11/07/CS%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B4/#globals--statics)，变量的生命周期（`storage duration`）有三种，我们形容为`static`,`automatic`,`dynamic`.分别对应着静态、全局变量；局部变量；动态分配内存的变量.

相应的，这三种不同的变量也被存储在不同类型的**内存池**中：

- **Static storage**:储存全局变量，生命周期为整个程序运行的时间
- **The Stack**: 储存**局部变量**、**函数参数**、**返回地址**
- **The heap**: 使用`malloc`动态分配的数据，直到`free`生命周期结束（这里的生命周期结束其实并非变量消失，后便会提到）

#### Memory management

在一个程序中，共有四种类型的**地址空间**，除了在上一小节中提到的三种内存池之外，还包括`code`段，他们的分布形式如下图所示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208000712193.png" alt="image-20211208000712193" style="zoom: 33%;" />

**从上至下**，地址空间从最高一直到0；与之相对应的，分别用以存储`stack`,`heap`,`static data`以及`code`:

- 当我们向`stack`中存入数据时，它会向下分配新的内存，而`heap`则是向上分配内存（我们不需要在这里考虑两个内存池发生重叠的问题，*CS 162*会介绍处理方法）.
- `static data`与`code`均是在程序运行过程中**不会发生改变**的内存区域，`code`主要用以存储运行需要的代码，在程序一开始即生成。

##### Stack

在上边我们提到，`stack`用于存储以下三种类型的数据：

1. `Return "instruction" address`
2. `Parameters`
3. `Space for other local variables`

`stack`区的内存分配是**连续**的。他有一个**栈指针**(`stack pointer`)，指向当前**栈顶**的位置（随着新开辟的栈区域不断地向下改变位置）：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208001902974.png" alt="image-20211208001902974" style="zoom:50%;" />

当我们结束了一个`procedure`时，栈内存被自动"释放"，之所以这里加了引号，是因为栈内存释放的方式与我们常理解的释放不同，**它在释放的过程中将栈指针不断上移到上一个还没有被释放的栈块的栈顶，而先前存放在已经被"释放"额区域内的数据，其实仍然保留在其中！**

栈内存的分配与释放都是**很快**的！

##### Heap

与栈不同，堆的内存分配**不是连续**的。两段看起来应当被分配在前后未知的动态内存，很可能彼此离得很远。相应地，**堆的内存分配和释放过程相比起栈是很慢的！**在使用堆时，我们想尽量避免碎片(`fragmentation`)化的出现：

> In this case, we might have many free bytes but not be able to satisfy a large request since the free bytes are not contiguous in memory.

那么堆内存的分配和释放等等过程究竟是如何实现的呢？

每一块堆内存的头部都有这样两组数据：

1. 该块的大小(`size of the block`)
2. 指向下一个块的指针(`a pointer to the next block`)–有点像指针

所有的**空内存块**被保存在一个**循环链表**中！（在一块已经被分配走的内存中，上述的`pointer field`是处于不被使用的状态）。

而函数`malloc`便会从这个**循环链表**中替我们寻找可用的内存，寻找的方法有这样几种：

1. `best-fit`:在循环链表中**选择满足大小要求的最小的内存块**
2. `first-fit`:**选择第一个满足大小要求的内存块**
3. `next-fit`:进行`first-fit`，但是记忆上一次搜索完的位置，下一次从此处继续搜索可用内存

而相对应地，`free`函数在将指针指向的内存块释放后会**检查前后的内存区域是否也是空内存块**，

- 如果是，则将几段内存`merge`;
- 如果不是，则将刚**被释放的内存加入循环链表中**

#### When memory goes bad

在课程中，提到了几种应当避免出现的内存分配和释放问题，这里说几个：

- <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208004619281.png" alt="image-20211208004619281" style="zoom:50%;" />

这个情况其实很`tricky`，观察结果我们发现，第一次使用`content`和第二次的结果不一样，why？

注意到这里**我们把指向栈内数据的指针作为了函数返回值**，当栈内存被释放后，根据前边的描述，其中的数据其实并没有被抹掉，所以我们仍能够通过返回的指针`stackAddr`获取原先的数据，所以第一个`printf`没有问题。

但是`printf`也是一个函数，也被分配到了**栈**上，由于栈内存是连续分配的，他恰好占用了原本数据`y`的位置，导致`y`被毁掉了–这就导致第二次我们再次尝试获取`y`的数据时，指针把我们带到了垃圾值上！

- `Realloc`

`Realloc`函数也是可能诱发内存分配问题的：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208005401436.png" alt="image-20211208005401436" style="zoom:50%;" />

在使用`realloc`时，如果程序发现接下来的空**堆内存块不够扩展到指定大小，他会将原来的数据一起搬运到新的能够存放整体大小的内存块上**！这就导致我们原本指向`foo`的指针`g`现在不可用了。
