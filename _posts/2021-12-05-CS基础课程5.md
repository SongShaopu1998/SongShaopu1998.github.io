---
layout:		post
title:		CS基础课程5
subtitle:	Berkeley CS 61C
date:		2021-12-05
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
    - C
    - Computer Architecture (Machine Structures)
    - CS基础课程笔记
---

## Number representation

1. **进制转换表**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182043678.png" alt="image-20211206182043678" style="zoom:33%;" />

2. **Number representations**

共有五种表示方法，其中较为常用的，比较适用于计算机使用的方法有三种。

- `Unsigned`

这种方法即不带有符号的表示方法，是最简单的一种表示，当我们有五位可以用来表示数字的时候，无符号表示方法可以记录`0~31`的数字，但是接下来的有符号表示只能记录`-16~15`的区间了（因为最高位用以记录正负–没有免费午餐定理）。

- `Sign and Magnitude`

这种方法根据老师的描述，就是我们数电课程中学过的**原码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182536990.png" alt="image-20211206182536990" style="zoom:50%;" />

这种方法主要有两大缺点：

1. 零位重合
2. 正数与负数的计算方向是相反的（依上图）

- `One's Complement`

这种方法就是**反码**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182709493.png" alt="image-20211206182709493" style="zoom:50%;" />

反码相比源码，虽然从负数到正数的计算方向保持了一致，但是仍然存在**零位重合**的问题。

- `Two's Complement`

这就是我们所说的**补码**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206182913504.png" alt="image-20211206182913504" style="zoom:50%;" />

根据上图我们可以看出，补码完美的解决了先前方法存在的问题，`11111`这里不再是`-0`，而是`-1`了。公式：**补码=反码+1.（正数的反码与补码均是其本身）**

- `Bias Encoding`

这种编码方式常用于将一个`unsigned representation`转化成`signed`的形式（比如要把一段在$$x$$轴上方的正弦波抬到中轴处），我们通过给入程序一个`bias`为$$-(2^{N-1}-1)$$的数值来辅助实现这一变换，在进行了$$unsigned+bias$$的操作之后，他最终形成的表示范围（以$$N=5$$为例）是`-15~16`(与补码不同)！也就是说，原本的`00000`现在变成了最小的那一个**负数**了：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206184425110.png" alt="image-20211206184425110" style="zoom:50%;" />



在上述的众多方法中，我们常使用的是`unsigned`,`two's complement`,`bias encoding`.

3. **overflow**

在计算的过程中，可能会发生**溢出**的情况，那到底什么时候才算做溢出呢？当我们**舍弃掉最高位进位后，如果发现运算结果是错的，那就说明确实是溢出**了，一般来讲，我们使用**双高位判定法**来判断是否发生溢出：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206190532715.png" alt="image-20211206190532715" style="zoom:50%;" />

**当最高数据位向符号位进位不等于符号位进位时，即发生溢出！**

## C Programming

### Pointing to Different Size Objects

#### 32？64？

首先我们要有**存储单元**的概念，在现代的微型存储器中，一个**存储单元**是8个`bit`，也就是一个`byte`，换句话说：这些机器是`byte-addressable`的 – 微型存储器的容量是以`byte`为最小单位计算的。

需要注意的是，当我们谈论*32位机器*或者*64位机器*（`cpu`）时，我们所指的是它**一次能够处理的数据的长度**，也就是**寄存器的位数**，也被叫做**字长(`word length`)**，它和我们所说的**数据总线**，**地址总线**等没有*直接*关系。

**数据总线**的长度一般要**等于**`cpu`的**字长**，这是为了保证`cpu`的数据处理能力得到充分利用，所以我们可以说字长由[微处理器](https://baike.baidu.com/item/微处理器)对外数据通路的[数据总线](https://baike.baidu.com/item/数据总线)条数决定。同时，由于**指针**也是数据，所以地址在进行数据传送时会被匹配到同样的位数，但这不代表**地址总线**长度要和**字长**或者**数据总线**的长度一样，**地址总线**的长度由`cpu`自身设计决定，与`cpu`的位数没有直接关系，但由于**地址总线**决定了`cpu`的寻址能力，所以**地址总线**所能够支持的寻址一定要大于**数据总线**的位数，不论通过什么方法来实现这一要求。

#### word alignment

在实际使用时，我们常常会遇到**内存对齐**的说法，什么是内存对齐？为什么我们需要这样做？

比如对于一个32位的处理器，它一次能够处理数据的能力为`32 bits`，换算成内存单元就是`4 bytes`。`cpu`正是按照这个`4 bytes`的**块(`chunk`)**来读写内存的，块的大小被我们定义为**内存访问粒度**。

我们可以把内存想成一个无穷大的`array`，寻址从`0`位开始，我们的数据存储也正是从这个地址开始，如果**内存访问粒度**是`4 bytes`，那么`0`,`4`,`8`等等都是`aligned address`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207141611819.png" alt="image-20211207141611819" style="zoom:50%;" />

那如果我们的数据没有做到`word alignment`会发生什么后果呢？对于某些处理器而言，这会让它们进行多次的内存访存（**速度变慢**），分别访问每一个**内存单元**，读取其中需要的数据，最后再把多个单元读取到的数据进行`merge`，放到**寄存器**中。而对于某些`cpu`，则不会支持**非内存对齐**的数据存储形式，会直接产生报错。

#### some notice on pointers

这里还是记录一下关于**指针**的使用事项。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211207200933346.png" alt="image-20211207200933346" style="zoom:50%;" />

上面的这幅图很好的包含了我们需要注意的关键点。首先我们可以看到：指针与整型均占4个`bytes`，之后我们声明了一个包含4个元素的整型数组，所以占据了28、32、36、40总共4个**内存单元**。

而在此之后，我们调用`malloc`函数，分配了一段内存，并让先前定义的指针`p`指向了这块我们刚刚分配的内存，但此时，这**段新分配的内存里边的值还是垃圾值**。相应的，指针`p`的值就变成了指向的那个地址，也就是40了！

> 我们一定要**先分配内存再使用内存**，如果在定义指针后没有使用`malloc`分配内存就直接`*p=1`，是不可以的。

最后，我们注意到对于数组`a`，`a`与`&a`的值是一样的，**不同于先前我们所定义的`变量`的表现！**这一点我们在*CS 106L*的课程笔记中也有提过，该课程的汇编部分会再次提到这一话题。

> 需要注意的是，数组名称**不可以被重新赋值**（`reassigned`），所以我们也不能对其进行`++a`的操作。这一点也是与指针有很大差异的一点.

- 此外，我们还要注意，在实际编程中，我们可能经常需要**向一个函数传递数组**，如果我们想在函数内部利用`sizeof`操作符获取数组大小，那么由于传入函数的是一个指针，我们只会得到指针的大小而非实际的数组大小–此时我们必须要向函数传递一个额外的`size`参数；当然，如果我们在处理一个**字符数组**，我们完全可以利用其`null terminator`的特征来定位整个数组。
- 在**C**中使用字符串（字符数组）时，末尾的`\0`在**ASCII**码中对应了**NUL**，即**ASCII**码中的**0**！所以我们在判定字符串是否到达末尾时，可以直接将`*str++*`作为判定条件，而无需和`\0`比较。我们需要注意，当使用字符数组来储存字符形成字符串时，我们需要手动添加一个`\0`，但是在使用`string literals`会自动添加，不需要我们手动操作.

### Memory locations

首先关于**声明**:

> - **Structure** declaration **does not** allocate memory.
> - **Variable** declaration **does** allocate memory.

在先前的**C++**课程中，其实也简短的[提到过](https://shaopu.tech/2021/11/07/CS%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B4/#globals--statics)，变量的生命周期（`storage duration`）有三种，我们形容为`static`,`automatic`,`dynamic`.分别对应着静态、全局变量；局部变量；动态分配内存的变量.

相应的，这三种不同的变量也被存储在不同类型的**内存池**中：

- **Static storage**:储存全局变量，生命周期为整个程序运行的时间
- **The Stack**: 储存**局部变量**、**函数参数**、**返回地址**
- **The heap**: 使用`malloc`动态分配的数据，直到`free`生命周期结束（这里的生命周期结束其实并非变量消失，后便会提到）

#### Memory management

在一个程序中，共有四种类型的**地址空间**，除了在上一小节中提到的三种内存池之外，还包括`code`段，他们的分布形式如下图所示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208000712193.png" alt="image-20211208000712193" style="zoom: 33%;" />

**从上至下**，**地址空间从最高一直到0**；与之相对应的，分别用以存储`stack`,`heap`,`static data`以及`code`:

- 当我们向`stack`中存入数据时，它会向下分配新的内存，而`heap`则是向上分配内存（我们不需要在这里考虑两个内存池发生重叠的问题，*CS 162*会介绍处理方法）.
- `static data`与`code`均是在程序运行过程中**不会发生改变**的内存区域，`code`主要用以存储运行需要的代码，在程序一开始即生成。

##### Stack

在上边我们提到，`stack`用于存储以下三种类型的数据：

1. `Return "instruction" address`
2. `Parameters`
3. `Space for other local variables`

`stack`区的内存分配是**连续**的。他有一个**栈指针**(`stack pointer`)，指向当前**栈顶**的位置（随着新开辟的栈区域不断地向下改变位置）：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208001902974.png" alt="image-20211208001902974" style="zoom:50%;" />

当我们结束了一个`procedure`时，栈内存被自动"释放"，之所以这里加了引号，是因为栈内存释放的方式与我们常理解的释放不同，**它在释放的过程中将栈指针不断上移到上一个还没有被释放的栈块的栈顶，而先前存放在已经被"释放"额区域内的数据，其实仍然保留在其中！**

栈内存的分配与释放都是**很快**的！

##### Heap

与栈不同，堆的内存分配**不是连续**的。两段看起来应当被分配在前后未知的动态内存，很可能彼此离得很远。相应地，**堆的内存分配和释放过程相比起栈是很慢的！**在使用堆时，我们想尽量避免碎片(`fragmentation`)化的出现：

> In this case, we might have many free bytes but not be able to satisfy a large request since the free bytes are not contiguous in memory.

那么堆内存的分配和释放等等过程究竟是如何实现的呢？

每一块堆内存的头部都有这样两组数据：

1. 该块的大小(`size of the block`)
2. 指向下一个块的指针(`a pointer to the next block`)–有点像指针

所有的**空内存块**被保存在一个**循环链表**中！（在一块已经被分配走的内存中，上述的`pointer field`是处于不被使用的状态）。

而函数`malloc`便会从这个**循环链表**中替我们寻找可用的内存，寻找的方法有这样几种：

1. `best-fit`:在循环链表中**选择满足大小要求的最小的内存块**
2. `first-fit`:**选择第一个满足大小要求的内存块**
3. `next-fit`:进行`first-fit`，但是记忆上一次搜索完的位置，下一次从此处继续搜索可用内存

而相对应地，`free`函数在将指针指向的内存块释放后会**检查前后的内存区域是否也是空内存块**，

- 如果是，则将几段内存`merge`;
- 如果不是，则将刚**被释放的内存加入循环链表中**

#### When memory goes bad

在课程中，提到了几种应当避免出现的内存分配和释放问题，这里说几个：

- <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208004619281.png" alt="image-20211208004619281" style="zoom:50%;" />

这个情况其实很`tricky`，观察结果我们发现，第一次使用`content`和第二次的结果不一样，why？

注意到这里**我们把指向栈内数据的指针作为了函数返回值**，当栈内存被释放后，根据前边的描述，其中的数据其实并没有被抹掉，所以我们仍能够通过返回的指针`stackAddr`获取原先的数据，所以第一个`printf`没有问题。

但是`printf`也是一个函数，也被分配到了**栈**上，由于栈内存是连续分配的，他恰好占用了原本数据`y`的位置，导致`y`被毁掉了–这就导致第二次我们再次尝试获取`y`的数据时，指针把我们带到了垃圾值上！

- `Realloc`

`Realloc`函数也是可能诱发内存分配问题的：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211208005401436.png" alt="image-20211208005401436" style="zoom:50%;" />

在使用`realloc`时，如果程序发现接下来的空**堆内存块不够扩展到指定大小，他会将原来的数据一起搬运到新的能够存放整体大小的内存块上**！这就导致我们原本指向`foo`的指针`g`现在不可用了。

- `calloc`

除了`malloc`和`realloc`外，我们还有一个`calloc`函数，可以避免我们忘记了初始化刚分配的内存空间的问题：

```c
// define a n*m matrix of int
int **mat = (int **)calloc(n, sizeof(int *));
for (int i = 0; i < n; ++i) {
    mat[i] = (int *)calloc(m, sizeof(int));
}
```

需要注意的是，该函数可以直接给出初始化的**空间+初始化值**–**0**（真正意义上的**0**，比如*NULL*或者数值的0之类的…）



几种会出现`segfault`的情况：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211213235209723.png" alt="image-20211213235209723" style="zoom: 33%;" />

#### some notice on memory menagement

- 对于程序中定义的**常数(`constants`)**,它可能存放的位置有：

1. Code段：`x=x+1`,其中`1`在编译阶段直接被存储到`machine instruction`中，以及`#define y 5`时
2. static段：全局变量：`const int x = 1`中的`1`
3. stack段：将常量定义在函数中：`int total = 1`

- 此外，`string literals`被存放在`static`段中，具体可见[这里](https://shaopu.tech/2021/11/07/CS%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B4/#storage-duration).

- 与**C++**不同的是，**C**中没有*引用*的说法，所以当我们在对一些数据结构比如链表进行内存的分配和释放时，我们不能够传递指针的引用，需要传递指针的指针.

### Stream

这里主要说一下关于**C**中的**流**这一概念，以及之前我一直没懂的`FILE`这个对象。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211210194228562.png" alt="image-20211210194228562" style="zoom: 33%;" />

其中，`stdin`是输入**流**，因为在`linux`中一切皆文件，所以他也是标准**输入文件**。同理，`stdout`是输出**流**–标准**输出文件**。

我们也可以这样理解：**linux**通过**文件**的形式实现了输入/输出流，文件们分别对应着不同的**文件描述符**，每当我们打开`文件`（也是**广义**的！）时，就有一个代表着该打开文件的**文件描述符**，程序启动时默认打开三个`I/O`设备文件：标准输入文件`stdin`，标准输出文件`stdout`，标准错误输出文件`stderr`，分别得到文件描述符 `0`, `1`, `2`:

> **[文件描述符](https://segmentfault.com/a/1190000009724931)**在形式上是一个非负整数。实际上，它是一个**索引值**，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开.

在*Stanford CS 106L*最开始的笔记章节中，我们对`stream`对象做了很多的分析，有了初步的了解。`stdin`默认从键盘接收输入，`stdout`默认将内容输出到屏幕上，但这不是它们唯一可行的路径和流入（出）方式，比如读入/写入文件当中，我们可以使用`redirection`（[重定向](http://c.biancheng.net/view/942.html)）的方法改变其输入/输出的对象.

> `</>`重定向在使用`gdb`调试时也可使用

需要注意的是，我们经常使用的`FILE`和我们日常所说的狭义的*文件*没有任何关系！根据**C++**官方文档：

> **Object containing information to control a stream**
>
> Object type that **identifies a stream and contains the information needed to control it**, including a pointer to its buffer, its position indicator and all its state indicators.

换句话说，他可以用来表示一个`stream`对象。这也是为什么我们在函数`fgetc(FILE *stream)`中，可以使用`fgetc(stdin)`的原因。

### Bit operation

在*Fa 2021 lab 02*中，我们需要解决三个位操作的函数，查看[Github仓库](https://github.com/SongShaopu1998/Berkeley-CS-61C/blob/main/labs/fa21-lab-starter-main/lab02/bit_ops.c)。分别为：

- 获取某位
- 改变某位
- 翻转(`flip`)某位

在后两种操作中，我们需要注意的是使用一个所有位均为`1`的参考值辅助操作，同时将原本的二进制数分为前后两个部分加以处理（`flip`）可以将需要`flip`的位单独拿出来，最后使用`|`合并.

### Floating Point

这一节来处理浮点数.

#### Basic Representation

首先，我们如何把一个二进制浮点数计算成我们习惯的十进制的样子？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211175738895.png" alt="image-20211211175738895" style="zoom:50%;" />

为什么叫`floating point`?这是因为在一开始，我们思考的储存方式是**固定小数点的位置**，这种方法被称为`fixed point`，而与之相对应地`floating point`则是允许小数点在数字之间移动–这种表示模式允许我们记录**更大范围的数字**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182809936.png" alt="image-20211211182809936" style="zoom:50%;" />

为了表示一个`floating point`，我们的基本思路是用一段`bits`表示**需要记录的数字部分**，再用另一段`bits`表示**小数点所在的位置**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182739063.png" alt="image-20211211182739063" style="zoom:50%;" />

按照如上的思想，我们需要将浮点数在内存中用如下方式表示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211182857518.png" alt="image-20211211182857518" style="zoom:50%;" />

`float`共使用`32`bits记录，其中，浮点数本身的最前边的`1`我们**不在这里单独记录**–因为除了`0`，其他的任何一个浮点数按照**科学计数法（`Normalization`）**的模式，都需要有一个`1`在前边。（后边我们会看到，即使是`0`，我们也有办法在不使用这个开头的数字的前提下表示出来！）

`float`(*Single Precision*)的储存形式整体上分为三个部分：

1. `Sign bit`-1 bit
2. `Exponent bits`-8 bits(对于`double`为`11 bits`)
3. `Signtificand bits`-23 bits(对于`double`(*Double Precision*),为`52 bits`)

我们可以先对这种表示模式进行一下思考：其中的`Exponent`部分应当使用一种类似于`Two's complement`的表示方法，因为我们需要最终表示形式的指数部分**可正可负**。`Significand`部分则是直接存储了二进制浮点数小数点后的二进制数字序列。

但是使用`Two's Complement`的一个问题在于，当机器上不存在**用于浮点数比较的硬件（如早期的计算机）时，我们无法直接通过整数比较的方法来比较浮点数**，并且，即使存在用于浮点数比较的硬件，浮点数比较的过程也是远远慢于整数比较的！

当我们使用`Two's Complement`来表示`Exponent`时，当`Ex`**所记录的整数**越大，我们并不能够得出对应的`float`越大的结论（在其他部分相同的前提下）– 当`Ex`从`00...0`到`11...1`，实际的`Exponent`值，在此时也可以用于表示实际的浮点数值会从`0~+MAX`，再到`-MAX~0`变化！

于是我们想到了`Bias Encoding/Notation`!在这种表示模式下，`Ex`所代表的整数的变化趋势与实际值的变化趋势是完全一致的，所以对于`float`，我们使用`bias=-127`，相对应地，`double`中`bias=-1023`. 

这样一来，我们的比较过程可以设计为：

1. `sort the sign field by just +/-`
2. `sort by more significant exponent`
3. `If Exponent the same, using mantissa sorting`

于是，以`float32`为例，最终我们的计算公式为：



$$(-1)^S\times (1+significand)\times 2^{(Exponent - 127)}$$



同时，显然，这种表示方法对于数字范围是存在限制的，这意味着我们会遇到`overflow`:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211184944361.png" alt="image-20211211184944361" style="zoom:50%;" />

#### Special Numbers

##### ∞

在浮点数的表示方法中，我们可以表示一些特殊数字，比如首先我们会想到表示正/负无穷。那么**IEEE 754**是如何表示∞的呢？

- **Most positive exponent** reserved for ∞
- **Significands all zeros**

也就是说，当我们从`1111110|11...1`再加一个1，就变成`∞`了！如果`sign bit`为1，那么就是`-∞`.

##### 0

其实严格意义上来讲，0并不能算作`special number`，因为他的表示与一般的方法是一样的，需要注意的是，在浮点数中，有一个`+0`，也有一个`-0`，从数学意义上来说，这两个0并非真正的0，而是指的从两个方向无限趋近于真正的**0**。他们都是合理的：



**+0: 0 00000000 00000000000000000000000**
**-0: 1 00000000 00000000000000000000000**

如此一来，我们用`significand`和`Exponent`均为`0`的方法来表示数字`0`（或者说数字0和这种表示方法是等价的）–>这允许我们不使用整数部分的数字，也能够表示0了.

所以我们在偌大的浮点数数字范围中，还有哪些区域的数字表示没有被使用？我们还需要表示那些特殊数字？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211202701559.png" alt="image-20211211202701559" style="zoom:50%;" />

根据上图，我们还有两个数字区域没有使用，分别是`Exponent`为0以及255，且`significand`(小数部分)不为0的情况.

> 为什么我们把正常数字的`Exponent`范围限制到`1-254`?这是因为我们刻意为`special numbers`保留了范围.

##### NaN

我们使用`Exponent`为**255**，`Significand`**不为0**的情况，来表示所谓的**NaN**(**Not-a-Number**).也即是说，当我们从`inf`再往前走一步，就回到了`Nan sea`.

那么NaN有什么用呢？

- 可以提供`debug`讯息
- op(NaN, X)=NaN

需要注意的是，NaN与任何东西比较的结果都是`false`，并且`NaN != NaN`.

##### Denorms

首先，什么是`normalization`? 通俗地讲，`normalization`就是将一个数字表示成科学计数法的`1`打头的表示，那么如果我们想把开头的数字搞成`0`而非`1`，这就叫`denorm`.

对于浮点数，我们当然希望它的**尺度**是均衡的，换句话说，我们希望在一段范围内，浮点数之间的距离是恒定的.

我们来计算一下现在的情况是否满足这一条款：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211215921254.png" alt="image-20211211215921254" style="zoom:50%;" />

显然，从0到a的距离…实在是相比起来有点太大了…

所以我们怎么解决这个巨大的`gap`的问题？奔着制造一个尺度均衡分布的数字范围的目标，我们利用还没有被分配任务的`Exponent`为0，且`significand`不为0的范围，提出`DEnormalizaed number`:

**No leading 1, implicit exponent = -126 (rather than -127)**

如此一来：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211221234402.png" alt="image-20211211221234402" style="zoom:50%;" />

需要注意的是，随着`Exponent`部分的变化，我们在`significand`的每一段的尺度也会发生变化，在最开始时每一段的间隔为$$2^{-149}$$，当`Exponent`加1之后，`significand`的间隔会变为$$2^{-149}\times 2$$. 换句话说：

> Exponent tells Significand how much (2^i) to count by (..., 1/4, 1/2, 1, 2, ...).

当存储内部的`Exponent`为150时，`significand`的间隔会变为1（$$2^{(150-127)}\times 2^{-23}=1$$）



最终，我们得到了完整的浮点数表示：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211221437771.png" alt="image-20211211221437771" style="zoom:50%;" />

> 当我们试图从`00...0`一直加到`11...1`时，浮点数的大小变化范围和我们先前提到的`Sign and magnitude`（**原码**）一致！

##### Attributes

首先，浮点数运算不具备**关联性**：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211230807221.png" alt="image-20211211230807221" style="zoom:50%;" />

其次，正如我们在写程序中经常遇到的，浮点数存在`rounding`这一机制，通常，浮点数硬件带有额外的两个`bit`，之后使用`rounding`机制将浮点数表示为合适的值。`rounding`发生在将`double`转为`float`时，也发生在将`float`转为`int`时：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211232700680.png" alt="image-20211211232700680" style="zoom:50%;" />

需要注意的是，当浮点数恰好位于`rounding`的分界线上时，我们将浮点数`rounding`到**偶数**上。

再者，浮点数的**加法运算**并不像整数的加法运算那样简单，我们可能先需要将浮点数`denormalize`，以匹配其指数部分，在完成`significands`的加法运算后，再将结果`normalize`.

我们可以使用**强制转换**机制，这一机制在内部通过`rounding`来实现。需要注意的是，由于浮点数尺度的问题，它并不能表示某些整数！所以：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211233056007.png" alt="image-20211211233056007" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211211233254194.png" alt="image-20211211233254194" style="zoom:50%;" />



除了上述的`float`以及`double`之外，还有其他一些表示方式：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211212000057633.png" alt="image-20211212000057633" style="zoom:50%;" />

特别的是，由于机器学习并不需要太高的精度要求，`bfloat16`类型被使用在ML中，它牺牲了一部分`significand`空间以换取更大的范围（`Exponent`）.

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211212000317259.png" alt="image-20211212000317259" style="zoom:50%;" />

特别的是，有一种观点提出，我们可以对`float point`做进一步优化，使得`Exponent`和`Significant`的长度都可以变化，以适应不同的场景。同时，携带一个`u-bit`来表示这个浮点数是否经过了`rounding`.换而言之，他是一个准确的值还是一个估计值。

## Assembly language

汇编语言的操作数(`operand`)是**寄存器(`register`)**!

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211214232809988.png" alt="image-20211214232809988" style="zoom:50%;" />

在**RISC-V**中，共有**32**个寄存器，其中`x0`是最特殊的，他始终保有`0`值！这意味着我们只允许使用其他31个寄存器来存储变量！

关于**RISC-V**的几个基本的操作，如`add`,`addi`,`sub`这里不详述.

### storing data in memory

我们首先要知道CPU与内存交互的两种基本模式：

1. **Write** Data – Store **To Memory**
2. **Read** Data – Load **from Memory**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216122249838.png" alt="image-20211216122249838" style="zoom:50%;" />

其次，在`word alignment`的一节我们已经提到过，一个`8bit`的块被称为`byte`，是一个微型存储单元（`byte-addressable`）。字(`word`)在`32`位CPU中，是`4 bytes`，内存读取按照`word`读取（**内存访问粒度**）……(参见原章节)

那么每一个`word`在内存中是以什么样的格式存储的呢？在这里，我们的存储方式为**Little-endian convention**:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216123319753.png" alt="image-20211216123319753" style="zoom: 33%;" />

> Word address is same as address of rightmost byte – least-significant byte.

也就是说，`word`中最低的那一个`byte`被安排在了最小的地址上。与之相对的是**Big-endian convention**:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216124545397.png" alt="image-20211216124545397" style="zoom:50%;" />

需要注意的是，无论是哪一种`bytes`的存储方式，其中`bits`的存储方式是不变的.

### Data Transfer Instructions

在**RISC-V**中，一个寄存器为4bytes，共有32个寄存器，也就是128bytes。而相对应的`Memory`有2GB-64GB，这也意味着寄存器一定要比内存（`DRAM`）更快，大概是它的50~500倍。所以我们更想让指令(`Instructions`)在寄存器中被操作，而不是直接在内存中操作–这就需要内存与寄存器的双向数据交互。

- <u>Load word from</u> Memory to Register

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216161325926.png" alt="image-20211216161325926" style="zoom: 33%;" />

**lw**这个语句的含义是将储存在`x15`中的`base pointer`的值加上`12bytes`的地址里储存的内容，即`A[3]`复制到x10中. 与之相对应地，是从寄存器向内存中储存内容的**sw**：

- <u>Store word from</u> Register to Memory

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216161736950.png" alt="image-20211216161736950" style="zoom:33%;" />

除了对于`word`存取的操作指令外，我们还可以直接对`Bytes`进行操作：

- Loading and Storing Bytes

分别于**lw**,**sw**相对应地：

- **lb**
- **sb**

E.g.

```assembly
lb x10,3(x11)
```

该指令将指针指向的内容**复制**到寄存器`x10`的`low byte position`.

#### Sign-extend

**sign-extend**的意义在于保证一个有符号数字(可能不到32bits)在被储存进寄存器(32bits)时仍然保证是一个有符号数字：

> 如果在前边所有的高位里都存储**0**，那么对于这个寄存器内的32位数字来说，就始终是一个`positive number`了.

所以，在**lb**中采用了如下方法：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211216164345305.png" alt="image-20211216164345305" style="zoom:50%;" />

需要注意的是，在**sb**中没有`sign-extend`的说法，我们只需要将寄存器中的内容取出来就好，`sign-extend`在**sb**中没有意义。

> RISC-V也有一种储存`unsigned byte`的方法：**lbu**，顾名思义，是使用`zero extend`的方法来填充寄存器.

#### Why need addi?

我们发现，这两种写法具有相同的效果：

```assembly
// first
lw x10,12(x5)
add x12,x12,x10

// second
addi x12, value
```

那为什么我们需要`addi`这个指令呢？（RISC-V提出了最小指令集的要求）这是因为第一种写法要求从`memory`加载数据，这一操作相对较慢，而直接使用`immediate value`可以利用寄存器序列中的`temporary`(专门用于存储临时值的寄存器)来实现运算.

### Decision Making

什么是`Decision Making`?就是我们在高级语言中常用的`if`判断等.

