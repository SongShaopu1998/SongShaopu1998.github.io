---
layout:		post
title:		Stanford CS144
date:		2024-02-15
author:		shaopu
header-img:	img/code.png
catalog:	true

tags:
   - C++
   - Computer Network
---

计算机网络的层级架构（这里使用五层）。

- 应用层（`application`）
- 运输层（`transport`）
- 网络层（`network`）
- 数据链路层
- 物理层

在本课程中，数据链路层与物理层被同一归于`link`层。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-15-044501.png" alt="image-20240215124500702" style="zoom:50%;" />

### The Internet Protocol (IP)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-15-044656.png" alt="image-20240215124656606" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-15-044723.png" alt="image-20240215124722474" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-15-045443.png" alt="image-20240215125443734" style="zoom:50%;" />

**IPV4 Datagram**:

![image-20240215125521378](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-15-045521.png)

其中，`TTL`用来避免packets looping forever的现象。`Protocol ID`的作用是告知接收方对应的协议应该使用哪一种。

### TCP Byte Stream

接下来，课程更加深入的带领我们了解了TCP Byte Stream，从三次握手（`Syn,syn/Ack, Ack`）的建立连接过程开始，建立由`IP address`和`TCP Port`这两个信息构建的客户端与服务端之间的连接。

- **IP Address**: network layer address
- **TCP Port**: Transport layer address

连接被建立后，在客户端与服务端之间通过许多`routers`不断跳转，这些跳转借由路由器中的`forwarding table`实现，通过选择匹配度最高的记录条目实现跳转（`Default`是最general的）

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-15-145905.png" alt="image-20240215225904403" style="zoom:50%;" />

### Two Principles

1. Layering
2. Encapsulation

`Encapsulation`的一个应用是VPN（`Virtual Private Network`）：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-16-135834.png" alt="image-20240216215834393" style="zoom:50%;" />

指向web server的数据包被封装在指向VPN Gateway的数据帧内。

 ### Network Byte Order

由于不同的处理器有不同的`endianness`设置（e.g. x86是小端，ARM是大端），所以网络包的发送方和接收方需要在`endianness`设置上达成一致，所以规定：

- **Network byte order is big endian**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-16-151326.png" alt="image-20240216231325932" style="zoom:50%;" />

这可能会导致处理器本身的端序和网络包内的端序不一致，于是我们需要一些方法来比较和转化：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-16-151510.png" alt="image-20240216231510399" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-16-151536.png" alt="image-20240216231536753" style="zoom:50%;" />

### IPV4

IPV4地址为32位长度，通过使用`netmask`来决定机器是否位于同一个网络中：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-17-111858.png" alt="image-20240217191857517" style="zoom:50%;" />

在传统的IPV4地址分配中，IP地址的分配把IP地址的32位按每8位为一段分开。这使得前缀必须为8，16或者24位。因此，可分配的最小的地址块有256（24位前缀，8位主机地址，28=256）个地址，而这对大多数企业来说太少了。大一点的地址块包含65536（16位前缀，16位主机，216=65536）个地址，而这对大公司来说都太多了。

> Network + host
>
> - Network to get to correct network (administrative domain)
> - Host to get to correct device in network (within administrative domain)
>
> Origianally 3 classes of addresses: class A, class B, class C
>
> <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-17-112225.png" alt="image-20240217192225553" style="zoom:50%;" />

为了解决上述问题，`Classless Inter-Domain Routing (CIDR)`被使用，允许不局限于8/16/24位的前缀网络段被使用。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-17-112324.png" alt="image-20240217192323555" style="zoom:50%;" />

IPV4地址的分配如今由ICANN负责，这些任务曾由其它组织（特别是[IANA](https://zh.wikipedia.org/wiki/IANA)）代表[美国政府](https://zh.wikipedia.org/wiki/美国政府)来执行。该机构将/8的网络地址段给予Regional Internet Registries (RIRs)，RIRs负责地球上不同的地理区域（非洲，美洲，e.g.）

### Longest Prefix Match

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-17-153740.png" alt="image-20240217233739388" style="zoom:50%;" />

### ARP

`Address Resolution Protocol(ARP)`协议用于寻找已知IP地址，确定对应的数据链路层地址。一般的数据链路层地址为48bit（`Ethernet`），由冒号分隔。

一个值得注意的点在于，虽然MAC地址和IP地址根据网络分层的概念，是完全解耦的，但在实际的应用中情况未必如此。比如，一种常见的情况是单个主机拥有多个IP地址，分配给他当中的每一个`interface`，这是由于网络掩码的概念导致的。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-19-064727.png" alt="image-20240219144727304" style="zoom:50%;" />

比如在上图中，如果网关的IP地址是唯一的，为了让网关和B处于同一网络段中，netmask必须为128.0.0.0，而这意味着A（192.168.0.5）也会和他们位于统一网络中，这显然不是我们希望发生的（netmask失去了意义）。正因如此，我们 常见到如下配置：网关或者路由器具有多个网卡，他们分别配备了不同的MAC地址和IP地址：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-19-065730.png" alt="image-20240219145729432" style="zoom:50%;" />

在实际的传输过程中，主机A想要发送一个网络包到主机B，发现B和自己不在一个网络中，于是先将网络包传送到A指定的网关内，即在`destination link addr`内填入网关的MAC地址，之后在从网关将数据包传送到B上，需要注意，**无论在哪一个传送阶段，IP数据包内的目的地址始终是B主机。**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-19-070100.png" alt="image-20240219150059673" style="zoom:50%;" />

于是接下来的问题变成了，主机A需要向网关发送数据包，由于网关和主机A位于同一个网络中，所以**数据包的发送是通过交换机中的MAC地址表实现的**，那么网关的MAC地址要如何获取呢？这就是ARP的用途了。设备会维护ARP缓存表，其中的缓存香会在一段时间内过期。

ARP采用简单的`request-reply`方法：

- Request: Who has network address X?
- Reply: I have network address X.

请求通过广播(broadcast)的形式发送，回复一般采用单播的方法，仅发送给先前发出请求的地址。但一些其他的可能也包括广播回复，这样可以加速更新其他设备中的ARP缓存表。ARP缓存表会在request和reply时都（可能）进行更新。

> 无回报的ARP（gratuitous ARP），它是指主机发送ARP查询（广播）自己的IP地址，当ARP功能被开启或者是端口初始配置完成，主机向网络发送无回报的ARP来查询自己的IP地址确认地址唯一可用。作用：
>
> 1. 确定网络中是否有其他主机使用了IP地址，如果有应答则产生错误消息。
> 2. 无回报的ARP可以做更新ARP缓存用，网络中的其他主机收到该广播则在缓存中更新条目，收到该广播的主机无论是否存在与IP地址相关的条目都会强制更新，如果存在旧条目则会将MAC更新为广播包中的MAC。

ARP报文格式：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-19-130826.png" alt="image-20240219210826338" style="zoom:50%;" />

例子：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-19-131009.png" alt="image-20240219211009524" style="zoom:50%;" />

|                           | Request            | Reply              |
| ------------------------- | ------------------ | ------------------ |
| Hardware                  | 1 (Ethrenet)       | 1 (Ethrenet)       |
| Protocol                  | 0x0800 (IP)        | 0x0800 (IP)        |
| Hardware Length           | 6 (48bit Ethernet) | 6 (48bit Ethernet) |
| Protocol Length           | 4 (32bit IP)       | 4 (32bit IP)       |
| Opcode                    | 1 (Request)        | 2 (Reply)          |
| Source hardware addr      | 68:a8:6d:05:85:22  | 0:18:e7:f3:ce:1a   |
| Source protocol addr      | 192.168.0.5        | 192.168.0.1        |
| Destination hardware addr | ff:ff:ff:ff:ff:ff  | 68:a8:6d:05:85:22  |
| Destination protocol addr | 192.168.0.1        | 192.168.0.5        |

### TCP

三次握手建立连接：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-030634.png" alt="image-20240221110633587" style="zoom:33%;" />

四次挥手断开连接：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-030710.png" alt="image-20240221110710396" style="zoom:33%;" />

#### TCP Service model

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-031325.png" alt="image-20240221111325135" style="zoom:50%;" />

TCP通过4种方法确保可靠传输：

1. 在接收到数据后，会发送确认消息告知发送成功；(REF: [zhihu](https://zhuanlan.zhihu.com/p/439614017))
2. 使用checksum检测数据是否有损坏
3. 利用sequence number检测丢失的数据
4. 利用flow-control防止发送者overrunning

TCP的拥塞控制机制会确保将网络流量均匀划分在该网络中的所有连接上。

#### TCP segment format

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-032822.png" alt="image-20240221112822771" style="zoom:50%;" />

- `source port`在另一侧的主机回复消息时，会作为`destination port`被传送。

- `sequence number`表示发送者即将发送的数据包的1st byte的位置(也可以理解为当前成功发送的数据位数)，`acknowledgement sequence #`表示接收者期待的下一个byte的位置(当前成功接收的数据位数)：

  <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-035917.png" alt="image-20240221115917283" style="zoom:50%;" />

  TCP协议拼凑接收到的数据包时，会通过seq来确定顺序，从而判断是否有数据包丢失。而在每一次发包、收包的过程中，接收方如何告知发送方数据已经收到？通过接收方的ack=发送方的seq+发送方的len。

- `checksum`计算的是entire header+data

- `ACK`字段表示`acknowledgement number`字段是否有效

- `SYN`：part of the three-way handshake

- `FIN`: part of the closing signal of one direction

- `PSH`: 如果设置为1，则在接收到数据后尽快交付给上层应用，而不是等待缓存满了之后再交付（time-critical data）

#### Unique ID of a TCP connection

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-044658.png" alt="image-20240221124657525" style="zoom:50%;" />

1. 为了确保每次的ID是独特的，对于同一主机上的每一个新连接，都会增加`source port`
2. 但当有大量连接突然出现时，上述操作仍有可能导致重复，所以还会利用ISN来减少重复的可能性，一个新连接的ISN是随机的

### UDP

UDP与TCP不同，他不是一个基于连接的协议。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-082517.png" alt="image-20240221162517419" style="zoom:50%;" />

当需要数据时，一个主机向另一个设备发送请求即可，企业不保证数据传送的有序性和一定到达。UDP的数据格式也比TCP简单很多。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-082625.png" alt="image-20240221162625653" style="zoom:50%;" />

### ICMP

网络层依靠如下几个机制运行：

1. **IP**: The creation of IP datagrams & Hop-by-hop delivery from end to end
2. **Routing Tables**: Algorithms to populate router forwarding tables
3. **Internet Control Message Protocol (ICMP)**: Communicates network layer information between end hosts and routers & reports error conditions & helps us diagnose problems

ICMP协议在网络层之上运行（transport layer），一种常见的情况是当路由器在转发表内找不到对应的路径时，会通过ICMP协议向发送消息的主机发送一个`Destination Network Unreachable`的消息：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-153550.png" alt="image-20240221233549885" style="zoom:50%;" />

#### ICMP Service Model

- Reporting Message: Self-contained message reporting error
- Unreliable: Simple datagram service - no retires

当路由器打算向主机返回一个报错信息时：

1. 从接收的IP数据包中取出前8个byte，以及IP header，结合type+code组成ICMP message
2. 将ICMP message放入新的IP data部分内，设定IP source addr为router，传递回原本的主机

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-165852.png" alt="image-20240222005851679" style="zoom:50%;" />

一些常用的ICMP message type:

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-170424.png" alt="image-20240222010423660" style="zoom:50%;" />

ICMP最常见的使用场景为ping和traceroute指令：

#### ping

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-173105.png" alt="image-20240222013105149" style="zoom:50%;" />

#### traceroute

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-21-173158.png" alt="image-20240222013158116" style="zoom:50%;" />

`traceroute`指令相对于`ping`则要稍微复杂一些，`traceroute`指令可以用于探测两个主机之间经过的传输路径和每个hop之间需要的传输时间。对于第i次指令传输的开始，主机A使用UDP进行传输，并将TTL(`Time-to-Live`)设置为i（第一次为1，第二次为2，以此类推），如此一来，当TTL为0时，路由器将强迫数据包返回，于是路由器会将ICMP的message设置为`TTL expired`对应的代码，并将数据传回主机A，主机A便可以借助其发出数据包的时间和接收到数据包的时间判定此次hop的传输时间。

`traceroute`在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当`traceroute` 收到这个消息时，便知道目的地已经到达了。

### End-to-End Argument

这篇论文先前读过，具体就不在这里赘述。在原本的`end-to-end argument`中，允许在中间层添加一些机制来提高整个系统的运行效率，比如在Wi-Fi中，由于无线传输的TCP接收的成功率只有50-80%，远不及有线传输的99.99%，所以在另一侧的主机收到数据包后，会返回一个`link layer acknowledgement`给发送端，否则发送端会重复发送数据包。

但是在`strong end-to-end argument`中，禁止了在中间层添加这种机制，两者各有利弊。

### Error Detection: 3 Schemes

三种错误检测的方法：CRC (ethernet)、MAC (TLS)、checksum (IP)。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-22-151455.png" alt="image-20240222231454799" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-22-151632.png" alt="image-20240222231632631" style="zoom:50%;" />

#### checksum

IP, TCP, UDP均适用ones's complement checksum算法，该算法步骤如下：

1. 将校验和设置为0，之后将数据的每个16bit的字相加
2. 对于进位，使用循环进位，即添加到结果的末尾（e.g. 0x8000+0x8000=0x0001）
3. 对结果取反，放到checksum位置中

校验步骤如下：

反码求和，结果应当为0xffff，如果不是，则说明发生错误。

校验和检测很容易计算，速度也比较快。但是他只具备检测`single bit error`的能力。

#### Cyclic Redundancy Check (CRC)

循环冗余校验码被用于数据链路层的ethernet错误检测，很容易在硬件中实现，并可以实现增量计算（`incremental computation`），也被称为多项式编码。

多项式编码的基本思想是将位串看成是系数为0或1的多项式，一个k位帧看成是一个k-1次多项式的系数列表；多项式的算术运算以2为模来完成，加法没有进位，减法没有借位（都等同于异或）。

使用多项式编码时，发送方和接收方必须先商定一个**生成多项式**$$G(x)$$，其最高位和最低位必须为1，为了计算多项式$$M(x)$$的CRC，他必须比$$G(x)$$长。计算CRC的算法如下：

1. 假设$$G(x)$$的阶为r，在帧的低位端加上r个0位，使得现在为m+r位，设新的多项式为$$x^rM(x)$$
2. 利用模2除法，用对应于$$G(x)$$的位串去除对应于$$x^rM(x)$$的位串
3. 利用模2减法，从对应于$$x^rM(x)$$的位串中减去余数（总是小于等于r位），该结果作为将被传输的带校验和的帧，设为$$T(x)$$

显然$$T(x)$$可以被$$G(x)$$除尽，如果不能，说明传输过程中出现问题。

CRC可以检测如下错误：

- 一位错误
- 两个独立的一位错误
- 奇数个位发生错误
- 带r个校验位的多项式编码可以检测到所有长度小于等于r的突发错误（突发错误：burst of errors, 初始位是1，然后是0和1的混合，最后一位也是1）
- 如果突发错误长度是r，不正确的帧被当作有效帧的概率是$$1/2^{r-1}$$
- 如果突发错误长度是r+1，...的概率是$$1/2^r$$

证明可以参考*Computer Networks (Fifth version)*.

#### Message Authentication Code (MAC)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-22-164109.png" alt="image-20240223004109462" style="zoom:50%;" />

该算法主要用于保护敌对攻击，由于翻转M任意一个bit之后得到的C都是随机的，所以我们并不能确保一定能够检测出某种类型的错误，所以说他的检测效果实际上没有CRC好。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-22-164414.png" alt="image-20240223004414294" style="zoom:50%;" />

### Finite State Machine

以TCP为例：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-23-065751.png" alt="image-20240223145750948" style="zoom:50%;" />

### Reliable Communications

为了实现流量控制，我们想要做到发送端的发送频率不要超过接收端的最大承载能力，这需要接收端给发送者反馈，一般有两种方法实现：

- Stop and wait
- Sliding window

#### Stop-and-Wait

在任意时刻，最多只有一个数据包在传送中；当发送端接收到ack后，发送新数据，如果其发现timeout，则sender重新发送当前数据。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-23-084613.png" alt="image-20240223164613598" style="zoom: 33%;" />

注意下图中的第四种情况：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-23-084641.png" alt="image-20240223164641134" style="zoom: 33%;" />

为了辨别发送的数据是重复发送的数据还是新数据，对发送的数据包和ack使用`1-bit counter`。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-23-084801.png" alt="image-20240223164801468" style="zoom:33%;" />

#### Sliding window

Stop-and-Wait的问题在于主机的计算资源没有得到充分利用，空闲时间太多（在等待数据包in flight的过程），滑动窗口协议的特点如下：

- Generalization of stop-and-wait: allow multiple un-acked segments
- Bound on numbewr of un-acked segments, called window
- **Can keep pipe full**

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-23-152937.png" alt="image-20240223232937414" style="zoom:50%;" />

在TCP的滑动窗口协议中，发送者为每一帧配备一个序列号，就是先前提到过的sequence number。发送端维护三个变量：

- `Send window size` (SWS, buffer up to SWS segments)
- `Last ack received` (LAR)
- `Last segment sent` (LSS)

并保证：$$(LSS-LAR)\le SWS$$，即确保in flight的帧数不要超过窗口长度。

而对于接收端，也维护三个变量：

- `Receive window size` (RWS)
- `Last acceptable segment` (LAS)
- `Last segment received` (LSR)

并保证：$$(LAS-LSR)\le RWS$$​，即确保in flight的帧数不要超过接收窗口长度。如果接收的数据包序列号小于LAS，则发送ACK。

不论是发送端还是接收端端窗口，本质上都是缓冲区。

滑动窗口协议可以分为两种，**Go-back-N**和**Selective-Repeat**。Go-back-N使用**cumulative acks**，即按照顺序从前往后ack，如果在当前窗口内有一个分组没有被接收，则之后到达的所有分组返回的ack仍然是那个丢失的分组，超时重传需要重传之后的所有分组；而**selective repeat**则不需要完全按照顺序ack，对于期望的分组（按照顺序无遗漏的）交付上层，如果期望的分组没有得到，就先缓存本地，这样之后超时重传也只需要重传丢失的那些分组即可，缓存的分组不需要再次ack。

> 所以，如果RWS为1，那么情况退化为go-back-n.

由于可能的超时重传的触发，滑动窗口协议对sequence space也有要求：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-23-154738.png" alt="image-20240223234737979" style="zoom:33%;" />

考虑RWS=SWS的情况，如果所有的数据包全部发出，但是所有的ack都没有传回，则我们需要让sequence space为RWS+SWS以便在下次接收所有数据包时知晓是所有旧的数据包还是新的下一组数据包：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/2024-02-23-155637.png" alt="image-20240223235636965" style="zoom:50%;" />

