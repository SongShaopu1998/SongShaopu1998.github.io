---
layout:		post
title:		CS基础课程
subtitle:	CS 61A
date:		2021-7-04
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
    - Python
    - CS基础课程笔记

---

## HW1

### Q2

问题转化的想法：选出两个最大的数，并计算其平方和，其实也就是在计算最大的数值平方组合

```python
max(a*a+b*b,b*b+c*c,a*a+c*c)
```



### Q3

摒弃遍历顺序正序的想法，在此题目中，倒序遍历是最方便的:

```python
factor = n - 1
while factor < n:
	if n % factor == 0:
		return factor
	factor -= 1
```



### Q4

`if_function(cond(), true_func(), false_func()`中，会先执行其中的函数，之后将其返回值传入主函数。所以执行的过程一定是`true_func()->false_func()`，执行结果根据提示分别为42与47，又因为`statement`函数执行结果仅为47，所以一定是`true_func()`对应47，那么`false_func()`对应42，根据之前的执行顺序，条件判断函数`cond()`应当设定为`false`。

```python
if cond():
	return true_func()
else:
	return false_func()
```

同时把握下图：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210705172319.jpg" alt="Snipaste_2021-07-05_17-20-24" style="zoom:80%;" />

### Q5

整数除法：**//**

## Lab1

### Veritasiness

```python
>>> 1 and 3 and 10 and 15
>>> 15
```

执行顺序为**自左至右**！

### Coding Practice

努力把代码写的具有被语言本身的特性，看起来更加简洁：

```python
def falling(n, k):
    """Compute the falling factorial of n to depth k."""
    total, stop = 1, n-k
    while n > stop:
        total, n = total*n, n-1
    return total
```

## F20 Lecture 4

### lambda

定义一个`search`函数，找到满足条件的`x`：

```python
def search(f):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x):
        x += 1
    return x
```

现在我们想要做一个`inverse`函数，作为反函数求值器，课上给出的解法如下：

```python
def inverse(f):
	return lambda y:search(lambda x:f(x)==y)
```

对于这个问题，我们可以做如下分析：

在`search`函数中，**条件**被设定为`f(x)`；而在`inverse`函数中，我们的目标是通过给出的函数`f`，可以对任意`y`值获取满足条件`f(x)==y`的`x`。

如果使用`lambda`操作，很方便的一点是可以借助`lambda`的匿名特点，表示我们需要的**条件**。因为我们要求的是反函数中的`x`，但是又需要引入未知数`x`，此时如果是通过`def`的形式引入变量`x`，就显得冗余，因为在`search`函数内部还有一个我们会真正用到的`x`，而匿名函数`lambda`恰好解决了这一问题。同样地，`lambda`也可以用于引入参数`y`。

而如果使用`def`的形式定义函数，则最方便的办法是先将`search`函数更改为如下形式：

```python
def search(f, y):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x) == y:
        x += 1
    return x
```

`inverse`函数做如下定义：

```python
def inverse(f):
    def SetY(y):
        return search(f, y)
    return SetY
```

如果我们选择不更改`search`函数，则`inverse`函数：

```python
def inverse(f):
    def SetY(y):
        # 因为只有在这个frame里才需要用到x，所以选择在另一个函数内部定义SetX，其实是和匿名函数一个道理
        
        def SetX(x):
            return f(x) == y
        return search(SetX)
    return SetY
```

这里要学习的还有从特例到抽象的推导思维，这有助于我们快速构建出程序结构。先从开平方根函数的特例开始：

```python
# 一个平方查找函数

def is_square_of_4(n):
    return square(4) == n
# 一个平方根查找函数

def is_sqrt_of_16(x):
    return square(x) == 16
# 利用search函数寻找x：

ans = search(is_sqrt_of_16)
# 扩充使用案例到16->n：

def sqrt(n):
	def is_sqrt_of_n(x):
    	return square(x) == n
    return search(is_sqrt_of_n)
# 扩充平方根函数，设计inverse,从内向外，逐层添加：

def inverse(f):
    def is_inverse_of_f(y):
        def is_inverse_of_y(x):
            return f(x) == y
    	return search(is_inverse_of_y)
    return is_inverse_of_f
```



调用函数：

```python
# e.g.

sqrt = inverse(square)
Ans = sqrt(256)
```

这里的**256**就是函数中的`y`参数，这也是为什么要把`return`写做`lambda y:...`的原因，我们要先给到参数`y`。

### call expression中的执行顺序

为什么不会出现``if_(c,t,f)`这种形式？因为这是一个`call expression (which applies a function to some arguments)`，而根据如下的evaluation规则，这种函数设计很容易出现问题，所有子表达式均要提前被执行：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210708215753.png" alt="image-20210708215746570" style="zoom:67%;" />

## Hog（Higher Order Function）

### Q8 Test

>​     \>>> dice = make_test_dice(3, 1, 5, 6)
>
>​     \>>> averaged_roll_dice = make_averaged(roll_dice, 1000)
>
>​     \>>> # Average of calling roll_dice 1000 times
>
>​     \>>> # Enter a float (e.g. 1.0) instead of an integer
>
>​     \>>> averaged_roll_dice(2, dice)

最终的结果为**6.0**。其中部分函数如下：

```python
def make_test_dice(*outcomes):
    """Return a die that cycles deterministically through OUTCOMES.

    >>> dice = make_test_dice(1, 2, 3)
    >>> dice()
    1
    >>> dice()
    2
    >>> dice()
    3
    >>> dice()
    1
    >>> dice()
    2

    This function uses Python syntax/techniques not yet covered in this course.
    The best way to understand it is by reading the documentation and examples.
    """
    assert len(outcomes) > 0, 'You must supply outcomes to make_test_dice'
    for o in outcomes:
        assert type(o) == int and o >= 1, 'Outcome is not a positive integer'
    index = len(outcomes) - 1

    def dice():
        nonlocal index
        index = (index + 1) % len(outcomes)
        return outcomes[index]

    return dice
```

```python
def roll_dice(num_rolls, dice=six_sided):
    """Simulate rolling the DICE exactly NUM_ROLLS > 0 times. Return the sum of
    the outcomes unless any of the outcomes is 1. In that case, return 1.

    num_rolls:  The number of dice rolls that will be made.
    dice:       A function that simulates a single dice roll outcome.
    """
    # These assert statements ensure that num_rolls is a positive integer.
    
    assert type(num_rolls) == int, 'num_rolls must be an integer.'
    assert num_rolls > 0, 'Must roll at least once.'
    i, sum = 0, 0
    flag_1 = False
    while i < num_rolls:
        res = dice()
        if res == 1:
            flag_1 = True
        else:
            sum += res
        i += 1
    if flag_1:
        sum = 1
    return sum
```

这要涉及到的知识点是`Higher Order Function`，以及一个`nonlocal`关键字。需要注意的是，只要`[f1=make_test_dice]`这个frame没有变，也就是说我们没有在另一个`[f2=make_test_dice]`里操作，那么无论我们执行多少次`dice(*args)`，变量`index`的值始终是循环的，因为根据`environment diagram`的原则，它的作用域`f1`没有消失。

### Q7

在Problem 7提供的样例中，有几个有趣的`Higher Order Function`：

```python
def say_scores(score0, score1):
    """A commentary function that announces the score for each player."""
    
    print("Player 0 now has", score0, "and Player 1 now has", score1)
    return say_scores
```

```python
def announce_lead_changes(last_leader=None):
    """Return a commentary function that announces lead changes."""

    >>> f0 = announce_lead_changes()
    >>> f1 = f0(5, 0)
    Player 0 takes the lead by 5
    >>> f2 = f1(5, 12)
    Player 1 takes the lead by 7
    >>> f3 = f2(8, 12)
    >>> f4 = f3(8, 13)
    >>> f5 = f4(15, 13)
    Player 0 takes the lead by 2

    def say(score0, score1):
        if score0 > score1:
            leader = 0
        elif score1 > score0:
            leader = 1
        else:
            leader = None
        if leader != None and leader != last_leader:
            print('Player', leader, 'takes the lead by', abs(score0 - score1))
        return announce_lead_changes(leader)

    return say
```

其中的`say`函数，返回值为`announce_lead_changes(leader)`，因为这是一个`call expression`，所以会重新建立一个`environment diagram`，其中的`formal parameter`由刚执行完毕的`say`函数给出，并作为即将执行的`announce_lead_changes`的参数，又传入以它为`parent`的`say`函数中使用。

```python
def both(f, g):
    """Return a commentary function that says what f says, then what g says."""

    NOTE: the following game is not possible under the rules, it's just
    an example for the sake of the doctest

    >>> h0 = both(say_scores, announce_lead_changes())
    >>> h1 = h0(10, 0)
    Player 0 now has 10 and Player 1 now has 0
    Player 0 takes the lead by 10
    >>> h2 = h1(10, 8)
    Player 0 now has 10 and Player 1 now has 8
    >>> h3 = h2(10, 17)
    Player 0 now has 10 and Player 1 now has 17
    Player 1 takes the lead by 7
    
    def say(score0, score1):
        return both(f(score0, score1), g(score0, score1))
    return say
```

**母函数返回子函数的同时，子函数返回母函数**--这样做的好处在于**一直跟随`leader`的变化，同时可以连续使用`(score0,score1)`的格式**。在CS 61A提供的文档中，表明这是`commentary function`的常用写法（即利用`Higher Order Function`）.

![image-20210713192008394](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210713192015.png)

## Disc 02(Higher Order Function)

一道很有趣的**HOF**题目：

```python
y = "y"
h = y

def y(y):
    h = "h"
    if y == h:
        return y + "i"
    y = lambda y: y(h)
    return lambda h: y(h)

y = y(y)(y)
```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210714155901.png" alt="image-20210714155901223" style="zoom: 67%;" />

进行变量查找时，先在该作用域内查找对应的变量名称和值，如果找不到，进入其`parent frame`中查找，依此递推。所以在程序段最后调用`y`时，它所指向的应该是`global frame`中的`func y(y)`，而不是`func y(y) frame`中的$$\lambda(y)$$ . 与之相反的是，`return lambda h: y(h)`中的`y`则是来自于本`frame`中的`y = lambda y: y(h)`.

## F20 Lecture 8（Recursion）

主要围绕**递归**进行讨论：

递归的主要原则就是通过函数的递归，逐步将原始问题转化为更简单的问题，最终将问题定位到**base case**上，递归结束，并给之前使用的函数逐个提供返回值。

递归的依据是数学归纳法，即在证明（或者说给出）`k=1`和`k=n-1`的解法之后，即可证明（推断出）`k=n`的情况。**我们也可以依据这一原则验证我们写出的递归函数是否正确，即分别验证`k=1`的情况，并假定`k=n-1`的情况是正确的，观察我么能否得到需要的`k=n`的结果。**

在写递归函数时，不要尝试推导递归过程，**尝试用抽象思维定义函数**。

### mutual recursion

此种情况适用于单一递归函数解决起来比较繁琐，或者不适于解决的问题：

*e.g. 银行卡号计算问题：*

```python
def sum_digits(n):
	if n < 10:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return sum_digits(all_but_last) + last

def luhn_sum(n):
    if n < 10:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return luhn_sum_double(all_but_last) + last
    
def luhn_sum_double(n):
    all_but_last, last = n // 10, n % 10
    last = sum_digits(2*last)
    if n < 10:
        return last
    else:
        return luhn_sum(all_but_last)+last
```

这里的`mutual recursion`实质上是针对奇偶两种情况的讨论，而也正因为如此，我们可以将两个函数合并到一个函数内来写：

```python
def luhn_sum(n, i=1):
    if n < 10:
        return sum_digits(2*n) if i % 2 == 1 else n
    else:
        all_but_last, last = n // 10, n % 10
        if i % 2 == 1:
            i += 1
            return luhn_sum(all_but_last, i) + last
        else:
            i += 1
            last = sum_digits(2*last)
            return luhn_sum(all_but_last, i) + last
```

只要设置一个奇偶指示标志即可。

### trick

遇到复杂的递归问题如何解决？我们要设想在问题解决的前一步乃至前几步的变化，比如**汉诺塔**问题，我们正是借助于对`k=n-1`的情况的了解，进行参数变换，并将`k=n`的问题成功转化为三个步骤。再比如这个问题：

> n个自然数中取出r个数字的组合

首先我们举例：654321，6选4，我们可以将问题分为如下几种情况：

> 1. 固定6，问题转化为从54321这5个数字中选3个数
> 2. 固定5，问题转化为从4321这4个数字中选3个数（无6）
> 3. 固定4，问题转化为从321这3个数字中选3个数（无56）

一开始的思路是想把这四步写成递归，但是发现存在问题：这几步是分别独立的步骤，**我们无法在递归程序中先固定6，之后又不考虑6**，也就是说不可能按照时间顺序先后发生。

于是，我们将上边的**情况1**的后续步骤写出来：

> 固定6，问题转化为从54321这**5**个数字中选**3**个数->固定4（已有64），问题转化为从5321这**4**个数字中选**2**个数->固定3（已有456），问题转化为从521这**3**个数字中选**1**个数......

这个步骤，是可以写作递归的！于是前边的几种情况，我们可以考虑写成循环(`iteration`).（**这也符合将递归变成一个simpler question的准则，转化后的问题又是一个可以写成一个有iteration的，可以继续分解的子问题...**）

于是我们接下来思考，递归的`base case`是什么？通过上边的案例，不难发现是`r=1`。在`base case`时，要做什么？就是把之前已经被固定（选择好的）数字输出，**为了达到这一目的，我们将之前遍历过的数字用数字保存起来**。

```python
a = []
for i in range(100):
    a.append(0)

def list_r_from_n(n,r):
    for i in range(n,r-1,-1):
        # 保存遍历过的数字
        
        a[r]=i
        # base case:
        
        if r == 1:
            for j in range(a[0],0,-1):
                print(a[j])
            print(end='\n')
        # 不可以a.clear()
        
        else:
            list_r_from_n(n - 1, r - 1)

a[0]=r
```

注意在保存遍历过的数字时，不要使用`a.append(i)`和`a.clear()`的方式，因为最外层的循环并非仅仅会经历`n-r+1`次，直接清空整个列表会导致排在前边的数据缺失。

此外，递归也可以运用在`higher order function`中，如：

```python
def repeat(i):
    if i == 0:
    	return x
    else:
    	return f(repeat(i - 1))
return repeat
```

### Tree recursion

#### Order of Recursive Calls

![image-20210720182353317](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210720182400.png)

#### Tree Recursion分析方法

![image-20210720182553555](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210720182553.png)

解决树递归的基本方法是进行`recursive decomposition`，尝试找到问题更简单的**案例**。比如`Counting Partitions`的例子，考虑`count_partitions(6,4)`就可以分解为两个子问题：

1. **至少有一个**4->count_partitions(2,4)
2. **不使用**4->count_partitions(6,3)

之后再将例子拓展即可：

```python
with_m = count_partitions(n-m,m)
without_m = count_partitions(n,m-1)
return with_m + without_m
```

根据这个方法，可以写出问题

>n个自然数中取出r个数字的组合

的另一种解法：

将问题`list_r_from_n(6,4)`划分为两个子问题：

1. 数字组合中**不包含6**->list_r_from_n(5,4)
2. 数字组合中**至少包含一个6**->list_r_from_n(5,3)

将例子拓展：

```python
def list_r_from_n(n, r):
    if r == 0:
        for j in range(a[0], 0, -1):
            print(a[j], end='')
        print(end='\n')
        return 0
    if n < r:
        return 0
    else:
        # 进入else，先把正在讨论的数固定住
        a[r] = n
        list_r_from_n(n - 1, r - 1)
        list_r_from_n(n - 1, r)

a[0] = r
```

类似的例子还出现在*lab04*和*disc04*当中:

#### Lab04

```python
def max_subseq(n, t):
    """Return the maximum subsequence of length at most t that can be found in the given number n."""
    
    if t == 0:
        return 0
    if n // 10 == 0:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return max(max_subseq(all_but_last, t - 1) * 10 + last, max_subseq(all_but_last, t))
```

还是用之前的思路分析一遍问题：

假设n为34521，t为3，问题可以分为两种情况：

1. 3个数的子序列中，不使用n的最后一个数字：则n为3452，t为3
2. 3个数的子序列中，使用n的最后一个数字：则n为3452，t为2，之后使用`10*n+d`的方法将末位固定住

将1与2得到的数字比较大小

#### disc04

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210725151724.png" alt="image-20210725151723769" style="zoom: 50%;" />

或者，当问题不再能简单的二分时，我们可以通过循环的方式统计所有可能性：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210725162045.png" alt="image-20210725162045374" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210725162056.png" alt="image-20210725162056225" style="zoom:50%;" />

## HW2(Recursion+Higher Order Function)

在对应的**HW**中，给出了将`Tree Recursion`与`Higher Order Function`相结合的例子.

同时注意在使用递归时，如果我们有多个数据需要追踪，可以写一个`helper`函数：

```python
def count_coins(total):
    """Return the number of ways to make change for total using coins of value of 1"""
    
    def count_helper(total, m):
        if total == 0:
            return 1
        elif total < 0:
            return 0
        elif m is None:
            return 0
        elif total < m:
            return 0
        else:
            return count_helper(total - m, m) + count_helper(total, next_largest_coin(m))
    return count_helper(total, 1)
```

这也是一个`tree recursion`问题，根据处理这类问题的方法，我们尝试寻找一个标准，将问题分为几个更简单的`instance`。依靠`helper`函数，问题转化为：

1. 不用当前最小面值硬币1，则问题转化为使用最小面值硬币`next_largest_coin(1)`，凑齐总价值`total`
2. 至少使用一个面值为1的硬币，则问题转化为使用最小面值硬币1，凑齐总价值为`total-1`

我们将分析写成函数，就是上边的形式。

```python
def pingpong(n):
    """Return the nth element of the ping-pong sequence."""
    
    if n <= 8:
        return n
    else:
        return pingpong(n - 1) + helper(n - 1)

# 决定是要+1还是-1

def helper(n):
    if n <= 7:
        return 1
    else:
        if n % 8 == 0 or num_eights(n) != 0:
            return -helper(n - 1)
        else:
            return helper(n - 1)
```

使用`lambda`函数，在不给出函数名的情况下定义递归：

```python
>>> fact = lambda n: 1 if n == 1 else mul(n, fact(sub(n, 1)))
>>> fact(5)
120

def make_anonymous_factorial():
    """Return the value of an expression that computes factorial."""
    
    return (lambda f: lambda n: f(f,n))(lambda s,x: 1 if x == 1 else mul(x, s(s,sub(x, 1))))
```

**这里理解的点在于，递归的过程实质上是把函数本身也作为了函数的参数，在函数内部调用了函数自己.**

## F20 Lecture 10(List)

1. list的concatenation & repetition

```python
# 将原来的所有元素重复一遍并加上[2,7]元素

[2,7]+lists*2
```

2. Sequence Unpacking

```python
pairs = [[1,2],[2,2],[3,4]]
for x,y in pairs:
if x == y:
	...
```

3. list constructor

```python
list(range(4))
```

### List在Tree Recursion中的使用

#### cats

> ### Problem 7 (3 pt)
>
> Implement `pawssible_patches`, which is a diff function that returns the minimum number of edit operations needed to transform the `start` word into the `goal` word.
>
> There are three kinds of edit operations:
>
> 1. Add a letter to `start`,
> 2. Remove a letter from `start`,
> 3. Substitute a letter in `start` for another.
>
> Each edit operation contributes 1 to the difference between two words.
>
> ```python
> >>> big_limit = 10
> >>> pawssible_patches("cats", "scat", big_limit)       # cats -> scats -> scat
> 
> 2
> >>> pawssible_patches("purng", "purring", big_limit)   # purng -> purrng -> purring
> 
> 2
> >>> pawssible_patches("ckiteus", "kittens", big_limit) # ckiteus -> kiteus -> kitteus -> kittens
> 
> 3
> ```
>
> We have provided a template of an implementation in `cats.py`. This is a recursive function with three recursive calls. One of these recursive calls will be similar to the recursive call in `shifty_shifts`.
>
> You may modify the template however you want or delete it entirely.
>
> If the number of edits required is greater than `limit`, then `pawssible_patches` should return any number larger than `limit` and should minimize the amount of computation needed to do so.
>
> ```python
>>>> limit = 2
> >>> pawssible_patches("ckiteus", "kittens", limit) > limit
> True
> >>> pawssible_patches("ckiteusabcdefghijklm", "kittensnopqrstuvwxyz", limit) > limit
> True
> ```

```python
def pawssible_patches(start, goal, limit):
    """A diff function that computes the edit distance from START to GOAL."""

    if limit < 0:
        return 0
    if start == '':
        return len(goal)
    elif goal == '':
        return len(start)
    elif start[0] == goal[0]:
        return pawssible_patches(start[1:], goal[1:],limit)
    else:
        limit -= 1
        add_diff = pawssible_patches(goal[0] + start, goal,limit)
        remove_diff = pawssible_patches(start[1:], goal,limit)
        substitute_diff = pawssible_patches(goal[0] + start[1:], goal,limit)
        return 1 + min(add_diff, remove_diff, substitute_diff)
```

对于这道问题，我们可以类比之前的`Tree Recursion`递归问题，思考如何把问题抽象化：

对于每一个位置的字符对比，都有增删改三种操作，可以联想之前爬楼梯的问题：每一步都有上1级台阶或者2级台阶这两种情况，只是在这里，增删改这三种操作不简单的是`f(n-1)`这种形式，我们需要自己实现它。所以现在基本可以确定，递归会作用在实现增删改这三种操作上，接下来要完善函数设计，就要思考如下几个问题：

- base case是什么？

首先刨除`limit`这个变量不管，显然在我们在递归至字符串`start`或者`goal`任意一个为空字符串时，递归停止，并返回另一字符串的长度（及需要进行改变的次数）

- 如何进行`recursion decomposition`?

起点很简单，一定是字符串开头的首字母，所以可以分为首字母相同与首字母不同两种情况，如果首字母相同，就不需要利用增删改三者当中的任何一个，那么这个`simpler instance`可以写作：

```python
elif start[0] == goal[0]:
	return pawssible_patches(start[1:], goal[1:],limit)
```

如果首字母不相同，这时候就需要进行增删改的操作，但要注意，我们将`goal`的首位递推的任务交给两者相同的情况，以免发生错误。只要进行了一次更改操作，次数要加1，所又因为题目要求计算最小更改次数，所以每一次，我们都选取这三种操作里需要次数最少的那一个并随之递归：

```python
else:
    limit -= 1
    add_diff = pawssible_patches(goal[0] + start, goal,limit)
    remove_diff = pawssible_patches(start[1:], goal,limit)
    substitute_diff = pawssible_patches(goal[0] + start[1:], goal,limit)
    return 1 + min(add_diff, remove_diff, substitute_diff)
```

最后，为了提高程序运行的效率，我们需要计算何时达到`limit`，于是在每一次更改之后，都将`limit`减小1，在`limit`达到0时，停止递归。

## F20 Lecture 12（Recursion->Tree）

详细阐述了如何使用递归完成关于**树**的各种操作，以及一些`container`的相关操作。

- `sum(iterable[,start])->value`

```python
>>> sum([2,3,[4]],[])
[2,3,4]
```

- `max(iterable[,key=func])->value`

- `all(iterable)->bool`

> Return True if bool(x) is True for all values in x in the iterable. If the iterable is empty, return True.

### Tree

![image-20210727235920957](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210727235928.png)

如何构造一个树？

e.g.

```python
>>> tree(3,[tree(1),tree(2,[tree(1),tree(1)])])
[3,[1],[2,[1],[1]]]
```

定义如下几个函数：

```python
def tree(label, branches=[]):
    return [label] + branches

def label(tree):
    return tree[0]

def branches(tree):
    return tree[1:]

def is_tree(tree):
    if type(tree) != list or len(tree) < 1:
        return False
    for branch in branches(tree):
        if not is_tree(branch):
            return False
    return True

def is_leaf(tree):
    # 判断是否为empty
    
    return not branches(tree)
```

利用这几个基本的函数，可以处理一些更为具体的`Tree Porcessing`，比如构造一个`Fibonacci`树：

```python
def fib_tree(n):
    if n <= 1:
        return tree(n)
    else:
        left, right = fib_tree(n-1), fib_tree(n-2)
        return tree(label(left)+label(right),[left,right])
```

以及一些更高阶的`Tree Processing`函数，比如对叶(`leaves`)进行的操作：

```python
def count_leaves(t):
    # 判断是否为叶结点，常作为base case
    
    if is_leaf(t):
        return 1
    else:
        branch_counts = [count_leaves(b) for b in branches(t)]
        return sum(branch_counts)
    
def leaves(tree):
    '''Return a list containing the leaf labels of tree.'''
    
    if is_leaf(tree):
        return [label(tree)]
    else:
        # 利用sum()函数对list操作的特殊性质
        
        # List of leaf labels for each branch
        
		return sum([leaves(b) for b in branches(tree)],[])
    
def increment_leaves(t):
    '''Return a tree like t but with leaf labels incremented.'''
    
    if is_leaf(t):
        return tree(label(t) + 1)
    else:
        return tree(label(t),[increment_leaves(b) for b in branches(t)])
    
def increment(t):
    '''Return a tree like t but with all labels incremented'''
    
    # 递归结束条件为for循环终止，不需要单独设置base case
    
    return tree(label(t) + 1, [increment_leaves(b) for b in branches(t)])
```

在有了一系列`Tree Processing`的函数之后，我们可以把树打印出来，并控制缩进，以更好的显示：

```python
def print_tree(t,indent = 0):
    print('	' * indent + str(label(t)))
    for b in branches(t):
        print_tree(b, indent + 1)
```

> 在设计递归时，有两种方式：
>
> 1. 使用return的方法控制递归进行
> 2. 将需要跟踪的变量以函数参数的形式传入
>
> 对于第二种方法，如：
>
> ```python
> numbers = tree(3,[tree(4),tree(5,[tree(6)])])
> 
> # 分别统计从root到每一个叶结点的label总和
> 
> def print_nums(t,so_far):
>     so_far = so_far + label(t)
>     if is_leaf(t):
>         print(so_far)
>     else:
>     	for b in branches(t):
>             print_sums(b,so_far)
> ```

