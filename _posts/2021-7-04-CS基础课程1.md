---
layout:		post
title:		CS基础课程
subtitle:	CS 61A
date:		2021-7-04
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
    - Python
    - CS基础课程笔记

---

## HW1

### Q2

问题转化的想法：选出两个最大的数，并计算其平方和，其实也就是在计算最大的数值平方组合

```python
max(a*a+b*b,b*b+c*c,a*a+c*c)
```



### Q3

摒弃遍历顺序正序的想法，在此题目中，倒序遍历是最方便的:

```python
factor = n - 1
while factor < n:
	if n % factor == 0:
		return factor
	factor -= 1
```



### Q4

`if_function(cond(), true_func(), false_func()`中，会先执行其中的函数，之后将其返回值传入主函数。所以执行的过程一定是`true_func()->false_func()`，执行结果根据提示分别为42与47，又因为`statement`函数执行结果仅为47，所以一定是`true_func()`对应47，那么`false_func()`对应42，根据之前的执行顺序，条件判断函数`cond()`应当设定为`false`。

```python
if cond():
	return true_func()
else:
	return false_func()
```

同时把握下图：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210705172319.jpg" alt="Snipaste_2021-07-05_17-20-24" style="zoom:80%;" />

### Q5

整数除法：**//**

## Lab1

### Veritasiness

```python
>>> 1 and 3 and 10 and 15
>>> 15
```

执行顺序为**自左至右**！

### Coding Practice

努力把代码写的具有被语言本身的特性，看起来更加简洁：

```python
def falling(n, k):
    """Compute the falling factorial of n to depth k."""
    total, stop = 1, n-k
    while n > stop:
        total, n = total*n, n-1
    return total
```

## F20 Lecture 4

### lambda

定义一个`search`函数，找到满足条件的`x`：

```python
def search(f):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x):
        x += 1
    return x
```

现在我们想要做一个`inverse`函数，作为反函数求值器，课上给出的解法如下：

```python
def inverse(f):
	return lambda y:search(lambda x:f(x)==y)
```

对于这个问题，我们可以做如下分析：

在`search`函数中，**条件**被设定为`f(x)`；而在`inverse`函数中，我们的目标是通过给出的函数`f`，可以对任意`y`值获取满足条件`f(x)==y`的`x`。

如果使用`lambda`操作，很方便的一点是可以借助`lambda`的匿名特点，表示我们需要的**条件**。因为我们要求的是反函数中的`x`，但是又需要引入未知数`x`，此时如果是通过`def`的形式引入变量`x`，就显得冗余，因为在`search`函数内部还有一个我们会真正用到的`x`，而匿名函数`lambda`恰好解决了这一问题。同样地，`lambda`也可以用于引入参数`y`。

而如果使用`def`的形式定义函数，则最方便的办法是先将`search`函数更改为如下形式：

```python
def search(f, y):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x) == y:
        x += 1
    return x
```

`inverse`函数做如下定义：

```python
def inverse(f):
    def SetY(y):
        return search(f, y)
    return SetY
```

如果我们选择不更改`search`函数，则`inverse`函数：

```python
def inverse(f):
    def SetY(y):
        # 因为只有在这个frame里才需要用到x，所以选择在另一个函数内部定义SetX，其实是和匿名函数一个道理
        
        def SetX(x):
            return f(x) == y
        return search(SetX)
    return SetY
```

这里要学习的还有从特例到抽象的推导思维，这有助于我们快速构建出程序结构。先从开平方根函数的特例开始：

```python
# 一个平方查找函数

def is_square_of_4(n):
    return square(4) == n
# 一个平方根查找函数

def is_sqrt_of_16(x):
    return square(x) == 16
# 利用search函数寻找x：

ans = search(is_sqrt_of_16)
# 扩充使用案例到16->n：

def sqrt(n):
	def is_sqrt_of_n(x):
    	return square(x) == n
    return search(is_sqrt_of_n)
# 扩充平方根函数，设计inverse,从内向外，逐层添加：

def inverse(f):
    def is_inverse_of_f(y):
        def is_inverse_of_y(x):
            return f(x) == y
    	return search(is_inverse_of_y)
    return is_inverse_of_f
```



调用函数：

```python
# e.g.

sqrt = inverse(square)
Ans = sqrt(256)
```

这里的**256**就是函数中的`y`参数，这也是为什么要把`return`写做`lambda y:...`的原因，我们要先给到参数`y`。

### call expression中的执行顺序

为什么不会出现``if_(c,t,f)`这种形式？因为这是一个`call expression (which applies a function to some arguments)`，而根据如下的evaluation规则，这种函数设计很容易出现问题，所有子表达式均要提前被执行：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210708215753.png" alt="image-20210708215746570" style="zoom:67%;" />

## Hog（Higher Order Function）

### Q8 Test

>​     \>>> dice = make_test_dice(3, 1, 5, 6)
>
>​     \>>> averaged_roll_dice = make_averaged(roll_dice, 1000)
>
>​     \>>> # Average of calling roll_dice 1000 times
>
>​     \>>> # Enter a float (e.g. 1.0) instead of an integer
>
>​     \>>> averaged_roll_dice(2, dice)

最终的结果为**6.0**。其中部分函数如下：

```python
def make_test_dice(*outcomes):
    """Return a die that cycles deterministically through OUTCOMES.

    >>> dice = make_test_dice(1, 2, 3)
    >>> dice()
    1
    >>> dice()
    2
    >>> dice()
    3
    >>> dice()
    1
    >>> dice()
    2

    This function uses Python syntax/techniques not yet covered in this course.
    The best way to understand it is by reading the documentation and examples.
    """
    assert len(outcomes) > 0, 'You must supply outcomes to make_test_dice'
    for o in outcomes:
        assert type(o) == int and o >= 1, 'Outcome is not a positive integer'
    index = len(outcomes) - 1

    def dice():
        nonlocal index
        index = (index + 1) % len(outcomes)
        return outcomes[index]

    return dice
```

```python
def roll_dice(num_rolls, dice=six_sided):
    """Simulate rolling the DICE exactly NUM_ROLLS > 0 times. Return the sum of
    the outcomes unless any of the outcomes is 1. In that case, return 1.

    num_rolls:  The number of dice rolls that will be made.
    dice:       A function that simulates a single dice roll outcome.
    """
    # These assert statements ensure that num_rolls is a positive integer.
    
    assert type(num_rolls) == int, 'num_rolls must be an integer.'
    assert num_rolls > 0, 'Must roll at least once.'
    i, sum = 0, 0
    flag_1 = False
    while i < num_rolls:
        res = dice()
        if res == 1:
            flag_1 = True
        else:
            sum += res
        i += 1
    if flag_1:
        sum = 1
    return sum
```

这要涉及到的知识点是`Higher Order Function`，以及一个`nonlocal`关键字。需要注意的是，只要`[f1=make_test_dice]`这个frame没有变，也就是说我们没有在另一个`[f2=make_test_dice]`里操作，那么无论我们执行多少次`dice(*args)`，变量`index`的值始终是循环的，因为根据`environment diagram`的原则，它的作用域`f1`没有消失。

### Q7

在Problem 7提供的样例中，有几个有趣的`Higher Order Function`：

```python
def say_scores(score0, score1):
    """A commentary function that announces the score for each player."""
    
    print("Player 0 now has", score0, "and Player 1 now has", score1)
    return say_scores
```

```python
def announce_lead_changes(last_leader=None):
    """Return a commentary function that announces lead changes."""

    >>> f0 = announce_lead_changes()
    >>> f1 = f0(5, 0)
    Player 0 takes the lead by 5
    >>> f2 = f1(5, 12)
    Player 1 takes the lead by 7
    >>> f3 = f2(8, 12)
    >>> f4 = f3(8, 13)
    >>> f5 = f4(15, 13)
    Player 0 takes the lead by 2

    def say(score0, score1):
        if score0 > score1:
            leader = 0
        elif score1 > score0:
            leader = 1
        else:
            leader = None
        if leader != None and leader != last_leader:
            print('Player', leader, 'takes the lead by', abs(score0 - score1))
        return announce_lead_changes(leader)

    return say
```

其中的`say`函数，返回值为`announce_lead_changes(leader)`，因为这是一个`call expression`，所以会重新建立一个`environment diagram`，其中的`formal parameter`由刚执行完毕的`say`函数给出，并作为即将执行的`announce_lead_changes`的参数，又传入以它为`parent`的`say`函数中使用。

```python
def both(f, g):
    """Return a commentary function that says what f says, then what g says."""

    NOTE: the following game is not possible under the rules, it's just
    an example for the sake of the doctest

    >>> h0 = both(say_scores, announce_lead_changes())
    >>> h1 = h0(10, 0)
    Player 0 now has 10 and Player 1 now has 0
    Player 0 takes the lead by 10
    >>> h2 = h1(10, 8)
    Player 0 now has 10 and Player 1 now has 8
    >>> h3 = h2(10, 17)
    Player 0 now has 10 and Player 1 now has 17
    Player 1 takes the lead by 7
    
    def say(score0, score1):
        return both(f(score0, score1), g(score0, score1))
    return say
```

**母函数返回子函数的同时，子函数返回母函数**--这样做的好处在于**一直跟随`leader`的变化，同时可以连续使用`(score0,score1)`的格式**。在CS 61A提供的文档中，表明这是`commentary function`的常用写法（即利用`Higher Order Function`）.

![image-20210713192008394](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210713192015.png)

## Disc 02(Higher Order Function)

一道很有趣的**HOF**题目：

```python
y = "y"
h = y

def y(y):
    h = "h"
    if y == h:
        return y + "i"
    y = lambda y: y(h)
    return lambda h: y(h)

y = y(y)(y)
```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210714155901.png" alt="image-20210714155901223" style="zoom: 67%;" />

进行变量查找时，先在该作用域内查找对应的变量名称和值，如果找不到，进入其`parent frame`中查找，依此递推。所以在程序段最后调用`y`时，它所指向的应该是`global frame`中的`func y(y)`，而不是`func y(y) frame`中的$$\lambda(y)$$ . 与之相反的是，`return lambda h: y(h)`中的`y`则是来自于本`frame`中的`y = lambda y: y(h)`.

## F20 Lecture 8（Recursion）

主要围绕**递归**进行讨论：

递归的主要原则就是通过函数的递归，逐步将原始问题转化为更简单的问题，最终将问题定位到**base case**上，递归结束，并给之前使用的函数逐个提供返回值。

递归的依据是数学归纳法，即在证明（或者说给出）`k=1`和`k=n-1`的解法之后，即可证明（推断出）`k=n`的情况。**我们也可以依据这一原则验证我们写出的递归函数是否正确，即分别验证`k=1`的情况，并假定`k=n-1`的情况是正确的，观察我么能否得到需要的`k=n`的结果。**

在写递归函数时，不要尝试推导递归过程，**尝试用抽象思维定义函数**。

### mutual recursion

此种情况适用于单一递归函数解决起来比较繁琐，或者不适于解决的问题：

*e.g. 银行卡号计算问题：*

```python
def sum_digits(n):
	if n < 10:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return sum_digits(all_but_last) + last

def luhn_sum(n):
    if n < 10:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return luhn_sum_double(all_but_last) + last
    
def luhn_sum_double(n):
    all_but_last, last = n // 10, n % 10
    last = sum_digits(2*last)
    if n < 10:
        return last
    else:
        return luhn_sum(all_but_last)+last
```

这里的`mutual recursion`实质上是针对奇偶两种情况的讨论，而也正因为如此，我们可以将两个函数合并到一个函数内来写：

```python
def luhn_sum(n, i=1):
    if n < 10:
        return sum_digits(2*n) if i % 2 == 1 else n
    else:
        all_but_last, last = n // 10, n % 10
        if i % 2 == 1:
            i += 1
            return luhn_sum(all_but_last, i) + last
        else:
            i += 1
            last = sum_digits(2*last)
            return luhn_sum(all_but_last, i) + last
```

只要设置一个奇偶指示标志即可。

### trick

遇到复杂的递归问题如何解决？我们要设想在问题解决的前一步乃至前几步的变化，比如**汉诺塔**问题，我们正是借助于对`k=n-1`的情况的了解，进行参数变换，并将`k=n`的问题成功转化为三个步骤。再比如这个问题：

> n个自然数中取出r个数字的组合

首先我们举例：654321，6选4，我们可以将问题分为如下几种情况：

> 1. 固定6，问题转化为从54321这5个数字中选3个数
> 2. 固定5，问题转化为从4321这4个数字中选3个数（无6）
> 3. 固定4，问题转化为从321这3个数字中选3个数（无56）

一开始的思路是想把这四步写成递归，但是发现存在问题：这几步是分别独立的步骤，**我们无法在递归程序中先固定6，之后又不考虑6**，也就是说不可能按照时间顺序先后发生。

于是，我们将上边的**情况1**的后续步骤写出来：

> 固定6，问题转化为从54321这**5**个数字中选**3**个数->固定4（已有64），问题转化为从5321这**4**个数字中选**2**个数->固定3（已有456），问题转化为从521这**3**个数字中选**1**个数......

这个步骤，是可以写作递归的！于是前边的几种情况，我们可以考虑写成循环(`iteration`).（**这也符合将递归变成一个simpler question的准则，转化后的问题又是一个可以写成一个有iteration的，可以继续分解的子问题...**）

于是我们接下来思考，递归的`base case`是什么？通过上边的案例，不难发现是`r=1`。在`base case`时，要做什么？就是把之前已经被固定（选择好的）数字输出，**为了达到这一目的，我们将之前遍历过的数字用数字保存起来**。

```python
a = []
for i in range(100):
    a.append(0)

def list_r_from_n(n,r):
    for i in range(n,r-1,-1):
        # 保存遍历过的数字
        
        a[r]=i
        # base case:
        
        if r == 1:
            for j in range(a[0],0,-1):
                print(a[j])
            print(end='\n')
        # 不可以a.clear()
        
        else:
            list_r_from_n(n - 1, r - 1)

a[0]=r
```

注意在保存遍历过的数字时，不要使用`a.append(i)`和`a.clear()`的方式，因为最外层的循环并非仅仅会经历`n-r+1`次，直接清空整个列表会导致排在前边的数据缺失。

此外，递归也可以运用在`higher order function`中，如：

```python
def repeat(i):
    if i == 0:
    	return x
    else:
    	return f(repeat(i - 1))
return repeat
```

### Tree recursion

#### Order of Recursive Calls

![image-20210720182353317](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210720182400.png)

#### Tree Recursion分析方法

![image-20210720182553555](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210720182553.png)

解决树递归的基本方法是进行`recursive decomposition`，尝试找到问题更简单的**案例**。比如`Counting Partitions`的例子，考虑`count_partitions(6,4)`就可以分解为两个子问题：

1. **至少有一个**4->count_partitions(2,4)
2. **不使用**4->count_partitions(6,3)

之后再将例子拓展即可：

```python
with_m = count_partitions(n-m,m)
without_m = count_partitions(n,m-1)
return with_m + without_m
```

根据这个方法，可以写出问题

>n个自然数中取出r个数字的组合

的另一种解法：

将问题`list_r_from_n(6,4)`划分为两个子问题：

1. 数字组合中**不包含6**->list_r_from_n(5,4)
2. 数字组合中**至少包含一个6**->list_r_from_n(5,3)

将例子拓展：

```python
def list_r_from_n(n, r):
    if r == 0:
        for j in range(a[0], 0, -1):
            print(a[j], end='')
        print(end='\n')
        return 0
    if n < r:
        return 0
    else:
        # 进入else，先把正在讨论的数固定住
        a[r] = n
        list_r_from_n(n - 1, r - 1)
        list_r_from_n(n - 1, r)

a[0] = r
```

类似的例子还出现在*lab04*和*disc04*当中:

#### Lab04

```python
def max_subseq(n, t):
    """Return the maximum subsequence of length at most t that can be found in the given number n."""
    
    if t == 0:
        return 0
    if n // 10 == 0:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return max(max_subseq(all_but_last, t - 1) * 10 + last, max_subseq(all_but_last, t))
```

还是用之前的思路分析一遍问题：

假设n为34521，t为3，问题可以分为两种情况：

1. 3个数的子序列中，不使用n的最后一个数字：则n为3452，t为3
2. 3个数的子序列中，使用n的最后一个数字：则n为3452，t为2，之后使用`10*n+d`的方法将末位固定住

将1与2得到的数字比较大小

#### disc04

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210725151724.png" alt="image-20210725151723769" style="zoom: 50%;" />

或者，当问题不再能简单的二分时，我们可以通过循环的方式统计所有可能性：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210725162045.png" alt="image-20210725162045374" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210725162056.png" alt="image-20210725162056225" style="zoom:50%;" />

## HW2 (Recursion+Higher  Order  Function)

在对应的**HW**中，给出了将`Tree Recursion`与`Higher Order Function`相结合的例子.

同时注意在使用递归时，如果我们有多个数据需要追踪，可以写一个`helper`函数：

```python
def count_coins(total):
    """Return the number of ways to make change for total using coins of value of 1"""
    
    def count_helper(total, m):
        if total == 0:
            return 1
        elif total < 0:
            return 0
        elif m is None:
            return 0
        elif total < m:
            return 0
        else:
            return count_helper(total - m, m) + count_helper(total, next_largest_coin(m))
    return count_helper(total, 1)
```

这也是一个`tree recursion`问题，根据处理这类问题的方法，我们尝试寻找一个标准，将问题分为几个更简单的`instance`。依靠`helper`函数，问题转化为：

1. 不用当前最小面值硬币1，则问题转化为使用最小面值硬币`next_largest_coin(1)`，凑齐总价值`total`
2. 至少使用一个面值为1的硬币，则问题转化为使用最小面值硬币1，凑齐总价值为`total-1`

我们将分析写成函数，就是上边的形式。

```python
def pingpong(n):
    """Return the nth element of the ping-pong sequence."""
    
    if n <= 8:
        return n
    else:
        return pingpong(n - 1) + helper(n - 1)

# 决定是要+1还是-1

def helper(n):
    if n <= 7:
        return 1
    else:
        if n % 8 == 0 or num_eights(n) != 0:
            return -helper(n - 1)
        else:
            return helper(n - 1)
```

使用`lambda`函数，在不给出函数名的情况下定义递归：

```python
>>> fact = lambda n: 1 if n == 1 else mul(n, fact(sub(n, 1)))
>>> fact(5)
120

def make_anonymous_factorial():
    """Return the value of an expression that computes factorial."""
    
    return (lambda f: lambda n: f(f,n))(lambda s,x: 1 if x == 1 else mul(x, s(s,sub(x, 1))))
```

**这里理解的点在于，递归的过程实质上是把函数本身也作为了函数的参数，在函数内部调用了函数自己.**

## F20 Lecture 10(List)

1. list的concatenation & repetition

```python
# 将原来的所有元素重复一遍并加上[2,7]元素

[2,7]+lists*2
```

2. Sequence Unpacking

```python
pairs = [[1,2],[2,2],[3,4]]
for x,y in pairs:
if x == y:
	...
```

3. list constructor

```python
list(range(4))
```

### List在Tree Recursion中的使用

#### cats

> ### Problem 7 (3 pt)
>
> Implement `pawssible_patches`, which is a diff function that returns the minimum number of edit operations needed to transform the `start` word into the `goal` word.
>
> There are three kinds of edit operations:
>
> 1. Add a letter to `start`,
> 2. Remove a letter from `start`,
> 3. Substitute a letter in `start` for another.
>
> Each edit operation contributes 1 to the difference between two words.
>
> ```python
> >>> big_limit = 10
> >>> pawssible_patches("cats", "scat", big_limit)       # cats -> scats -> scat
> 
> 2
> >>> pawssible_patches("purng", "purring", big_limit)   # purng -> purrng -> purring
> 
> 2
> >>> pawssible_patches("ckiteus", "kittens", big_limit) # ckiteus -> kiteus -> kitteus -> kittens
> 
> 3
> ```
>
> We have provided a template of an implementation in `cats.py`. This is a recursive function with three recursive calls. One of these recursive calls will be similar to the recursive call in `shifty_shifts`.
>
> You may modify the template however you want or delete it entirely.
>
> If the number of edits required is greater than `limit`, then `pawssible_patches` should return any number larger than `limit` and should minimize the amount of computation needed to do so.
>
> ```python
>>>> limit = 2
> >>> pawssible_patches("ckiteus", "kittens", limit) > limit
> True
> >>> pawssible_patches("ckiteusabcdefghijklm", "kittensnopqrstuvwxyz", limit) > limit
> True
> ```

```python
def pawssible_patches(start, goal, limit):
    """A diff function that computes the edit distance from START to GOAL."""

    if limit < 0:
        return 0
    if start == '':
        return len(goal)
    elif goal == '':
        return len(start)
    elif start[0] == goal[0]:
        return pawssible_patches(start[1:], goal[1:],limit)
    else:
        limit -= 1
        add_diff = pawssible_patches(goal[0] + start, goal,limit)
        remove_diff = pawssible_patches(start[1:], goal,limit)
        substitute_diff = pawssible_patches(goal[0] + start[1:], goal,limit)
        return 1 + min(add_diff, remove_diff, substitute_diff)
```

对于这道问题，我们可以类比之前的`Tree Recursion`递归问题，思考如何把问题抽象化：

对于每一个位置的字符对比，都有增删改三种操作，可以联想之前爬楼梯的问题：每一步都有上1级台阶或者2级台阶这两种情况，只是在这里，增删改这三种操作不简单的是`f(n-1)`这种形式，我们需要自己实现它。所以现在基本可以确定，递归会作用在实现增删改这三种操作上，接下来要完善函数设计，就要思考如下几个问题：

- base case是什么？

首先刨除`limit`这个变量不管，显然在我们在递归至字符串`start`或者`goal`任意一个为空字符串时，递归停止，并返回另一字符串的长度（及需要进行改变的次数）

- 如何进行`recursion decomposition`?

起点很简单，一定是字符串开头的首字母，所以可以分为首字母相同与首字母不同两种情况，如果首字母相同，就不需要利用增删改三者当中的任何一个，那么这个`simpler instance`可以写作：

```python
elif start[0] == goal[0]:
	return pawssible_patches(start[1:], goal[1:],limit)
```

如果首字母不相同，这时候就需要进行增删改的操作，但要注意，我们将`goal`的首位递推的任务交给两者相同的情况，以免发生错误。只要进行了一次更改操作，次数要加1，所又因为题目要求计算最小更改次数，所以每一次，我们都选取这三种操作里需要次数最少的那一个并随之递归：

```python
else:
    limit -= 1
    add_diff = pawssible_patches(goal[0] + start, goal,limit)
    remove_diff = pawssible_patches(start[1:], goal,limit)
    substitute_diff = pawssible_patches(goal[0] + start[1:], goal,limit)
    return 1 + min(add_diff, remove_diff, substitute_diff)
```

最后，为了提高程序运行的效率，我们需要计算何时达到`limit`，于是在每一次更改之后，都将`limit`减小1，在`limit`达到0时，停止递归。

## F20 Lecture 12（Recursion->Tree）

详细阐述了如何使用递归完成关于**树**的各种操作，以及一些`container`的相关操作。

- `sum(iterable[,start])->value`

```python
>>> sum([[2,3],[4]],[])
[2,3,4]
```

- `max(iterable[,key=func])->value`

- `all(iterable)->bool`

> Return True if bool(x) is True for all values in x in the iterable. If the iterable is empty, return True.

### Tree

![image-20210727235920957](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210727235928.png)

如何构造一个树？

e.g.

```python
>>> tree(3,[tree(1),tree(2,[tree(1),tree(1)])])
[3,[1],[2,[1],[1]]]
```

定义如下几个函数：

```python
def tree(label, branches=[]):
    return [label] + branches

def label(tree):
    return tree[0]

def branches(tree):
    return tree[1:]

def is_tree(tree):
    if type(tree) != list or len(tree) < 1:
        return False
    for branch in branches(tree):
        # 这里的条件判断语句是有必要的，如果我们单单进行循环的话，最后势必会回到函数最下端的返回值那里，那判断也就失去了意义，通过if条件，程序在某一时刻直接结束
        
        if not is_tree(branch):
            return False
    return True

def is_leaf(tree):
    # 判断是否为empty
    
    return not branches(tree)
```

利用这几个基本的函数，可以处理一些更为具体的`Tree Porcessing`，比如构造一个`Fibonacci`树：

```python
def fib_tree(n):
    if n <= 1:
        return tree(n)
    else:
        left, right = fib_tree(n-1), fib_tree(n-2)
        return tree(label(left)+label(right),[left,right])
```

以及一些更高阶的`Tree Processing`函数，比如对叶(`leaves`)进行的操作：

```python
def count_leaves(t):
    # 判断是否为叶结点，常作为base case
    
    if is_leaf(t):
        return 1
    else:
        branch_counts = [count_leaves(b) for b in branches(t)]
        return sum(branch_counts)
    
def leaves(tree):
    '''Return a list containing the leaf labels of tree.'''
    
    if is_leaf(tree):
        return [label(tree)]
    else:
        # 利用sum()函数对list操作的特殊性质，每次return遇到sum函数就会脱掉在sum内部的list comprehension外边一层括号,这样便可以保证输出的leaves都在同一维度内
        
        # List of leaf labels for each branch
        
        return sum([leaves(b) for b in branches(tree)],[])
    
def increment_leaves(t):
    '''Return a tree like t but with leaf labels incremented.'''
    
    if is_leaf(t):
        return tree(label(t) + 1)
    else:
        # 注意这里必须用tree包裹递归函数，如果没有tree，那么最后返回的仅仅就是几个单独的leaf，无法构成完整的树
        
        return tree(label(t),[increment_leaves(b) for b in branches(t)])
    
def increment(t):
    '''Return a tree like t but with all labels incremented'''
    
    # 递归结束条件为for循环终止，不需要单独设置base case
    
    return tree(label(t) + 1, [increment_leaves(b) for b in branches(t)])
```

在有了一系列`Tree Processing`的函数之后，我们可以把树打印出来，并控制缩进，以更好的显示：

```python
def print_tree(t,indent = 0):
    print('	' * indent + str(label(t)))
    for b in branches(t):
        print_tree(b, indent + 1)
```

> 在设计递归时，有两种方式：
>
> 1. 使用return的方法控制递归进行
> 2. 将需要跟踪的变量以函数参数的形式传入
>
> 对于第二种方法，如：
>
> ```python
> numbers = tree(3,[tree(4),tree(5,[tree(6)])])
> 
> # 分别统计从root到每一个叶结点的label总和
> 
> def print_nums(t,so_far):
>     so_far = so_far + label(t)
>     if is_leaf(t):
>         print(so_far)
>     else:
>     	for b in branches(t):
>             print_sums(b,so_far)
> ```

**在`Tree`的相关递归函数中我们可以发现，他的思路其实是和之前的递归类似的，从一个节点到分支的过程，其实就是在进行`Recursion decomposition`，同先前的递归一样，在书写函数时也只需要考虑下边一层的情况即可（即第(n-1)层可能存在的1、2、3、4...个节点如何处理）**

#### lab05

> Define the function `add_trees`, which takes in two trees and returns a new tree where each corresponding node from the first tree is added with the node from the second tree. If a node at any particular position is present in one tree but not the other, it should be present in the new tree as well.

首先思考下base case，可以将`t1`与`t2`为叶结点的情况合并在一起：

```python
def add_trees(t1,t2):
    if is_leaf(t1) or is_leaf(t2):
        return tree(label(t1)+label(t2),branches(t1)+branches(t2))
    else:
        ......
```

如果两者均不是叶结点，我们需要对两个树同时进行遍历（递归），这就需要用到拉链函数，同时最后的返回值一定是使用`tree`函数进行构造的，所以基本的框架应该是：

```python
else:
    return tree(label(t1)+label(t2),[add_trees(b[0],b[1]) for b in zip(branches(t1),branches(t2))])
```

显然，如果两树的构造完全相同，这么做是没有问题的，但是当树的构造不同时，直接使用`zip`函数会导致数据丢失，所以我们下边要解决的问题是将构造不同的两树变成相同的：

```python
else:
        branch_t1 = branches(t1)
        branch_t2 = branches(t2)
        t1_len = len(branch_t1)
        t2_len = len(branch_t2)
        if t1_len < t2_len:
            branch_t1 += [tree(0) for _ in range(t2_len-t1_len)]
        if t1_len > t2_len:
            branch_t2 += [tree(0) for _ in range(t1_len - t2_len)]
```

技巧就是把原先不存在的节点用0节点填补上。

最后得到完整的递归函数：

```python
def add_trees(t1,t2):
    if is_leaf(t1) or is_leaf(t2):
        return tree(label(t1) + label(t2),branches(t1) + branches(t2))
    else:
        branch_t1 = branches(t1)
        branch_t2 = branches(t2)
        t1_len = len(branch_t1)
        t2_len = len(branch_t2)
        if t1_len < t2_len:
            branch_t1 += [tree(0) for _ in range(t2_len - t1_len)]
        if t1_len > t2_len:
            branch_t2 += [tree(0) for _ in range(t1_len - t2_len)]
        return tree(label(t1)+label(t2),[add_trees(b[0],b[1]) for b in zip(branch_t1,branch_t2)])
```

#### disc05

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210730153747.png" alt="image-20210730153746665" style="zoom:67%;" />

还是先来思考base case：

因为这道题最终并不是要构造一个树，所以`base case`不要理所应当的写作`is_leaf`，根据题目，在我们找到`x`时就应当返回带有`x`的列表，所以很容易想到：

```python
def find_path(tree,x):
    if label(tree) == x:
        return [x]
```

接下来考虑是否可以用`list comprehension`的形式直接递归，但是我们想到`list comprehension`会将所有节点全部输出，但在遇到不存在`x`的路径时，根据题目要求需要返回`None`，所以为了更加清晰，我们将`for`循环拉出来写：

```python
def find_path(tree,x):
    if label(tree) == x:
        return [x]
    for b in branches(tree):
        path = find_path(b,x)
        # 如果已经找到了x所在的位置，则返回，否则继续for循环遍历分支
        
        if path:
            return [label(tree)] + path
```

仿照上边这道题：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210730154947.png" alt="image-20210730154947851" style="zoom:67%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210730155007.png" alt="image-20210730155007625" style="zoom:67%;" />

**注意这道题最后是要返回一个tree的，但是和上一道题目相同，也是只包含了部分满足条件的节点，所以到这里，我们可以明白两件事：**

1. base case极大概率为`is_leaf()`
2. 递归主体中的for循环不能使用`list comprehension`的形式
3. 函数最后要使用`tree`函数return

```python
def prune_binary(t,nums):
    if is_leaf(t):
        if label(t) in nums:
            return t
        return None
```

在递归主体中，我们需要完成两件事：

1. 把列表中的元素的某几个字母抽出来，和分支节点比对，如果一样，就把对应元素中余下的字符传下去，如果不一样，就把那个元素直接扔掉吧
2. 因为可能存在多个路径，我们最后要组合成一个完整的树

首先看第二点，其实`list comprehension`的另一种写法是：

```python
next_branch = []
for b in branches(tree):
    cur_f = f(x)
    next_branch = next_branch + [cur_f]
return tree(label(tree),next_branch)
```

在这种写法中，`next_branch`的作用就是将某个节点下对应的所有`branch`组合起来，我们正是利用这一点来解决上边这道问题。

其次对于第一点，把伪代码实现出来：

```python
next_valid_nums = [n[1:] for n in nums if label(t) == nums[0]]
```

至此，程序的大致结构已经确定了：

```python
def prune_binary(t,nums):
    if is_leaf(t):
        if label(t) in nums:
            return t
        return None
    else:
        next_valid_nums = [n[1:] for n in nums if label(t) == nums[0]]
        next_branch = []
        for b in branches(tree):
            pruned_branch = pruned_binary(b,next_valid_nums)
            next_branch = next_branch + [pruned_branch]
        #此处的return语句必须独立于for循环之外，否则一条分支结束了就回家了
        
        return tree(label(tree),next_branch)
```

但同时注意到，在base case中存在返回`None`的可能性，如果`pruned_binary`一旦返回`None`，其实整个分支也就没有保留的必要了。所以我们需要加上一些判断语句，保证程序运行正确：

```python
def prune_binary(t,nums):
    if is_leaf(t):
        if label(t) in nums:
            return t
        return None
    else:
        next_valid_nums = [n[1:] for n in nums if label(t) == nums[0]]
        next_branch = []
        for b in branches(tree):
            pruned_branch = pruned_binary(b,next_valid_nums)
            if pruned_branch is not None:
            	next_branch = next_branch + [pruned_branch]      
        if not new_branches:
            return None
        return tree(label(tree),next_branch)
```

## F20 Lecture16  Q&A  (Recursion->Tree+Higher  Order  Function)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210803195429.png" alt="image-20210803195428667" style="zoom:50%;" />

```python
def profit(t):
    '''Return the max profit'''
    
    return helper(t, False)
```

> 为什么需要一个helper函数？因为考虑到题目设置：对于某个节点`b`，若它的父节点已被使用，则`b`不能被使用；如果父节点没有使用，那我们可以选择使用`b`或者不使用`b`，这也决定了接下来`b`的子节点能否被使用。这意味着需要跟踪一个额外的`父节点是否已被使用`的参数，所以需要建立一个helper函数。

```python
def helper(t, used_parent):
    # 如果已经使用了父节点,则下一个节点（该节点）不可使用，将flag设置为False就直接跳过这个if
    
    if used_parent:
        return sum([helper(b,False) for b in branches(t)])
    else:
        # 不使用父节点，分为用该节点/不用该节点两种情况，如果使用此节点，则下次递归（其子节点要跳过，即进入上边的if里）
        
        use_current_total = label(t) + sum([helper(b,True) for b in branches(t)])
        # 不使用此节点，则还需要考虑其子节点是否要使用，下次还要进入这里的else
        
        skip_current_label= 0        + sum([helper(b,False) for b in branches(t)])
        return max(use_current_total, skip_current_label)
```

---

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210803204027.png" alt="image-20210803204027282" style="zoom:50%;" />

题目提供了一些基本的框架，这里不单独列出框架了，直接写（两种写法，我的做法和教授的不一样）:

因为要同时跟踪已经加上的节点，将其作为原来的`branches`的`root`，同时还要跟踪未处理的`branches`，所以建立嵌套函数：

```python
def village(apple, t):
    '''Grafts the given branches 'bs' onto each leaf of the given tree 't', returning a new tree '''
    
    def graft(t,bs):
        if is_leaf(t):
            return tree(label(t), bs)
        new_branches = [graft(b,bs) for b in branches(t)]
        return tree(label(t), new_branches)
    base_t = apple(label(t))
    bs = [village(apple,b) for b in branches(t)]
    return graft(base_t,bs)
```

为什么要这么写？想法是通过变量`base_t`将节点扩展，利用`bs`**遍历原树**，之后通过`graft(base_t,bs)`函数传入扩展节点，并把**添加节点**的工作放在`graft`函数内部，与之前一样使用`list comprehension`的方法。也就是说大的目标有两个：

- 遍历原树，keep tracking of every nodes of the original tree
- 根据要求添加节点并构造新树

这道题也可以这么写：

```python
def village(apple, t):
    def graft(t, bs):
        # 叶结点
        
        if bs is None:
            return t
        new_branches = [tree(label(b), bs) for b in branches(base_t)]
        return tree(label(t), [tree(label(b), [village(apple, branch) for branch in branches(b)]) for b in new_branches])
    base_t = apple(label(t))
    bs = branches(t)
    return graft(base_t, bs)
```

这种方法的想法是把所有的递归工作放到内部函数中去，所以在叶结点的处理条件上有些改变，相对直观，内部函数的`new_branch`代表了经过`apple`处理后的所有分支。那么接下来要考察的就是除了`root`和刚才添加的`apple`生成节点了。

---

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202108050020029.png" alt="image-20210805002038879" style="zoom:50%;" />

这道题目我尝试过使用一般的递归形式去做，但是发现会很麻烦...要返回的形式比较古怪，所以题目本身给出的模板里增加一个`index`标志跟踪字符位置是没有问题的，这会大大减少操作难度。

```python
def schedule(galaxy, sum_to, max_digit):
    def schedule_helper(galaxy, sum_sofar, index):
        if index == len(galaxy) and sum_sofar == sum_to:
            # 敏锐捕捉到，这个形式下返回的galaxy是完整的
            
            return [galaxy]
        elif sum_sofar > sum_to or (sum_sofar < sum_to and index == len(galaxy)):
            return []
        elif galaxy[index] != '?':
            return schedule_helper(galaxy, sum_sofar + int(galaxy[index]), index + 1)
        ans = []
        for x in range(max_digit + 1):
            # 关键的处理行
            
            modified_galaxy = galaxy[0:index] + str(x) + galaxy[index + 1:]
            ans = ans + schedule_helper(modified_galaxy, sum_sofar + x, index + 1)
        return ans

    return schedule_helper(galaxy, 0, 0)
```

卡住的点主要有三个：

1. 敏锐捕捉到，base case中这个`[]`返回值形式下的`galaxy`是完整的
2. `index`对准的是下一个即将处理的数字位置，而不是已经处理过的数字位置
3. 如果要保持`galaxy`数组长度一致，如何去更改其中的某一位字符？

再考虑清楚这三点之后，余下的工作就比较清楚了：

- **Base Case**: 当遍历完最后一位数字，并且数字之和恰好为`sum_to`时，把已经调整完毕的`galaxy`字符串以`list`的形式返回；
- **ERROR**: 如果已经遍历完但是`sum`还是不到设定值或者已经超过设定值的情况下，舍弃结果，返回空数组；
- 如果指定位置的字符不为`'?'`，则保持`galaxy`不动；
- 反之，在`max_digit`的限制下对所有可能的数字递归选择，并使用切片操作更改指定位置的`'?'`为我们当前选定的数字`x`

> 因为源字符串中至少存在一个`'?'`，所以只需要在`for`循环内部对`ans`进行操作即可

> 这道题也可以用`yield`做：
>
> ```python
> def schedule(galaxy, sum_to, max_digit):
>     def schedule_helper(galaxy, sum_sofar, index):
>         if index == len(galaxy) and sum_sofar == sum_to:
>             # 敏锐捕捉到，这个形式下返回的galaxy是完整的
>             
>             # return [galaxy]
>             
>             yield galaxy
>         elif sum_sofar > sum_to or (sum_sofar < sum_to and index == len(galaxy)):
>             # return []
>             
>             return 
>         elif galaxy[index] != '?':
>             # return schedule_helper(galaxy, sum_sofar + int(galaxy[index]), index + 1)
>             
>             yield from schedule_helper(galaxy, sum_sofar + int(galaxy[index]), index + 1)
>         # ans = []
>         
>         for x in range(max_digit + 1):
>             # 关键的处理行
>             
>             modified_galaxy = galaxy[0:index] + str(x) + galaxy[index + 1:]
>             # ans = ans + schedule_helper(modified_galaxy, sum_sofar + x, index + 1)
>             
>             yield from schedule_helper(modified_galaxy, sum_sofar + x, index + 1)
>         # return ans (可以参考下边yield以list代写的简单例子)
> 
>     # return schedule_helper(galaxy, 0, 0)
>     
>     return list(schedule_helper(galaxy, 0, 0))
> ```

## F20 Lecture 15（List & Tuple Mutable）

> List的Mutable性质 & Tuple的unmutable性质

- Mutable Default Arguments are Dangerous

函数的默认参数随函数本体一起创建，在使用过程中始终维护同一块内存空间

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210730165126.png" alt="image-20210730165126008" style="zoom: 50%;" />

- List-addition & slicing

```python
s = [2,3]
t = [5,6]
a = s + [t]
b = a[1:]
a[1] = 9
b[1][1] = 0

>>> s
[2,3]
>>> t
[5,0]
>>> a
[2,9,[5,0]]
>>> b
[3,[5,0]]
```

这里需要注意两个问题：

1. ```python
   a = a + b
   
   # 不同于c.append(a)
   ```

这条`+`语句会为等式右侧的`a`与`b`分别创建一个全新的list，所以改变原始的`a`与`b`的值并不会影响相加生成后的列表`a`，这与`append`函数不同。

2. ```python
   a += b
   
   # 不同于a = a + b
   ```

python中的`+=`号不完全等同于`+`，在这里，如果后续改变了`b`的值，则生成的`a`也会被改变。

3. ```python
   s = [2,3]
   t = [5,6]
   a = s + [t]
   ```

`[t]`作为一个整体，可以理解为是`[]`经过`append`操作的产物，所以在这样的`+`操作中，创建的是`[]`，之后指向原先的`t`数组所在的位置，所以此时改变`t`，则会改变生成的`a`的值。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210730170109.png" alt="image-20210730170109139" style="zoom:50%;" />

```python
s[0:0] = t
```

意为在0处插入整个t序列（`s[1:1]`同理，不论插入序列的长度多少，因为使用的是`slicing`语法）

- `list()`会创建一个新的对象
- Lists in Lists in Lists in Environment Diagrams

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210730171704.png" alt="image-20210730171704192" style="zoom:50%;" />

- Tuple中的list数据可以被更改（因为指向的是单独开辟的另一块内存区域而不直接位于`tuple`的内存块内）

## F20 Lecture 16 - Nonlocal

### Python Particulars

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210803214128.png" alt="image-20210803214128250" style="zoom:50%;" />

但是`nonlocal`关键字解决了这个问题：

```python
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(20)
print(wd(5))
```

## F20 Lecture 17 (Iterator & Generator)

### Iterator

- ```python
  iter(iterable)-返回迭代器对象
  next(iterator)-取出其中的值
  ```

- ```python
  # Dictionary Iteration
  
  iter(dic.keys())
  iter(dic.values())
  iter(dic.items())
  ```

- Built-in Functions for Iteration

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210804225957.png" alt="image-20210804225950289" style="zoom:50%;" />

- 迭代器对象在被读取元素之后，即会将被读取的元素从迭代器对象中去除

```python
s = [[1,2],3,4,5]
t = iter(s)
next(t)
next(t)
>>> list(t)
[4,5]
```

- 若迭代器已被开始读取，则中途不可以改变迭代器`size`，但是可以改变未读取元素的值

```python
d = {'one':1,'two':2}
k=iter(d)
next(k)
# 下边这句会报错，dictionary changed size during iteration

d['zero'] = 0
```

- for循环既可以遍历`list`，也可以遍历迭代器，但是迭代器在遍历完毕之后不能再次使用了

### Generator

**yield返回给调用者一个生成器对象**

`generator function is a function that yields values instead of returning them`

`A normal function returns once; a generator function can yield multiple times`

`A generator is an iterator created automatically by calling a generator function`

`When a generator function is called, it returns a generator that iterates over its yields`

在遇到`yield`时，程序会暂停（保存局部变量），所以每次执行，都只会执行一个生成器对象：

```python
def plus_minus(x):
    yield x
    yield -x

t = plus_minus(3)
>>> next(t)
3
>>> next(t)
-3
```

`yield from`从一个可迭代对象或者迭代器中`yield`所有值

#### Yield & Recursion

```python
def prefixes(s):
    if s:
        yield from prefixes(s[:-1])
        yield s
```

为了更加深刻的理解`yield`，我们可以展开分析一下上边这个简单的递归：

首先写成标准`for`循环的形式：

```python
def prefixes(s):
    if s:
        for x in prefixes(s[:-1]):
            yield x
        yield s
```

每一次函数返回，都会把函数体中所有的`generator`对象传递回去，并且在上一级函数执行完毕之后，生成器对象又多了一个（`yield s`），逐次递增。

如果不使用`yield`，也可以实现这个功能：

```python
def prefixes(s):
    result = []
    if s:
        for x in prefixes(s[:-1]):
            result.append(x)
        result.append(s)
    return result
```



