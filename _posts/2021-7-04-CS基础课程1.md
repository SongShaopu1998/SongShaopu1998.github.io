---
layout:		post
title:		CS基础课程
subtitle:	CS 61A
date:		2021-7-04
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
    - Python

---

## HW1

### Q2

问题转化的想法：选出两个最大的数，并计算其平方和，其实也就是在计算最大的数值平方组合

```python
max(a*a+b*b,b*b+c*c,a*a+c*c)
```



### Q3

摒弃遍历顺序正序的想法，在此题目中，倒序遍历是最方便的:

```python
factor = n - 1
while factor < n:
	if n % factor == 0:
		return factor
	factor -= 1
```



### Q4

`if_function(cond(), true_func(), false_func()`中，会先执行其中的函数，之后将其返回值传入主函数。所以执行的过程一定是`true_func()->false_func()`，执行结果根据提示分别为42与47，又因为`statement`函数执行结果仅为47，所以一定是`true_func()`对应47，那么`false_func()`对应42，根据之前的执行顺序，条件判断函数`cond()`应当设定为`false`。

```python
if cond():
	return true_func()
else:
	return false_func()
```

同时把握下图：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210705172319.jpg" alt="Snipaste_2021-07-05_17-20-24" style="zoom:80%;" />

### Q5

整数除法：**//**

## Lab1

### Veritasiness

```python
>>> 1 and 3 and 10 and 15
>>> 15
```

执行顺序为**自左至右**！

### Coding Practice

努力把代码写的具有被语言本身的特性，看起来更加简洁：

```python
def falling(n, k):
    """Compute the falling factorial of n to depth k."""
    total, stop = 1, n-k
    while n > stop:
        total, n = total*n, n-1
    return total
```

## F20 Lecture 4

### lambda

定义一个`search`函数，找到满足条件的`x`：

```python
def search(f):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x):
        x += 1
    return x
```

现在我们想要做一个`inverse`函数，作为反函数求值器，课上给出的解法如下：

```python
def inverse(f):
	return lambda y:search(lambda x:f(x)==y)
```

对于这个问题，我们可以做如下分析：

在`search`函数中，**条件**被设定为`f(x)`；而在`inverse`函数中，我们的目标是通过给出的函数**`f`**，可以对任意**`y`**值获取满足**条件**`f(x)==y`的`x`。

如果使用`lambda`操作，很方便的一点是可以借助`lambda`的匿名特点，表示我们需要的**条件**。因为我们要求的是反函数中的`x`，但是又需要引入未知数`x`，此时如果是通过`def`的形式引入变量`x`，就显得冗余，因为在`search`函数内部还有一个我们会真正用到的`x`，而匿名函数`lambda`恰好解决了这一问题。同样地，`lambda`也可以用于引入参数`y`。

而如果使用`def`的形式定义函数，则最方便的办法是先将`search`函数更改为如下形式：

```python
def search(f, y):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x) == y:
        x += 1
    return x
```

`inverse`函数做如下定义：

```python
def inverse(f):
    def SetY(y):
        return search(f, y)
    return SetY
```

如果我们选择不更改`search`函数，则`inverse`函数：

```python
def inverse(f):
    def SetY(y):
        # 因为只有在这个frame里才需要用到x，所以选择在另一个函数内部定义SetX，其实是和匿名函数一个道理
        
        def SetX(x):
            return f(x) == y
        return search(SetX)
    return SetY
```

这里要学习的还有从特例到抽象的推导思维，这有助于我们快速构建出程序结构。先从开平方根函数的特例开始：

```python
# 一个平方查找函数

def is_square_of_4(n):
    return square(4) == n
# 一个平方根查找函数

def is_sqrt_of_16(x):
    return square(x) == 16
# 利用search函数寻找x：

ans = search(is_sqrt_of_16)
# 扩充使用案例到16->n：

def sqrt(n):
	def is_sqrt_of_n(x):
    	return square(x) == n
    return search(is_sqrt_of_n)
# 扩充平方根函数，设计inverse,从内向外，逐层添加：

def inverse(f):
    def is_inverse_of_f(y):
        def is_inverse_of_y(x):
            return f(x) == y
    	return search(is_inverse_of_y)
    return is_inverse_of_f
```



调用函数：

```python
# e.g.

sqrt = inverse(square)
Ans = sqrt(256)
```

这里的**256**就是函数中的**`y`**参数，这也是为什么要把`return`写做`lambda y:...`的原因，我们要先给到参数`y`。

### call expression中的执行顺序

为什么不会出现``if_(c,t,f)`这种形式？因为这是一个`call expression (which applies a function to some arguments)`，而根据如下的evaluation规则，这种函数设计很容易出现问题，所有子表达式均要提前被执行：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210708215753.png" alt="image-20210708215746570" style="zoom:67%;" />

## Hog

### Q8 Test

>​     \>>> dice = make_test_dice(3, 1, 5, 6)
>
>​     \>>> averaged_roll_dice = make_averaged(roll_dice, 1000)
>
>​     \>>> # Average of calling roll_dice 1000 times
>
>​     \>>> # Enter a float (e.g. 1.0) instead of an integer
>
>​     \>>> averaged_roll_dice(2, dice)

最终的结果为**6.0**。其中部分函数如下：

```python
def make_test_dice(*outcomes):
    """Return a die that cycles deterministically through OUTCOMES.

    >>> dice = make_test_dice(1, 2, 3)
    >>> dice()
    1
    >>> dice()
    2
    >>> dice()
    3
    >>> dice()
    1
    >>> dice()
    2

    This function uses Python syntax/techniques not yet covered in this course.
    The best way to understand it is by reading the documentation and examples.
    """
    assert len(outcomes) > 0, 'You must supply outcomes to make_test_dice'
    for o in outcomes:
        assert type(o) == int and o >= 1, 'Outcome is not a positive integer'
    index = len(outcomes) - 1

    def dice():
        nonlocal index
        index = (index + 1) % len(outcomes)
        return outcomes[index]

    return dice
```

```python
def roll_dice(num_rolls, dice=six_sided):
    """Simulate rolling the DICE exactly NUM_ROLLS > 0 times. Return the sum of
    the outcomes unless any of the outcomes is 1. In that case, return 1.

    num_rolls:  The number of dice rolls that will be made.
    dice:       A function that simulates a single dice roll outcome.
    """
    # These assert statements ensure that num_rolls is a positive integer.
    
    assert type(num_rolls) == int, 'num_rolls must be an integer.'
    assert num_rolls > 0, 'Must roll at least once.'
    i, sum = 0, 0
    flag_1 = False
    while i < num_rolls:
        res = dice()
        if res == 1:
            flag_1 = True
        else:
            sum += res
        i += 1
    if flag_1:
        sum = 1
    return sum
```

这要涉及到的知识点是`Higher Order Function`，以及一个`nonlocal`关键字。需要注意的是，只要`[f1=make_test_dice]`这个frame没有变，也就是说我们没有在另一个`[f2=make_test_dice]`里操作，那么无论我们执行多少次`dice(*args)`，变量`index`的值始终是循环的，因为根据`environment diagram`的原则，它的作用域`f1`没有消失。

### Q7

在Problem 7提供的样例中，有几个有趣的`Higher Order Function`：

```python
def say_scores(score0, score1):
    """A commentary function that announces the score for each player."""
    
    print("Player 0 now has", score0, "and Player 1 now has", score1)
    return say_scores
```

```python
def announce_lead_changes(last_leader=None):
    """Return a commentary function that announces lead changes."""

    >>> f0 = announce_lead_changes()
    >>> f1 = f0(5, 0)
    Player 0 takes the lead by 5
    >>> f2 = f1(5, 12)
    Player 1 takes the lead by 7
    >>> f3 = f2(8, 12)
    >>> f4 = f3(8, 13)
    >>> f5 = f4(15, 13)
    Player 0 takes the lead by 2

    def say(score0, score1):
        if score0 > score1:
            leader = 0
        elif score1 > score0:
            leader = 1
        else:
            leader = None
        if leader != None and leader != last_leader:
            print('Player', leader, 'takes the lead by', abs(score0 - score1))
        return announce_lead_changes(leader)

    return say
```

其中的`say`函数，返回值为`announce_lead_changes(leader)`，因为这是一个`call expression`，所以会重新建立一个`environment diagram`，其中的`formal parameter`由刚执行完毕的`say`函数给出，并作为即将执行的`announce_lead_changes`的参数，又传入以它为`parent`的`say`函数中使用。

```python
def both(f, g):
    """Return a commentary function that says what f says, then what g says."""

    NOTE: the following game is not possible under the rules, it's just
    an example for the sake of the doctest

    >>> h0 = both(say_scores, announce_lead_changes())
    >>> h1 = h0(10, 0)
    Player 0 now has 10 and Player 1 now has 0
    Player 0 takes the lead by 10
    >>> h2 = h1(10, 8)
    Player 0 now has 10 and Player 1 now has 8
    >>> h3 = h2(10, 17)
    Player 0 now has 10 and Player 1 now has 17
    Player 1 takes the lead by 7
    
    def say(score0, score1):
        return both(f(score0, score1), g(score0, score1))
    return say
```

**母函数返回子函数的同时，子函数返回母函数**--这样做的好处在于**一直跟随`leader`的变化，同时可以连续使用`(score0,score1)`的格式**。在CS 61A提供的文档中，表明这是`commentary function`的常用写法（即利用`Higher Order Function`）.

![image-20210713192008394](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210713192015.png)

