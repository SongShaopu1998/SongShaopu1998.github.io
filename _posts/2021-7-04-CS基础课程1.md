---
layout:		post
title:		CS基础课程
subtitle:	CS 61A
date:		2021-7-04
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
    - Python

---

## HW1

### Q2

问题转化的想法：选出两个最大的数，并计算其平方和，其实也就是在计算最大的数值平方组合

```python
max(a*a+b*b,b*b+c*c,a*a+c*c)
```



### Q3

摒弃遍历顺序正序的想法，在此题目中，倒序遍历是最方便的:

```python
factor = n - 1
while factor < n:
	if n % factor == 0:
		return factor
	factor -= 1
```



### Q4

`if_function(cond(), true_func(), false_func()`中，会先执行其中的函数，之后将其返回值传入主函数。所以执行的过程一定是`true_func()->false_func()`，执行结果根据提示分别为42与47，又因为`statement`函数执行结果仅为47，所以一定是`true_func()`对应47，那么`false_func()`对应42，根据之前的执行顺序，条件判断函数`cond()`应当设定为`false`。

```python
if cond():
	return true_func()
else:
	return false_func()
```

同时把握下图：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210705172319.jpg" alt="Snipaste_2021-07-05_17-20-24" style="zoom:80%;" />

### Q5

整数除法：**//**

## Lab1

### Veritasiness

```python
>>> 1 and 3 and 10 and 15
>>> 15
```

执行顺序为**自左至右**！

### Coding Practice

努力把代码写的具有被语言本身的特性，看起来更加简洁：

```python
def falling(n, k):
    """Compute the falling factorial of n to depth k."""
    total, stop = 1, n-k
    while n > stop:
        total, n = total*n, n-1
    return total
```

## F20 Lecture 4

### lambda

定义一个`search`函数，找到满足条件的`x`：

```python
def search(f):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x):
        x += 1
    return x
```

现在我们想要做一个`inverse`函数，作为反函数求值器，课上给出的解法如下：

```python
def inverse(f):
	return lambda y:search(lambda x:f(x)==y)
```

对于这个问题，我们可以做如下分析：

在`search`函数中，**条件**被设定为`f(x)`；而在`inverse`函数中，我们的目标是通过给出的函数**`f`**，可以对任意**`y`**值获取满足**条件**`f(x)==y`的`x`。

如果使用`lambda`操作，很方便的一点是可以借助`lambda`的匿名特点，表示我们需要的**条件**。因为我们要求的是反函数中的`x`，但是又需要引入未知数`x`，此时如果是通过`def`的形式引入变量`x`，就显得冗余，因为在`search`函数内部还有一个我们会真正用到的`x`，而匿名函数`lambda`恰好解决了这一问题。同样地，`lambda`也可以用于引入参数`y`。

而如果使用`def`的形式定义函数，则最方便的办法是先将`search`函数更改为如下形式：

```python
def search(f, y):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x) == y:
        x += 1
    return x
```

`inverse`函数做如下定义：

```python
def inverse(f):
    def SetY(y):
        return search(f, y)
    return SetY
```

如果我们选择不更改`search`函数，则`inverse`函数：

```python
def inverse(f):
    def SetY(y):
        # 因为只有在这个frame里才需要用到x，所以选择在另一个函数内部定义SetX，其实是和匿名函数一个道理
        
        def SetX(x):
            return f(x)==y
        return search(SetX)
    return SetY
```



调用函数：

```python
# e.g.

sqrt = inverse(square)
Ans = sqrt(256)
```

这里的**256**就是函数中的**`y`**参数，这也是为什么要把`return`写做`lambda y:...`的原因，我们要先给到参数`y`。

### call expression中的执行顺序

为什么不会出现``if_(c,t,f)`这种形式？因为这是一个`call expression (which applies a function to some arguments)`，而根据如下的evaluation规则，这种函数设计很容易出现问题，所有子表达式均要提前被执行：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210708215753.png" alt="image-20210708215746570" style="zoom:67%;" />

