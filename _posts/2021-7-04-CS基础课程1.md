---
layout:		post
title:		CS基础课程
subtitle:	CS 61A
date:		2021-7-04
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
    - Python
    - CS基础课程笔记

---

## HW1

### Q2

问题转化的想法：选出两个最大的数，并计算其平方和，其实也就是在计算最大的数值平方组合

```python
max(a*a+b*b,b*b+c*c,a*a+c*c)
```



### Q3

摒弃遍历顺序正序的想法，在此题目中，倒序遍历是最方便的:

```python
factor = n - 1
while factor < n:
	if n % factor == 0:
		return factor
	factor -= 1
```



### Q4

`if_function(cond(), true_func(), false_func()`中，会先执行其中的函数，之后将其返回值传入主函数。所以执行的过程一定是`true_func()->false_func()`，执行结果根据提示分别为42与47，又因为`statement`函数执行结果仅为47，所以一定是`true_func()`对应47，那么`false_func()`对应42，根据之前的执行顺序，条件判断函数`cond()`应当设定为`false`。

```python
if cond():
	return true_func()
else:
	return false_func()
```

同时把握下图：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210705172319.jpg" alt="Snipaste_2021-07-05_17-20-24" style="zoom:80%;" />

### Q5

整数除法：**//**

## Lab1

### Veritasiness

```python
>>> 1 and 3 and 10 and 15
>>> 15
```

执行顺序为**自左至右**！

### Coding Practice

努力把代码写的具有被语言本身的特性，看起来更加简洁：

```python
def falling(n, k):
    """Compute the falling factorial of n to depth k."""
    total, stop = 1, n-k
    while n > stop:
        total, n = total*n, n-1
    return total
```

## F20 Lecture 4

### lambda

定义一个`search`函数，找到满足条件的`x`：

```python
def search(f):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x):
        x += 1
    return x
```

现在我们想要做一个`inverse`函数，作为反函数求值器，课上给出的解法如下：

```python
def inverse(f):
	return lambda y:search(lambda x:f(x)==y)
```

对于这个问题，我们可以做如下分析：

在`search`函数中，**条件**被设定为`f(x)`；而在`inverse`函数中，我们的目标是通过给出的函数**`f`**，可以对任意**`y`**值获取满足**条件**`f(x)==y`的`x`。

如果使用`lambda`操作，很方便的一点是可以借助`lambda`的匿名特点，表示我们需要的**条件**。因为我们要求的是反函数中的`x`，但是又需要引入未知数`x`，此时如果是通过`def`的形式引入变量`x`，就显得冗余，因为在`search`函数内部还有一个我们会真正用到的`x`，而匿名函数`lambda`恰好解决了这一问题。同样地，`lambda`也可以用于引入参数`y`。

而如果使用`def`的形式定义函数，则最方便的办法是先将`search`函数更改为如下形式：

```python
def search(f, y):
    x = 0
    # 注意这里loop语法简洁
    
    while not f(x) == y:
        x += 1
    return x
```

`inverse`函数做如下定义：

```python
def inverse(f):
    def SetY(y):
        return search(f, y)
    return SetY
```

如果我们选择不更改`search`函数，则`inverse`函数：

```python
def inverse(f):
    def SetY(y):
        # 因为只有在这个frame里才需要用到x，所以选择在另一个函数内部定义SetX，其实是和匿名函数一个道理
        
        def SetX(x):
            return f(x) == y
        return search(SetX)
    return SetY
```

这里要学习的还有从特例到抽象的推导思维，这有助于我们快速构建出程序结构。先从开平方根函数的特例开始：

```python
# 一个平方查找函数

def is_square_of_4(n):
    return square(4) == n
# 一个平方根查找函数

def is_sqrt_of_16(x):
    return square(x) == 16
# 利用search函数寻找x：

ans = search(is_sqrt_of_16)
# 扩充使用案例到16->n：

def sqrt(n):
	def is_sqrt_of_n(x):
    	return square(x) == n
    return search(is_sqrt_of_n)
# 扩充平方根函数，设计inverse,从内向外，逐层添加：

def inverse(f):
    def is_inverse_of_f(y):
        def is_inverse_of_y(x):
            return f(x) == y
    	return search(is_inverse_of_y)
    return is_inverse_of_f
```



调用函数：

```python
# e.g.

sqrt = inverse(square)
Ans = sqrt(256)
```

这里的**256**就是函数中的**`y`**参数，这也是为什么要把`return`写做`lambda y:...`的原因，我们要先给到参数`y`。

### call expression中的执行顺序

为什么不会出现``if_(c,t,f)`这种形式？因为这是一个`call expression (which applies a function to some arguments)`，而根据如下的evaluation规则，这种函数设计很容易出现问题，所有子表达式均要提前被执行：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210708215753.png" alt="image-20210708215746570" style="zoom:67%;" />

## Hog

### Q8 Test

>​     \>>> dice = make_test_dice(3, 1, 5, 6)
>
>​     \>>> averaged_roll_dice = make_averaged(roll_dice, 1000)
>
>​     \>>> # Average of calling roll_dice 1000 times
>
>​     \>>> # Enter a float (e.g. 1.0) instead of an integer
>
>​     \>>> averaged_roll_dice(2, dice)

最终的结果为**6.0**。其中部分函数如下：

```python
def make_test_dice(*outcomes):
    """Return a die that cycles deterministically through OUTCOMES.

    >>> dice = make_test_dice(1, 2, 3)
    >>> dice()
    1
    >>> dice()
    2
    >>> dice()
    3
    >>> dice()
    1
    >>> dice()
    2

    This function uses Python syntax/techniques not yet covered in this course.
    The best way to understand it is by reading the documentation and examples.
    """
    assert len(outcomes) > 0, 'You must supply outcomes to make_test_dice'
    for o in outcomes:
        assert type(o) == int and o >= 1, 'Outcome is not a positive integer'
    index = len(outcomes) - 1

    def dice():
        nonlocal index
        index = (index + 1) % len(outcomes)
        return outcomes[index]

    return dice
```

```python
def roll_dice(num_rolls, dice=six_sided):
    """Simulate rolling the DICE exactly NUM_ROLLS > 0 times. Return the sum of
    the outcomes unless any of the outcomes is 1. In that case, return 1.

    num_rolls:  The number of dice rolls that will be made.
    dice:       A function that simulates a single dice roll outcome.
    """
    # These assert statements ensure that num_rolls is a positive integer.
    
    assert type(num_rolls) == int, 'num_rolls must be an integer.'
    assert num_rolls > 0, 'Must roll at least once.'
    i, sum = 0, 0
    flag_1 = False
    while i < num_rolls:
        res = dice()
        if res == 1:
            flag_1 = True
        else:
            sum += res
        i += 1
    if flag_1:
        sum = 1
    return sum
```

这要涉及到的知识点是`Higher Order Function`，以及一个`nonlocal`关键字。需要注意的是，只要`[f1=make_test_dice]`这个frame没有变，也就是说我们没有在另一个`[f2=make_test_dice]`里操作，那么无论我们执行多少次`dice(*args)`，变量`index`的值始终是循环的，因为根据`environment diagram`的原则，它的作用域`f1`没有消失。

### Q7

在Problem 7提供的样例中，有几个有趣的`Higher Order Function`：

```python
def say_scores(score0, score1):
    """A commentary function that announces the score for each player."""
    
    print("Player 0 now has", score0, "and Player 1 now has", score1)
    return say_scores
```

```python
def announce_lead_changes(last_leader=None):
    """Return a commentary function that announces lead changes."""

    >>> f0 = announce_lead_changes()
    >>> f1 = f0(5, 0)
    Player 0 takes the lead by 5
    >>> f2 = f1(5, 12)
    Player 1 takes the lead by 7
    >>> f3 = f2(8, 12)
    >>> f4 = f3(8, 13)
    >>> f5 = f4(15, 13)
    Player 0 takes the lead by 2

    def say(score0, score1):
        if score0 > score1:
            leader = 0
        elif score1 > score0:
            leader = 1
        else:
            leader = None
        if leader != None and leader != last_leader:
            print('Player', leader, 'takes the lead by', abs(score0 - score1))
        return announce_lead_changes(leader)

    return say
```

其中的`say`函数，返回值为`announce_lead_changes(leader)`，因为这是一个`call expression`，所以会重新建立一个`environment diagram`，其中的`formal parameter`由刚执行完毕的`say`函数给出，并作为即将执行的`announce_lead_changes`的参数，又传入以它为`parent`的`say`函数中使用。

```python
def both(f, g):
    """Return a commentary function that says what f says, then what g says."""

    NOTE: the following game is not possible under the rules, it's just
    an example for the sake of the doctest

    >>> h0 = both(say_scores, announce_lead_changes())
    >>> h1 = h0(10, 0)
    Player 0 now has 10 and Player 1 now has 0
    Player 0 takes the lead by 10
    >>> h2 = h1(10, 8)
    Player 0 now has 10 and Player 1 now has 8
    >>> h3 = h2(10, 17)
    Player 0 now has 10 and Player 1 now has 17
    Player 1 takes the lead by 7
    
    def say(score0, score1):
        return both(f(score0, score1), g(score0, score1))
    return say
```

**母函数返回子函数的同时，子函数返回母函数**--这样做的好处在于**一直跟随`leader`的变化，同时可以连续使用`(score0,score1)`的格式**。在CS 61A提供的文档中，表明这是`commentary function`的常用写法（即利用`Higher Order Function`）.

![image-20210713192008394](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210713192015.png)

## Disc 02

一道很有趣的**HOF**题目：

```python
y = "y"
h = y

def y(y):
    h = "h"
    if y == h:
        return y + "i"
    y = lambda y: y(h)
    return lambda h: y(h)

y = y(y)(y)
```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210714155901.png" alt="image-20210714155901223" style="zoom: 67%;" />

进行变量查找时，先在该作用域内查找对应的变量名称和值，如果找不到，进入其`parent frame`中查找，依此递推。所以在程序段最后调用`y`时，它所指向的应该是`global frame`中的`func y(y)`，而不是`func y(y) frame`中的$$\lambda(y)$$ . 与之相反的是，`return lambda h: y(h)`中的`y`则是来自于本`frame`中的`y = lambda y: y(h)`.

## F20 Lecture 8

主要围绕递归进行讨论：

递归的主要原则就是通过函数的递归，逐步将原始问题转化为更简单的问题，最终将问题定位到**base case**上，递归结束，并给之前使用的函数逐个提供返回值。

递归的依据是数学归纳法，即在证明（或者说给出）`k=1`和`k=n-1`的解法之后，即可证明（推断出）`k=n`的情况。**我们也可以依据这一原则验证我们写出的递归函数是否正确，即分别验证`k=1`的情况，并假定`k=n-1`的情况是正确的，观察我么能否得到需要的`k=n`的结果。**

在写递归函数时，不要尝试推导递归过程，**尝试用抽象思维定义函数**。

### mutual recursion

此种情况适用于单一递归函数解决起来比较繁琐，或者不适于解决的问题：

*e.g. 银行卡号计算问题：*

```python
def sum_digits(n):
	if n < 10:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return sum_digits(all_but_last) + last

def luhn_sum(n):
    if n < 10:
        return n
    else:
        all_but_last, last = n // 10, n % 10
        return luhn_sum_double(all_but_last) + last
    
def luhn_sum_double(n):
    all_but_last, last = n // 10, n % 10
    last = sum_digits(2*last)
    if n < 10:
        return last
    else:
        return luhn_sum(all_but_last)+last
```

这里的`mutual recursion`实质上是针对奇偶两种情况的讨论，而也正因为如此，我们可以将两个函数合并到一个函数内来写：

```python
def luhn_sum(n, i=1):
    if n < 10:
        return sum_digits(2*n) if i % 2 == 1 else n
    else:
        all_but_last, last = n // 10, n % 10
        if i % 2 == 1:
            i += 1
            return luhn_sum(all_but_last, i) + last
        else:
            i += 1
            last = sum_digits(2*last)
            return luhn_sum(all_but_last, i) + last
```

只要设置一个奇偶指示标志即可。

### trick

遇到复杂的递归问题如何解决？我们要设想在问题解决的前一步乃至前几步的变化，比如**汉诺塔**问题，我们正是借助于对`k=n-1`的情况的了解，进行参数变换，并将`k=n`的问题成功转化为三个步骤。再比如这个问题：

> n个自然数中取出r个数字的组合

首先我们举例：654321，6选4，我们可以将问题分为如下几种情况：

> 1. 固定6，问题转化为从54321这5个数字中选3个数
> 2. 固定5，问题转化为从4321这4个数字中选3个数（无6）
> 3. 固定4，问题转化为从321这3个数字中选3个数（无56）

一开始的思路是想把这四步写成递归，但是发现存在问题：这几步是分别独立的步骤，**我们无法在递归程序中先固定6，之后又不考虑6**，也就是说不可能按照时间顺序先后发生。

于是，我们将上边的**情况1**的后续步骤写出来：

> 固定6，问题转化为从54321这**5**个数字中选**3**个数->固定4（已有64），问题转化为从5321这**4**个数字中选**2**个数->固定3（已有456），问题转化为从521这**3**个数字中选**1**个数......

这个步骤，是可以写作递归的！于是前边的几种情况，我们可以考虑写成循环(`iteration`).（**这也符合将递归变成一个simpler question的准则，转化后的问题又是一个可以写成一个有iteration的，可以继续分解的子问题...**）

于是我们接下来思考，递归的`base case`是什么？通过上边的案例，不难发现是`r=1`。在`base case`时，要做什么？就是把之前已经被固定（选择好的）数字输出，**为了达到这一目的，我们将之前遍历过的数字用数字保存起来**。

```python
a = []
for i in range(100):
    a.append(0)

def list_r_from_n(n,r):
    for i in range(n,r-1,-1):
        # 保存遍历过的数字
        
        a[r]=i
        # base case:
        
        if r == 1:
            for j in range(a[0],0,-1):
                print(a[j])
            print(end='\n')
        # 不可以a.clear()
        
        else:
            list_r_from_n(n - 1, r - 1)

a[0]=r
```

注意在保存遍历过的数字时，不要使用`a.append(i)`和`a.clear()`的方式，因为最外层的循环并非仅仅会经历`n-r+1`次，直接清空整个列表会导致排在前边的数据缺失。

此外，递归也可以运用在`higher order function`中，如：

```python
def repeat(i):
    if i == 0:
    	return x
    else:
    	return f(repeat(i - 1))
return repeat
```



