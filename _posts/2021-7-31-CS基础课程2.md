---
layout:		post
title:		CS基础课程2
subtitle:	Modern C++ course for CV (2020)-Lecture1
date:		2021-7-31
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
   - C++
   - CMake
   - CS基础课程笔记
---

# Lecture 1

## 编译过程

我们有许多编译器可以选择，比如`clang, g++`等等，如果我们想要编译的是`C`文件，那么可以使用`gcc`。编译过程包括：首先预处理，转换为`.i`文件，这一步需要展开所有的宏定义、预编译`#inclede`命令、删除注释等等；之后把文件内容进行**词法分析、语法分析**，转化为**汇编语言**，即`.s`文件；第三步为了让机器读取代码，还需要转化为**机器语言**，即二进制代码（也是所说的库）-`.o`文件，最后链接目标代码，生成**可执行文件**.

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731111340.png" alt="image-20210731111340507" style="zoom:50%;" />

1. ```bash
   clang++ -E main.cpp
   ```

2. ```bash
   clang++ -S main.i
   ```

3. ```bash
   clang++ -c main.s
   ```

4. ```bash
   clang++ main.o -o main
   ```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731112408.png" alt="image-20210731112408724" style="zoom:50%;" />

> 优化主要包含进行跳转和延迟退栈两种优化，`O~`选项将使编译速度减慢，但是通常产生的代码执行速度会更快

> `-Wall`表示打印出警告信息，如果要关闭所有警告信息，使用`-w`

### Libraries

- library是什么？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731112926.png" alt="image-20210731112926554" style="zoom:50%;" />

在编译时，如果将函数的定义也放在头文件内，将会导致运行变慢，因为没有使用linker，每次调用都会直接使用定义在其中的函数。

### link library

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731125102.png" alt="image-20210731125102493" style="zoom:50%;" />

出现该错误的原因是我们在主函数文件`program.cpp`中包含的是`tools.hpp`，也就是说程序完全不知道到哪里去寻找函数`SomeFunc()`的实现，他只知道存在这个函数（该函数的实现被我们放在`tools.cpp`中，但是我们没有告诉编译器这一点）。

所以我们要做的是：先让编译器生成一个`tools`库；之后要把`tools`和`program`链接起来，这样当`program.cpp`中找到`tools.h`时，也就知道其中函数`SomeFunc()`的实现被放在哪里了。

对于这种较为简单的情形，我们可以做如下操作：

```bash
# 生成tools.o库文件（第三步：编译）
g++ --std=c++17 -Wall -O0 tools.cpp -c

# 生成main.o库文件（第三步：编译）
g++ --std=c++17 -Wall -O0 main.cpp -c

#链接两者！
g++ --std=c++17 -Wall -O0 main.o tools.o -o main
```

在做链接时，需要注意**越是底层的库，越往后边写**。

**当然，我们也可以在主程序直接包含`tools.cpp`，可以直接一步用`-o`搞定，不需要单独链接库了，但这不是一种好的方法**。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731131645.png" alt="image-20210731131645773" style="zoom:50%;" />

也就是说，在`linking`时，会**将函数声明定位到它的已经经过编译的实现上**。而为了完成这一点，我们需要的`library`需要包括两个部分：

- 一个包含声明的头文件
- 经过编译的二进制代码库函数实现

### How to build libraries

现在的情况是我们**自己定义了库文件**，并将库文件中的函数声明在头文件中：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731135146.png" alt="image-20210731135146844" style="zoom:50%;" />

> `-L`参数用来指定程序要链接的库，`-l`参数紧接着就是库名

首先将库文件编译为一个`object file`，这一步对应着C++文件编译过程中的**第三步**，**将文件转化为二进制代码**；之后将其**组合建立一个静态库**(`rcs`)，里边是`binary code`，接下来把库**链接**到`main`文件里，即告知程序`function/symbol`的位置。

### Build systems

发展历程：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140111.png" alt="image-20210731140111783" style="zoom:50%;" />

> Cmake是一个*MetaBuild System*，通过我们写好的CMakeLists.txt生成makefile，系统会根据makefile当中的指令去编译和链接程序

## cmake使用

cmake的教程可以参考：

https://github.com/ttroy50/cmake-examples

cmake的官方文档写的有些过于晦涩，这个教程相对清晰明了，先掌握一些cmake的基本用法即可。

本节课作业中的内容对应着该GitHub教程的`01-Basic`和`02-sub-project`的部分内容。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140139.png" alt="image-20210731140139832" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140345.png" alt="image-20210731140345122" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140947.png" alt="image-20210731140947572" style="zoom:50%;" />

## Git的使用

**Git**的命令介绍可以参考：https://www.runoob.com/git/git-basic-operations.html

### 本地仓库

在学习**Git**过程中遇到的几个简易命令：

- 工作区、暂存区、版本库(`.git`)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111061825173.jpeg" alt="git-repo" style="zoom: 80%;" />

1. `checkout`被替换

在创建或者切换分支时，使用`switch`命令代替：

```bash
# 切换分支
git switch newBranch

# 创建分支
git switch -c newBranch
```

在恢复文件内容时，使用`restore`命令代替：

```bash
# 从版本库舍弃工作区(working tree)修改（或者从版本库恢复工作区文件）
git restore readme.txt

# 从index(stage)恢复working tree
git restore --worktree readme.txt

# 从版本库master恢复暂存区(stage/index)
git restore --stage readme.txt

# 从版本库master同时恢复工作区与暂存区
git restore --source=HEAD --staged --worktree readme.txt
```

2. `reset`用于**版本回退**+**撤销修改**

```bash
# 版本回退(已经提交到了本地版本库内)
# HEAD/HEAD^^/HEAD~100/commit-id
git reset --hard HEAD^

# 使用reflog查看commit-id
git reflog

# unstage(撤销暂存区修改)
git reset HEAD readme.txt
```

3. `diff`的使用

```bash
# 比较working tree & stage
git diff readme.txt

# 比较暂存区与版本库
git diff --cached readme.txt

# 比较工作区与版本库
# HEAD如果指向master分支，也可以换成master
# HEAD也可以写作某个commit-id
git diff HEAD readme.txt

# 同理，我们可以比较暂存区与某个指定的commit-id
git diff --cached [<commit-id>] readme.txt

# 或者比较两个commit-id的差异
git diff [<commit-id>] [<commit-id>]
```

此外，`git diff`还可以用来打补丁（`patch`），这里就先不列出具体方法了。

4. 其余一些基本命令

- `git init`
- `git add`
- `git commit -m`
- `git rm`(从版本库中删除文件)
- `git tag <tagname>`创建标签

### 远程仓库

#### push

1. 注意一开始要在自己本地生成`SSH Key`，这样`Github`才允许把远程仓库和本地仓库关联起来并进行后续操作
2. 关联本地与远程命令：`git remote add origin git@github.com:michaelliao/learngit.git`

> 为什么是`origin`？这是远程库的名字，而非仓库本身的名字，对于不同的远程服务器上的同样的仓库，名字应当不同（`server-1`,`server-2`,`server-3`...），一般来说就关联一个远程库，习惯命名为`origin`。

3. 第一次推送：`git push -u origin master`

> ```bash
> git push <远程主机名> <本地分支名>:<远程分支名>
> ```
>
> 遵循**来源地:目的地**，所以`git push`命令的顺序是**本地分支:远程分支**
>
> - 如果远程分支被省略，则表示将本地分支推送到与之存在**追踪关系**的远程分支。
> - 如果本地分支被省略，则表示推送一个空分支，等同于`git push origin --delete master`，会将远程主机上的`master`分支删除
> - 如果当前只有一个追踪分支，则可以简略为`git push`
> - 如果当前分支与多个主机存在追踪关系，则可以使用`-u`选项指定一个默认主机，这样后面就可以不加任何参数使用git push

4. 查看远程库信息：

```bash
git remote -v
```

5. 解除本地与远程的绑定关系：

```bash
git remote rm origin
```

#### clone

### 分支管理

参看廖雪峰老师的教程，这部分写的很清楚：https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424

1. 注意我们可能需要处理**分支冲突**，解决方法也很简单，我们只要让某个分支领先于另一个分支即可，这样一来便会直接使用`fast-forward`模式进行合并
2. 同时，我们不应该做回退分支合并，即不能让一个最新的提交往回合并（这其实也是没有意义的）
3. 分支相关操作：

```bash
# 合并dev分支
git merge dev

# 查看分支结构
git branch

# 删除分支
git branch -d dev

# 强制删除分支（该分支可能还未被merge）
git branch -D dev

# 创建分支
git switch -c dev

# 进入分支
git switch dev

# 查看分支合并图
git log --graph --pretty=oneline --abbrev-commit

# 保留分支结构(普通模式)，合并
git merge --no-ff -m "merge with no-ff" dev
```

当我们使用**普通模式**进行合并时，代码结构如下：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111062303336.png" alt="git-no-ff-mode" style="zoom:80%;" />

4. **Bug**分支

引入一个新命令：`stash`，作用如下：

> Using the git stash command, developers can temporarily shelve changes made in the working directory. It allows them to quickly switch contexts when they are not quite ready to commit changes. And it allows them to more easily switch between branches.

```bash
# 在当前分支下，储存现场，使得git status为空，工作区是干净的
git stash

# 查看工作现场储存情况
git stash list

# 恢复工作现场，但不删除stash内容
git stash apply

# 删除stash内容
git stash drop

# 同时完成以上两项操作
git stash pop
```

需要注意的是，考虑到原本在`master`主分支中存在的bug也在`dev`分支中存在，所以我们需要同样修复`dev`中相同的问题，可以考虑在`dev`分支中**复制修复bug的对应操作的commit-id**，从而避免重复劳动。

```bash
git cherry-pick [<commit-id>]
```

> 在使用`cherry-pick`之前，我们需要先将之前使用`stash`暂存起来还没有`commit`的内容提交，否则会提示错误：`error: Your local changes to the following files would be overwritten by merge`

#### 多人协作

https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320

- 创建本地对应的远程分支：

```bash
git switch -c dev origin/dev
```

- 多人协作推送流程：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111070125878.png" alt="image-20211107012558802" style="zoom:50%;" />

### 其他一些教程

[100秒git介绍](https://www.youtube.com/watch?v=hwP7WQkmECE)

[Git官方文档-分支的新建与合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)

[一个更加完整的git视频教程](https://www.youtube.com/watch?v=gQSd2lFkZHk)

