---
layout:		post
title:		CS基础课程2
subtitle:	Modern C++ course for CV (2020)-Lecture1
date:		2021-7-31
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
   - C++
   - CMake
   - Git
   - CS基础课程笔记
---

# Lecture 1

## 编译过程

> 以下内容来自于CS 61C：
>
> C/C++是一种**编译**型语言（`Compiler`），而非**解释**型语言（如`Python`）："C compilers map C programs directly into architecture-specific machine code (string of 1s and 0s".
>
> <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206214747874.png" alt="image-20211206214747874" style="zoom:50%;" />
>
> <img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211206215609119.png" alt="image-20211206215609119" style="zoom:50%;" />
>
> 而也正是基于编译型语言的原因，在编译阶段可以做许多优化：比如修改文件后编译器会指定(`Makefiles`)只编译更改后的文件，而不是做修改后要把项目里所有文件都编译一遍。这是编译型语言的一大优点之一。
>
> 但同时，编译型语言意味着编译生成的文件是`architecture-specific`的："Executable must be rebuilt on each new system". 另一方面，由于我们每次更改文件后都需要经过编译->运行的过程，这可能会拖慢我们的速度，这一点可使用`parallel compile`的方法抑制：`make -j`.

我们有许多编译器可以选择，比如`clang, g++`等等，如果我们想要编译的是`C`文件，那么可以使用`gcc`。编译过程包括：

1. 首先预处理，转换为`.i`文件，这一步需要展开所有的**宏定义**（**做简单的文本替换）、处理`#id/#endif`命令、预编译`#include`命令(insert xxx.h into output directly**)、**删除注释**(**replace with a single space**)等等，我们可以使用`-save-temps`来检查预编译文件。
2. 之后把文件内容进行**词法分析、语法分析**，转化为**汇编语言**，即`.s`文件；
3. 第三步为了让机器读取代码，还需要转化为**机器语言**，即二进制代码（也是所说的库）-`.o`文件；
4. 最后链接目标代码，生成**可执行文件**.

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731111340.png" alt="image-20210731111340507" style="zoom:50%;" />

1. ```bash
   clang++ -E main.cpp
   ```

2. ```bash
   clang++ -S main.i
   ```

3. ```bash
   clang++ -c main.s
   ```

4. ```bash
   clang++ main.o -o main
   ```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731112408.png" alt="image-20210731112408724" style="zoom:50%;" />

> 优化主要包含进行跳转和延迟退栈两种优化，`O~`选项将使编译速度减慢，但是通常产生的代码执行速度会更快

> `-Wall`表示打印出警告信息，如果要关闭所有警告信息，使用`-w`

### Libraries

- library是什么？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731112926.png" alt="image-20210731112926554" style="zoom:50%;" />

在编译时，如果将函数的定义也放在头文件内，将会导致运行变慢，因为没有使用linker，每次调用都会直接使用定义在其中的函数。

### link library

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731125102.png" alt="image-20210731125102493" style="zoom:50%;" />

出现该错误的原因是我们在主函数文件`program.cpp`中包含的是`tools.hpp`，也就是说程序完全不知道到哪里去寻找函数`SomeFunc()`的实现，他只知道存在这个函数（该函数的实现被我们放在`tools.cpp`中，但是我们没有告诉编译器这一点）。

所以我们要做的是：先让编译器生成一个`tools`库；之后要把`tools`和`program`链接起来，这样当`program.cpp`中找到`tools.h`时，也就知道其中函数`SomeFunc()`的实现被放在哪里了。

对于这种较为简单的情形，我们可以做如下操作：

```bash
# 生成tools.o库文件（第三步：编译）
g++ --std=c++17 -Wall -O0 tools.cpp -c

# 生成main.o库文件（第三步：编译）
g++ --std=c++17 -Wall -O0 main.cpp -c

#链接两者！
g++ --std=c++17 -Wall -O0 main.o tools.o -o main
```

在做链接时，需要注意**越是底层的库，被依赖的项，越往后边写**。

**当然，我们也可以在主程序直接包含`tools.cpp`，可以直接一步用`-o`搞定，不需要单独链接库了，但这不是一种好的方法**。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731131645.png" alt="image-20210731131645773" style="zoom:50%;" />

也就是说，在`linking`时，会**将函数声明定位到它的已经经过编译的实现上**。而为了完成这一点，我们需要的`library`需要包括两个部分：

- 一个包含声明的头文件
- 经过编译的二进制代码库函数实现

### How to build libraries

现在的情况是我们**自己定义了库文件**，并将库文件中的函数声明在头文件中：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731135146.png" alt="image-20210731135146844" style="zoom:50%;" />

> `-L`参数用来指定程序要链接的库，`-l`参数紧接着就是库名

首先将库文件编译为一个`object file`，这一步对应着C++文件编译过程中的**第三步**，**将文件转化为二进制代码**；之后将其**打包组合建立一个静态库**(`ar rcs`)，后边的`.`表示库所在位置，库里边是`binary code`，接下来把库**链接**到`main`文件里，即告知程序`function/symbol`的位置。

我们也可以用这种方法对上边的`program&tools`案例进行测试，结果是一样的，只不过我们先把两个`.o`文件打包成了静态链接库而已：

```bash
# 打包成静态链接库
ar rcs libtools.a main.o tools.o

# linking
g++ --std=c++17 main.cpp -L . -ltools -o main_1
```



### Build systems

发展历程：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140111.png" alt="image-20210731140111783" style="zoom:50%;" />

> Cmake是一个*MetaBuild System*，通过我们写好的CMakeLists.txt生成makefile，系统会根据makefile当中的指令去编译和链接程序

## cmake使用

cmake的教程可以参考[这里](https://github.com/ttroy50/cmake-examples).

cmake的官方文档写的有些过于晦涩，这个教程相对清晰明了，先掌握一些cmake的基本用法即可。

本节课作业中的内容对应着该GitHub教程的`01-Basic`和`02-sub-project`的部分内容。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140139.png" alt="image-20210731140139832" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140345.png" alt="image-20210731140345122" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140947.png" alt="image-20210731140947572" style="zoom:50%;" />

## Git的使用

**Git**的命令介绍可以参考[这里](https://www.runoob.com/git/git-basic-operations.html)。

### 本地仓库

在学习**Git**过程中遇到的几个简易命令：

- 工作区、暂存区、版本库(`.git`)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111061825173.jpeg" alt="git-repo" style="zoom: 80%;" />

1. `checkout`被替换

在**创建或者切换分支**时，使用`switch`命令代替：

```bash
# 切换分支
git switch newBranch

# 创建分支
git switch -c newBranch
```

在**恢复文件内容**时，使用`restore`命令代替,不论使用`–worktree`还是`stage`，我们指的都是**需要恢复的区域**：

```bash
# 撤销工作区(working tree)修改：如果暂存区有文件则恢复到暂存区的样子，如果没有，则恢复到上一次commit的样子，也即版本库master中的样子
git restore readme.txt

# 与上一个一样的效果，因为可省略worktree关键字
git restore --worktree readme.txt

# 撤销暂存区修改，从版本库master恢复暂存区(stage/index)
git restore --staged readme.txt

# 可以指定source关键字，从版本库master当前HEAD同时恢复工作区与暂存区内容
git restore --source=HEAD --staged --worktree readme.txt
```

2. `reset`用于**版本回退**+**撤销修改**

```bash
# 版本回退(已经提交到了本地的版本库master内)
# HEAD/HEAD^^/HEAD~100/commit-id(e.g. bavdc8743)
# 该命令把工作区（worktree）与暂存区（index/stage）的内容替换成指定的版本库master的内容，也即把他们回退到版本库的某个版本
git reset --hard HEAD^

# 使用reflog查看commit-id
git reflog

# unstage(撤销暂存区修改)，该命令撤销git add的在暂存区的内容
git reset HEAD readme.txt
```

根据上述代码，我们不难发现`--hard`主要用来撤销工作区的内容，当我们使用`--hard`后，工作区+暂存区的修改都会回退掉。

3. `diff`的使用

```bash
# 比较working tree & index/stage
git diff readme.txt

# 比较暂存区与版本库
git diff --cached readme.txt

# 比较工作区与版本库
# HEAD如果指向master分支，也可以换成master
# HEAD也可以写作某个commit-id
git diff HEAD readme.txt

# 同理，我们可以比较暂存区与某个指定的commit-id
git diff --cached [<commit-id>] readme.txt

# 或者比较两个commit-id的差异
git diff [<commit-id>] [<commit-id>]
```

此外，`git diff`还可以用来打补丁（`patch`），这里就先不列出具体方法了。

4. 其余一些基本命令

- `git init`
- `git add`
- `git commit -m`
- `git rm`(从**版本库**中删除文件)
- `git tag <tagname>`创建标签

### 远程仓库

#### push

1. 注意一开始要在自己**本地生成**`SSH Key`，这样`Github`才允许**把远程仓库和本地仓库关联起来并进行后续操作**
2. 关联本地与远程命令：`git remote add origin git@github.com:michaelliao/learngit.git`

> 为什么是`origin`？这是**远程库的默认名字**，而非仓库本身的名字，对于不同的远程服务器上的同样的仓库，名字应当不同（`server-1`,`server-2`,`server-3`...），一般来说就关联一个远程库，习惯命名为`origin`。

3. 第一次推送：`git push -u origin master`

> ```bash
> git push <远程主机名> <本地分支名>:<远程分支名>
> ```
>
> 在这里，远程主机名为`origin`，遵循**来源地:目的地**，所以`git push`命令的顺序是**本地分支:远程分支**
>
> - 如果远程分支被省略，则表示将本地分支推送到与之存在**追踪关系**的远程分支:
>
> ```bash
> git push origin master
> ```
>
> - 如果本地分支被省略，则表示推送一个空分支，等同于`git push origin --delete master`，会将远程主机上的`master`分支删除：
>
> ```bash
> git push origin :master
> ```
>
> - 如果当前只有一个追踪分支，则可以简略为`git push`
> - 如果当前分支与多个主机存在追踪关系，则可以使用`-u`选项指定一个默认主机，这样后面就可以不加任何参数使用git push

4. 查看远程库信息：

```bash
git remote -v
```

5. 解除本地与远程的绑定关系：

```bash
git remote rm origin
```

#### clone

### 分支管理

参看廖雪峰老师的[教程](https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424)，这部分写的很清楚。

比如创建了一个分支并在此分支上提交了一次之后，分支结构就会变成下图所示的样子：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211205165634501.png" alt="image-20211205165634501" style="zoom:50%;" />

1. 注意我们可能需要处理**分支冲突**，解决方法也很简单，我们只要让某个分支领先于另一个分支即可，这样一来便会直接使用`fast-forward`模式进行合并
2. 同时，我们不应该做回退分支合并，即不能让一个最新的提交往回合并（这其实也是没有意义的）我们只能把以前的分支合并到我们新的分支上：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211205165850740.png" alt="image-20211205165850740" style="zoom: 33%;" />

在这之后，我们可以将`dev`分支删除，于是便只剩下`master`主分支了。

1. 分支相关操作：

```bash
# 将dev分支合并到当前分支中
# fast-forward合并模式，将master指向dev分支的当前提交位置
git merge dev

# 查看分支结构
git branch

# 删除分支
git branch -d dev

# 强制删除分支（该分支可能还未被merge）
git branch -D dev

# 创建分支
git switch -c dev

# 进入分支
git switch dev

# 查看分支合并图
git log --graph --pretty=oneline --abbrev-commit

# 保留分支结构(普通模式)，合并
git merge --no-ff -m "merge with no-ff" dev
```

什么时候无法使用`fast-forward`模式合并呢？当我们在两个分支上分别有提交的时候：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/image-20211205170638223.png" alt="image-20211205170638223" style="zoom: 33%;" />

此时我们应当手动修改文件（文件中会显示提示内容）处理冲突，之后再进行分支合并。

> 通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。
>
> 如果要强制禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

当我们使用**普通模式**进行合并时，代码结构如下：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111062303336.png" alt="git-no-ff-mode" style="zoom:80%;" />

4. **Bug**分支

引入一个新命令：`stash`，作用如下：

> Using the git stash command, developers can temporarily shelve changes made in the working directory. It allows them to quickly switch contexts when they are not quite ready to commit changes. And it allows them to more easily switch between branches.

```bash
# 在当前分支下，储存现场，使得git status为空，工作区是干净的
git stash

# 查看工作现场储存情况
git stash list

# 恢复工作现场，但不删除stash内容
git stash apply

# 删除stash内容
git stash drop

# 同时完成以上两项操作
git stash pop
```

需要注意的是，考虑到原本在`master`主分支中存在的bug也在`dev`分支中存在，所以我们需要同样修复`dev`中相同的问题，可以考虑在`dev`分支中**复制修复bug的对应操作的commit-id**，从而避免重复劳动。

```bash
git cherry-pick [<commit-id>]
```

> 在使用`cherry-pick`之前，我们需要先将之前`dev`分支中使用`stash`暂存起来的、还没有`commit`的内容提交，否则会提示错误：`error: Your local changes to the following files would be overwritten by merge`

#### 多人协作

[教程](https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320)

- 创建本地对应的远程分支：

```bash
git switch -c dev origin/dev
```

- 多人协作推送流程：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111070125878.png" alt="image-20211107012558802" style="zoom:50%;" />

这里，`git pull`的作用相当于`git fetch + git merge`，先把远程库的内容下载到版本库中，之后在本地将分支合并。

一张大佬制作的**Git**命令图：

[原图作者地址](https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3)

![git思维导图](https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111072200435.png)

### 其他一些教程

[100秒git介绍](https://www.youtube.com/watch?v=hwP7WQkmECE)

[Git官方文档-分支的新建与合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)

[一个更加完整的git视频教程](https://www.youtube.com/watch?v=gQSd2lFkZHk)

