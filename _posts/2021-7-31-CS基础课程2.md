---
layout:		post
title:		CS基础课程2
subtitle:	Modern C++ course for CV (2020)-Lecture1
date:		2021-7-31
author:		shaopu
header-img:	img/code.png
catalog:	true
tags:
   - C++
   - CMake
   - CS基础课程笔记
---

# Lecture 1

## 编译过程

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731111340.png" alt="image-20210731111340507" style="zoom:50%;" />

1. ```bash
   clang++ -E main.cpp
   ```

2. ```bash
   clang++ -S main.i
   ```

3. ```bash
   clang++ -c main.s
   ```

4. ```bash
   clang++ main.o -o main
   ```

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731112408.png" alt="image-20210731112408724" style="zoom:50%;" />

## Libraries

- library是什么？

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731112926.png" alt="image-20210731112926554" style="zoom:50%;" />

在编译时，如果将函数的定义也放在头文件内，将会导致运行变慢，因为没有使用linker，每次调用都会直接使用定义在其中的函数

## 当link library时

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731125102.png" alt="image-20210731125102493" style="zoom:50%;" />

未经过`preprocessor`的步骤（未识别到**头文件包含行**，告知在`linking`时要把`library/object files`链接起来并`search` functions的`implementation`），相当于没有包含任何其他信息给linker

具体来说：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731131645.png" alt="image-20210731131645773" style="zoom:50%;" />

也就是说，在`linking`时，会**将函数声明定位到它的已经经过编译的实现上**。而为了完成这一点，我们需要的`library`需要包括两个部分：

- 一个包含声明的头文件
- 经过编译的二进制代码库函数实现

## How to build libraries

现在的情况是我们**自己定义了库文件**，并将库文件中的函数声明在头文件中：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731135146.png" alt="image-20210731135146844" style="zoom:50%;" />

首先将库文件编译为一个`object file`，这一步对应着C++文件编译过程中的第三步，**将文件转化为二进制代码**；之后将其组合建立一个静态库(`rcs`)，里边是`binary code`，接下来把库链接到`main`文件里，即告知程序`function/symbol`的位置。

## Build systems

发展历程：

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140111.png" alt="image-20210731140111783" style="zoom:50%;" />

> Cmake是一个*MetaBuild System*，通过我们写好的CMakeLists.txt生成makefile，系统会根据makefile当中的指令去编译和链接程序

## cmake使用

cmake的教程可以参考：

https://github.com/ttroy50/cmake-examples

cmake的官方文档写的有些过于晦涩，这个教程相对清晰明了，先掌握一些cmake的基本用法即可。

本节课作业中的内容对应着该GitHub教程的`01-Basic`和`02-sub-project`的部分内容。

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140139.png" alt="image-20210731140139832" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140345.png" alt="image-20210731140345122" style="zoom:50%;" />

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/20210731140947.png" alt="image-20210731140947572" style="zoom:50%;" />

## Git的使用

**Git**的命令介绍可以参考：https://www.runoob.com/git/git-basic-operations.html

### 本地仓库

在学习**Git**过程中遇到的几个简易命令：

- 工作区、暂存区、版本库(`.git`)

<img src="https://shaopu-blog.oss-cn-beijing.aliyuncs.com/img/202111061825173.jpeg" alt="git-repo" style="zoom: 80%;" />

1. `checkout`被替换

在创建或者切换分支时，使用`switch`命令代替：

```bash
# 切换分支
git switch newBranch

# 创建分支
git switch -c newBranch
```

在恢复文件内容时，使用`restore`命令代替：

```bash
# 从版本库舍弃工作区(working tree)修改（或者从版本库恢复工作区文件）
git restore readme.txt

# 从index(stage)恢复working tree
git restore --worktree readme.txt

# 从版本库master恢复暂存区(stage/index)
git restore --stage readme.txt

# 从版本库master同时恢复工作区与暂存区
git restore --source=HEAD --staged --worktree readme.txt
```

2. `reset`用于**版本回退**+**撤销修改**

```bash
# 版本回退(已经提交到了本地版本库内)
# HEAD/HEAD^^/HEAD~100/commit-id
git reset --hard HEAD^

# 使用reflog查看commit-id
git reflog

# unstage(撤销暂存区修改)
git reset HEAD readme.txt
```

3. `diff`的使用

```bash
# 比较working tree & stage
git diff readme.txt

# 比较暂存区与版本库
git diff --cached readme.txt

# 比较工作区与版本库
# HEAD如果指向master分支，也可以换成master
# HEAD也可以写作某个commit-id
git diff HEAD readme.txt

# 同理，我们可以比较暂存区与某个指定的commit-id
git diff --cached [<commit-id>] readme.txt

# 或者比较两个commit-id的差异
git diff [<commit-id>] [<commit-id>]
```

此外，`git diff`还可以用来打补丁（`patch`），这里就先不列出具体方法了。

4. 其余一些基本命令

- `git init`
- `git add`
- `git commit -m`
- `git rm`(从版本库中删除文件)

### 远程仓库

#### push

1. 注意一开始要在自己本地生成`SSH Key`，这样`Github`才允许把远程仓库和本地仓库关联起来并进行后续操作
2. 关联命令：`git remote add origin git@github.com:michaelliao/learngit.git`

> 为什么是`origin`？这是远程库的名字，而非仓库本身的名字，对于不同的远程服务器上的同样的仓库，名字应当不同（`server-1`,`server-2`,`server-3`...），一般来说就关联一个远程库，习惯命名为`origin`。

3. 第一次推送：`git push -u origin master`

> ```bash
> git push <远程主机名> <本地分支名>:<远程分支名>
> ```
>
> 遵循**来源地:目的地**，所以`git push`命令的顺序是**本地分支:远程分支**
>
> - 如果远程分支被省略，则表示将本地分支推送到与之存在**追踪关系**的远程分支。
> - 如果本地分支被省略，则表示推送一个空分支，等同于`git push origin --delete master`，会将远程主机上的`master`分支删除
> - 如果当前只有一个追踪分支，则可以简略为`git push`
> - 如果当前分支与多个主机存在追踪关系，则可以使用`-u`选项指定一个默认主机，这样后面就可以不加任何参数使用git push

4. 查看远程库信息：

```bash
git remote -v
```

5. 解除本地与远程的绑定关系：

```bash
git remote rm origin
```





### 其他一些教程

[100秒git介绍](https://www.youtube.com/watch?v=hwP7WQkmECE)

[Git官方文档-分支的新建与合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)

[一个更加完整的git视频教程](https://www.youtube.com/watch?v=gQSd2lFkZHk)

